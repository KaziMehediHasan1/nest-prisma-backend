
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Profile
 * 
 */
export type Profile = $Result.DefaultSelection<Prisma.$ProfilePayload>
/**
 * Model EventType
 * 
 */
export type EventType = $Result.DefaultSelection<Prisma.$EventTypePayload>
/**
 * Model Venue
 * 
 */
export type Venue = $Result.DefaultSelection<Prisma.$VenuePayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Shift
 * 
 */
export type Shift = $Result.DefaultSelection<Prisma.$ShiftPayload>
/**
 * Model Booking
 * 
 */
export type Booking = $Result.DefaultSelection<Prisma.$BookingPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Decoration
 * 
 */
export type Decoration = $Result.DefaultSelection<Prisma.$DecorationPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model Amenities
 * 
 */
export type Amenities = $Result.DefaultSelection<Prisma.$AmenitiesPayload>
/**
 * Model FileInstance
 * 
 */
export type FileInstance = $Result.DefaultSelection<Prisma.$FileInstancePayload>
/**
 * Model Conversation
 * 
 */
export type Conversation = $Result.DefaultSelection<Prisma.$ConversationPayload>
/**
 * Model DirectMessage
 * 
 */
export type DirectMessage = $Result.DefaultSelection<Prisma.$DirectMessagePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const FileType: {
  IMAGE: 'IMAGE',
  VIDEO: 'VIDEO',
  AUDIO: 'AUDIO',
  DOCUMENT: 'DOCUMENT'
};

export type FileType = (typeof FileType)[keyof typeof FileType]


export const UserRole: {
  ADMIN: 'ADMIN',
  PLANNER: 'PLANNER',
  SERVICE_PROVIDER: 'SERVICE_PROVIDER',
  VENUE_OWNER: 'VENUE_OWNER',
  GUEST: 'GUEST'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ServiceProviderRole: {
  PHOTOGRAPHER: 'PHOTOGRAPHER',
  VIDEOGRAPHER: 'VIDEOGRAPHER',
  DJ_BAND: 'DJ_BAND',
  CATERING: 'CATERING',
  ENTERTAINER: 'ENTERTAINER'
};

export type ServiceProviderRole = (typeof ServiceProviderRole)[keyof typeof ServiceProviderRole]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE',
  OTHER: 'OTHER'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const BookingStatus: {
  REQUESTED: 'REQUESTED',
  PENDING: 'PENDING',
  CONFIRMED: 'CONFIRMED',
  COMPLETED: 'COMPLETED'
};

export type BookingStatus = (typeof BookingStatus)[keyof typeof BookingStatus]


export const AcceptanceStatus: {
  ACCEPTED: 'ACCEPTED',
  DENIED: 'DENIED'
};

export type AcceptanceStatus = (typeof AcceptanceStatus)[keyof typeof AcceptanceStatus]


export const PaymentStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  FAILED: 'FAILED',
  REFUNDED: 'REFUNDED',
  CANCELLED: 'CANCELLED'
};

export type PaymentStatus = (typeof PaymentStatus)[keyof typeof PaymentStatus]


export const PaymentMethod: {
  CREDIT_CARD: 'CREDIT_CARD',
  DEBIT_CARD: 'DEBIT_CARD',
  PAYPAL: 'PAYPAL',
  BANK_TRANSFER: 'BANK_TRANSFER',
  CASH: 'CASH'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const TableShape: {
  ROUND: 'ROUND',
  OVAL: 'OVAL',
  HALF_MOON: 'HALF_MOON',
  BANQUET: 'BANQUET',
  SQUARE: 'SQUARE',
  HEXAGONAL: 'HEXAGONAL'
};

export type TableShape = (typeof TableShape)[keyof typeof TableShape]


export const SeatingStyle: {
  BANQUET: 'BANQUET',
  THEATER: 'THEATER',
  CLASSROOM: 'CLASSROOM',
  CABARET: 'CABARET',
  U_SHAPED: 'U_SHAPED',
  COCKTAIL: 'COCKTAIL'
};

export type SeatingStyle = (typeof SeatingStyle)[keyof typeof SeatingStyle]


export const LightingStyle: {
  AMBIENT: 'AMBIENT',
  SPOTLIGHTING: 'SPOTLIGHTING',
  FAIRY: 'FAIRY',
  CHANDELIERS: 'CHANDELIERS',
  LED: 'LED',
  NEON: 'NEON',
  GOBO: 'GOBO'
};

export type LightingStyle = (typeof LightingStyle)[keyof typeof LightingStyle]


export const FlowerColor: {
  WHITE: 'WHITE',
  RED: 'RED',
  YELLOW: 'YELLOW',
  PINK: 'PINK',
  PURPLE: 'PURPLE',
  BLUE: 'BLUE',
  GREEN: 'GREEN',
  ORANGE: 'ORANGE'
};

export type FlowerColor = (typeof FlowerColor)[keyof typeof FlowerColor]


export const FlowerType: {
  ROSES: 'ROSES',
  PEONIES: 'PEONIES',
  LILIES: 'LILIES',
  ORCHIDS: 'ORCHIDS',
  TULIPS: 'TULIPS',
  SUNFLOWERS: 'SUNFLOWERS',
  HYDRANGEAS: 'HYDRANGEAS'
};

export type FlowerType = (typeof FlowerType)[keyof typeof FlowerType]


export const Fragrance: {
  FLORAL_SCENTS: 'FLORAL_SCENTS',
  CITRUS_SCENTS: 'CITRUS_SCENTS',
  HERBAL_SCENTS: 'HERBAL_SCENTS',
  OCEANIC_SCENTS: 'OCEANIC_SCENTS',
  WOODY_SCENTS: 'WOODY_SCENTS',
  SPICY: 'SPICY'
};

export type Fragrance = (typeof Fragrance)[keyof typeof Fragrance]


export const BookingType: {
  INSTANT_BOOKING: 'INSTANT_BOOKING',
  REQUEST_BASED_BOOKING: 'REQUEST_BASED_BOOKING'
};

export type BookingType = (typeof BookingType)[keyof typeof BookingType]


export const VenueType: {
  HOTEL: 'HOTEL',
  RESTAURANT: 'RESTAURANT',
  CONFERENCE_HALL: 'CONFERENCE_HALL',
  BANQUET: 'BANQUET',
  RESORT: 'RESORT',
  OUTDOOR: 'OUTDOOR'
};

export type VenueType = (typeof VenueType)[keyof typeof VenueType]

}

export type FileType = $Enums.FileType

export const FileType: typeof $Enums.FileType

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ServiceProviderRole = $Enums.ServiceProviderRole

export const ServiceProviderRole: typeof $Enums.ServiceProviderRole

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type BookingStatus = $Enums.BookingStatus

export const BookingStatus: typeof $Enums.BookingStatus

export type AcceptanceStatus = $Enums.AcceptanceStatus

export const AcceptanceStatus: typeof $Enums.AcceptanceStatus

export type PaymentStatus = $Enums.PaymentStatus

export const PaymentStatus: typeof $Enums.PaymentStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type TableShape = $Enums.TableShape

export const TableShape: typeof $Enums.TableShape

export type SeatingStyle = $Enums.SeatingStyle

export const SeatingStyle: typeof $Enums.SeatingStyle

export type LightingStyle = $Enums.LightingStyle

export const LightingStyle: typeof $Enums.LightingStyle

export type FlowerColor = $Enums.FlowerColor

export const FlowerColor: typeof $Enums.FlowerColor

export type FlowerType = $Enums.FlowerType

export const FlowerType: typeof $Enums.FlowerType

export type Fragrance = $Enums.Fragrance

export const Fragrance: typeof $Enums.Fragrance

export type BookingType = $Enums.BookingType

export const BookingType: typeof $Enums.BookingType

export type VenueType = $Enums.VenueType

export const VenueType: typeof $Enums.VenueType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **Profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.ProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.eventType`: Exposes CRUD operations for the **EventType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventTypes
    * const eventTypes = await prisma.eventType.findMany()
    * ```
    */
  get eventType(): Prisma.EventTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.venue`: Exposes CRUD operations for the **Venue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Venues
    * const venues = await prisma.venue.findMany()
    * ```
    */
  get venue(): Prisma.VenueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.shift`: Exposes CRUD operations for the **Shift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shifts
    * const shifts = await prisma.shift.findMany()
    * ```
    */
  get shift(): Prisma.ShiftDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.booking`: Exposes CRUD operations for the **Booking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bookings
    * const bookings = await prisma.booking.findMany()
    * ```
    */
  get booking(): Prisma.BookingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.decoration`: Exposes CRUD operations for the **Decoration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Decorations
    * const decorations = await prisma.decoration.findMany()
    * ```
    */
  get decoration(): Prisma.DecorationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.amenities`: Exposes CRUD operations for the **Amenities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Amenities
    * const amenities = await prisma.amenities.findMany()
    * ```
    */
  get amenities(): Prisma.AmenitiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fileInstance`: Exposes CRUD operations for the **FileInstance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileInstances
    * const fileInstances = await prisma.fileInstance.findMany()
    * ```
    */
  get fileInstance(): Prisma.FileInstanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.conversation`: Exposes CRUD operations for the **Conversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Conversations
    * const conversations = await prisma.conversation.findMany()
    * ```
    */
  get conversation(): Prisma.ConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.directMessage`: Exposes CRUD operations for the **DirectMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DirectMessages
    * const directMessages = await prisma.directMessage.findMany()
    * ```
    */
  get directMessage(): Prisma.DirectMessageDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.6.0
   * Query Engine version: f676762280b54cd07c770017ed3711ddde35f37a
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Profile: 'Profile',
    EventType: 'EventType',
    Venue: 'Venue',
    Employee: 'Employee',
    Shift: 'Shift',
    Booking: 'Booking',
    Payment: 'Payment',
    Decoration: 'Decoration',
    Review: 'Review',
    Amenities: 'Amenities',
    FileInstance: 'FileInstance',
    Conversation: 'Conversation',
    DirectMessage: 'DirectMessage'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "profile" | "eventType" | "venue" | "employee" | "shift" | "booking" | "payment" | "decoration" | "review" | "amenities" | "fileInstance" | "conversation" | "directMessage"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Profile: {
        payload: Prisma.$ProfilePayload<ExtArgs>
        fields: Prisma.ProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findFirst: {
            args: Prisma.ProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          findMany: {
            args: Prisma.ProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          create: {
            args: Prisma.ProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          createMany: {
            args: Prisma.ProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          delete: {
            args: Prisma.ProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          update: {
            args: Prisma.ProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          deleteMany: {
            args: Prisma.ProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>[]
          }
          upsert: {
            args: Prisma.ProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProfilePayload>
          }
          aggregate: {
            args: Prisma.ProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProfile>
          }
          groupBy: {
            args: Prisma.ProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProfileCountArgs<ExtArgs>
            result: $Utils.Optional<ProfileCountAggregateOutputType> | number
          }
        }
      }
      EventType: {
        payload: Prisma.$EventTypePayload<ExtArgs>
        fields: Prisma.EventTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          findFirst: {
            args: Prisma.EventTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          findMany: {
            args: Prisma.EventTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>[]
          }
          create: {
            args: Prisma.EventTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          createMany: {
            args: Prisma.EventTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>[]
          }
          delete: {
            args: Prisma.EventTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          update: {
            args: Prisma.EventTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          deleteMany: {
            args: Prisma.EventTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>[]
          }
          upsert: {
            args: Prisma.EventTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          aggregate: {
            args: Prisma.EventTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventType>
          }
          groupBy: {
            args: Prisma.EventTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventTypeCountArgs<ExtArgs>
            result: $Utils.Optional<EventTypeCountAggregateOutputType> | number
          }
        }
      }
      Venue: {
        payload: Prisma.$VenuePayload<ExtArgs>
        fields: Prisma.VenueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VenueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VenueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          findFirst: {
            args: Prisma.VenueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VenueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          findMany: {
            args: Prisma.VenueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>[]
          }
          create: {
            args: Prisma.VenueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          createMany: {
            args: Prisma.VenueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VenueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>[]
          }
          delete: {
            args: Prisma.VenueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          update: {
            args: Prisma.VenueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          deleteMany: {
            args: Prisma.VenueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VenueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VenueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>[]
          }
          upsert: {
            args: Prisma.VenueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VenuePayload>
          }
          aggregate: {
            args: Prisma.VenueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVenue>
          }
          groupBy: {
            args: Prisma.VenueGroupByArgs<ExtArgs>
            result: $Utils.Optional<VenueGroupByOutputType>[]
          }
          count: {
            args: Prisma.VenueCountArgs<ExtArgs>
            result: $Utils.Optional<VenueCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Shift: {
        payload: Prisma.$ShiftPayload<ExtArgs>
        fields: Prisma.ShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findFirst: {
            args: Prisma.ShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findMany: {
            args: Prisma.ShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          create: {
            args: Prisma.ShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          createMany: {
            args: Prisma.ShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          delete: {
            args: Prisma.ShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          update: {
            args: Prisma.ShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          deleteMany: {
            args: Prisma.ShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ShiftUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          upsert: {
            args: Prisma.ShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          aggregate: {
            args: Prisma.ShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShift>
          }
          groupBy: {
            args: Prisma.ShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftCountAggregateOutputType> | number
          }
        }
      }
      Booking: {
        payload: Prisma.$BookingPayload<ExtArgs>
        fields: Prisma.BookingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BookingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BookingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findFirst: {
            args: Prisma.BookingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BookingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          findMany: {
            args: Prisma.BookingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          create: {
            args: Prisma.BookingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          createMany: {
            args: Prisma.BookingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BookingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          delete: {
            args: Prisma.BookingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          update: {
            args: Prisma.BookingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          deleteMany: {
            args: Prisma.BookingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BookingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BookingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>[]
          }
          upsert: {
            args: Prisma.BookingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BookingPayload>
          }
          aggregate: {
            args: Prisma.BookingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBooking>
          }
          groupBy: {
            args: Prisma.BookingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BookingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BookingCountArgs<ExtArgs>
            result: $Utils.Optional<BookingCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Decoration: {
        payload: Prisma.$DecorationPayload<ExtArgs>
        fields: Prisma.DecorationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DecorationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DecorationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload>
          }
          findFirst: {
            args: Prisma.DecorationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DecorationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload>
          }
          findMany: {
            args: Prisma.DecorationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload>[]
          }
          create: {
            args: Prisma.DecorationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload>
          }
          createMany: {
            args: Prisma.DecorationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DecorationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload>[]
          }
          delete: {
            args: Prisma.DecorationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload>
          }
          update: {
            args: Prisma.DecorationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload>
          }
          deleteMany: {
            args: Prisma.DecorationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DecorationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DecorationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload>[]
          }
          upsert: {
            args: Prisma.DecorationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecorationPayload>
          }
          aggregate: {
            args: Prisma.DecorationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDecoration>
          }
          groupBy: {
            args: Prisma.DecorationGroupByArgs<ExtArgs>
            result: $Utils.Optional<DecorationGroupByOutputType>[]
          }
          count: {
            args: Prisma.DecorationCountArgs<ExtArgs>
            result: $Utils.Optional<DecorationCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      Amenities: {
        payload: Prisma.$AmenitiesPayload<ExtArgs>
        fields: Prisma.AmenitiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AmenitiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AmenitiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          findFirst: {
            args: Prisma.AmenitiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AmenitiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          findMany: {
            args: Prisma.AmenitiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>[]
          }
          create: {
            args: Prisma.AmenitiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          createMany: {
            args: Prisma.AmenitiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AmenitiesCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>[]
          }
          delete: {
            args: Prisma.AmenitiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          update: {
            args: Prisma.AmenitiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          deleteMany: {
            args: Prisma.AmenitiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AmenitiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AmenitiesUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>[]
          }
          upsert: {
            args: Prisma.AmenitiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AmenitiesPayload>
          }
          aggregate: {
            args: Prisma.AmenitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAmenities>
          }
          groupBy: {
            args: Prisma.AmenitiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<AmenitiesGroupByOutputType>[]
          }
          count: {
            args: Prisma.AmenitiesCountArgs<ExtArgs>
            result: $Utils.Optional<AmenitiesCountAggregateOutputType> | number
          }
        }
      }
      FileInstance: {
        payload: Prisma.$FileInstancePayload<ExtArgs>
        fields: Prisma.FileInstanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileInstanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileInstancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileInstanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileInstancePayload>
          }
          findFirst: {
            args: Prisma.FileInstanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileInstancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileInstanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileInstancePayload>
          }
          findMany: {
            args: Prisma.FileInstanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileInstancePayload>[]
          }
          create: {
            args: Prisma.FileInstanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileInstancePayload>
          }
          createMany: {
            args: Prisma.FileInstanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileInstanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileInstancePayload>[]
          }
          delete: {
            args: Prisma.FileInstanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileInstancePayload>
          }
          update: {
            args: Prisma.FileInstanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileInstancePayload>
          }
          deleteMany: {
            args: Prisma.FileInstanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileInstanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileInstanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileInstancePayload>[]
          }
          upsert: {
            args: Prisma.FileInstanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileInstancePayload>
          }
          aggregate: {
            args: Prisma.FileInstanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileInstance>
          }
          groupBy: {
            args: Prisma.FileInstanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileInstanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileInstanceCountArgs<ExtArgs>
            result: $Utils.Optional<FileInstanceCountAggregateOutputType> | number
          }
        }
      }
      Conversation: {
        payload: Prisma.$ConversationPayload<ExtArgs>
        fields: Prisma.ConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findFirst: {
            args: Prisma.ConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          findMany: {
            args: Prisma.ConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          create: {
            args: Prisma.ConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          createMany: {
            args: Prisma.ConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          delete: {
            args: Prisma.ConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          update: {
            args: Prisma.ConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          deleteMany: {
            args: Prisma.ConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>[]
          }
          upsert: {
            args: Prisma.ConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConversationPayload>
          }
          aggregate: {
            args: Prisma.ConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConversation>
          }
          groupBy: {
            args: Prisma.ConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConversationCountArgs<ExtArgs>
            result: $Utils.Optional<ConversationCountAggregateOutputType> | number
          }
        }
      }
      DirectMessage: {
        payload: Prisma.$DirectMessagePayload<ExtArgs>
        fields: Prisma.DirectMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DirectMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DirectMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          findFirst: {
            args: Prisma.DirectMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DirectMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          findMany: {
            args: Prisma.DirectMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>[]
          }
          create: {
            args: Prisma.DirectMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          createMany: {
            args: Prisma.DirectMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DirectMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>[]
          }
          delete: {
            args: Prisma.DirectMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          update: {
            args: Prisma.DirectMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          deleteMany: {
            args: Prisma.DirectMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DirectMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DirectMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>[]
          }
          upsert: {
            args: Prisma.DirectMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DirectMessagePayload>
          }
          aggregate: {
            args: Prisma.DirectMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDirectMessage>
          }
          groupBy: {
            args: Prisma.DirectMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<DirectMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.DirectMessageCountArgs<ExtArgs>
            result: $Utils.Optional<DirectMessageCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    profile?: ProfileOmit
    eventType?: EventTypeOmit
    venue?: VenueOmit
    employee?: EmployeeOmit
    shift?: ShiftOmit
    booking?: BookingOmit
    payment?: PaymentOmit
    decoration?: DecorationOmit
    review?: ReviewOmit
    amenities?: AmenitiesOmit
    fileInstance?: FileInstanceOmit
    conversation?: ConversationOmit
    directMessage?: DirectMessageOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProfileCountOutputType
   */

  export type ProfileCountOutputType = {
    eventPreference: number
    assets: number
    directMessages: number
    conversationsInitiated: number
    conversationsReceived: number
    bookingToVenue: number
    bookingToServiceProvider: number
    reviews: number
    venues: number
  }

  export type ProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventPreference?: boolean | ProfileCountOutputTypeCountEventPreferenceArgs
    assets?: boolean | ProfileCountOutputTypeCountAssetsArgs
    directMessages?: boolean | ProfileCountOutputTypeCountDirectMessagesArgs
    conversationsInitiated?: boolean | ProfileCountOutputTypeCountConversationsInitiatedArgs
    conversationsReceived?: boolean | ProfileCountOutputTypeCountConversationsReceivedArgs
    bookingToVenue?: boolean | ProfileCountOutputTypeCountBookingToVenueArgs
    bookingToServiceProvider?: boolean | ProfileCountOutputTypeCountBookingToServiceProviderArgs
    reviews?: boolean | ProfileCountOutputTypeCountReviewsArgs
    venues?: boolean | ProfileCountOutputTypeCountVenuesArgs
  }

  // Custom InputTypes
  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProfileCountOutputType
     */
    select?: ProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountEventPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventTypeWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountAssetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileInstanceWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountDirectMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DirectMessageWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountConversationsInitiatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountConversationsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountBookingToVenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountBookingToServiceProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * ProfileCountOutputType without action
   */
  export type ProfileCountOutputTypeCountVenuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueWhereInput
  }


  /**
   * Count Type EventTypeCountOutputType
   */

  export type EventTypeCountOutputType = {
    profile: number
  }

  export type EventTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | EventTypeCountOutputTypeCountProfileArgs
  }

  // Custom InputTypes
  /**
   * EventTypeCountOutputType without action
   */
  export type EventTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventTypeCountOutputType
     */
    select?: EventTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventTypeCountOutputType without action
   */
  export type EventTypeCountOutputTypeCountProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
  }


  /**
   * Count Type VenueCountOutputType
   */

  export type VenueCountOutputType = {
    amenities: number
    shifts: number
    reviews: number
    employees: number
    bookings: number
  }

  export type VenueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    amenities?: boolean | VenueCountOutputTypeCountAmenitiesArgs
    shifts?: boolean | VenueCountOutputTypeCountShiftsArgs
    reviews?: boolean | VenueCountOutputTypeCountReviewsArgs
    employees?: boolean | VenueCountOutputTypeCountEmployeesArgs
    bookings?: boolean | VenueCountOutputTypeCountBookingsArgs
  }

  // Custom InputTypes
  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VenueCountOutputType
     */
    select?: VenueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountAmenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenitiesWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * VenueCountOutputType without action
   */
  export type VenueCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    shifts: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    shifts?: boolean | EmployeeCountOutputTypeCountShiftsArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountShiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
  }


  /**
   * Count Type BookingCountOutputType
   */

  export type BookingCountOutputType = {
    payment: number
  }

  export type BookingCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payment?: boolean | BookingCountOutputTypeCountPaymentArgs
  }

  // Custom InputTypes
  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BookingCountOutputType
     */
    select?: BookingCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BookingCountOutputType without action
   */
  export type BookingCountOutputTypeCountPaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type AmenitiesCountOutputType
   */

  export type AmenitiesCountOutputType = {
    Venue: number
  }

  export type AmenitiesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Venue?: boolean | AmenitiesCountOutputTypeCountVenueArgs
  }

  // Custom InputTypes
  /**
   * AmenitiesCountOutputType without action
   */
  export type AmenitiesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AmenitiesCountOutputType
     */
    select?: AmenitiesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AmenitiesCountOutputType without action
   */
  export type AmenitiesCountOutputTypeCountVenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueWhereInput
  }


  /**
   * Count Type ConversationCountOutputType
   */

  export type ConversationCountOutputType = {
    directMessages: number
  }

  export type ConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    directMessages?: boolean | ConversationCountOutputTypeCountDirectMessagesArgs
  }

  // Custom InputTypes
  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ConversationCountOutputType
     */
    select?: ConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ConversationCountOutputType without action
   */
  export type ConversationCountOutputTypeCountDirectMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DirectMessageWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    password: string | null
    name: string | null
    role: $Enums.UserRole | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    phone: string | null
    password: string | null
    name: string | null
    role: $Enums.UserRole | null
    isVerified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    phone: number
    password: number
    name: number
    role: number
    isVerified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    password?: true
    name?: true
    role?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    password?: true
    name?: true
    role?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    phone?: true
    password?: true
    name?: true
    role?: true
    isVerified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    phone: string
    password: string
    name: string
    role: $Enums.UserRole
    isVerified: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    profile?: boolean | User$profileArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    phone?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    isVerified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "phone" | "password" | "name" | "role" | "isVerified" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    profile?: boolean | User$profileArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      profile: Prisma.$ProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      phone: string
      password: string
      name: string
      role: $Enums.UserRole
      isVerified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    profile<T extends User$profileArgs<ExtArgs> = {}>(args?: Subset<T, User$profileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly isVerified: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.profile
   */
  export type User$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Profile
   */

  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileAvgAggregateOutputType = {
    experience: number | null
  }

  export type ProfileSumAggregateOutputType = {
    experience: number | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    gender: $Enums.Gender | null
    imageId: string | null
    location: string | null
    coverPhotoId: string | null
    profession: string | null
    description: string | null
    experience: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    gender: $Enums.Gender | null
    imageId: string | null
    location: string | null
    coverPhotoId: string | null
    profession: string | null
    description: string | null
    experience: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    userId: number
    gender: number
    imageId: number
    location: number
    coverPhotoId: number
    profession: number
    description: number
    experience: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProfileAvgAggregateInputType = {
    experience?: true
  }

  export type ProfileSumAggregateInputType = {
    experience?: true
  }

  export type ProfileMinAggregateInputType = {
    id?: true
    userId?: true
    gender?: true
    imageId?: true
    location?: true
    coverPhotoId?: true
    profession?: true
    description?: true
    experience?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    gender?: true
    imageId?: true
    location?: true
    coverPhotoId?: true
    profession?: true
    description?: true
    experience?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    userId?: true
    gender?: true
    imageId?: true
    location?: true
    coverPhotoId?: true
    profession?: true
    description?: true
    experience?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profile to aggregate.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProfileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProfileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithAggregationInput | ProfileOrderByWithAggregationInput[]
    by: ProfileScalarFieldEnum[] | ProfileScalarFieldEnum
    having?: ProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _avg?: ProfileAvgAggregateInputType
    _sum?: ProfileSumAggregateInputType
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }

  export type ProfileGroupByOutputType = {
    id: string
    userId: string
    gender: $Enums.Gender
    imageId: string | null
    location: string | null
    coverPhotoId: string | null
    profession: string | null
    description: string | null
    experience: number | null
    createdAt: Date
    updatedAt: Date
    _count: ProfileCountAggregateOutputType | null
    _avg: ProfileAvgAggregateOutputType | null
    _sum: ProfileSumAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type ProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gender?: boolean
    imageId?: boolean
    location?: boolean
    coverPhotoId?: boolean
    profession?: boolean
    description?: boolean
    experience?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    image?: boolean | Profile$imageArgs<ExtArgs>
    eventPreference?: boolean | Profile$eventPreferenceArgs<ExtArgs>
    coverPhoto?: boolean | Profile$coverPhotoArgs<ExtArgs>
    assets?: boolean | Profile$assetsArgs<ExtArgs>
    directMessages?: boolean | Profile$directMessagesArgs<ExtArgs>
    conversationsInitiated?: boolean | Profile$conversationsInitiatedArgs<ExtArgs>
    conversationsReceived?: boolean | Profile$conversationsReceivedArgs<ExtArgs>
    bookingToVenue?: boolean | Profile$bookingToVenueArgs<ExtArgs>
    bookingToServiceProvider?: boolean | Profile$bookingToServiceProviderArgs<ExtArgs>
    reviews?: boolean | Profile$reviewsArgs<ExtArgs>
    venues?: boolean | Profile$venuesArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gender?: boolean
    imageId?: boolean
    location?: boolean
    coverPhotoId?: boolean
    profession?: boolean
    description?: boolean
    experience?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    image?: boolean | Profile$imageArgs<ExtArgs>
    coverPhoto?: boolean | Profile$coverPhotoArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    gender?: boolean
    imageId?: boolean
    location?: boolean
    coverPhotoId?: boolean
    profession?: boolean
    description?: boolean
    experience?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    image?: boolean | Profile$imageArgs<ExtArgs>
    coverPhoto?: boolean | Profile$coverPhotoArgs<ExtArgs>
  }, ExtArgs["result"]["profile"]>

  export type ProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    gender?: boolean
    imageId?: boolean
    location?: boolean
    coverPhotoId?: boolean
    profession?: boolean
    description?: boolean
    experience?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "gender" | "imageId" | "location" | "coverPhotoId" | "profession" | "description" | "experience" | "createdAt" | "updatedAt", ExtArgs["result"]["profile"]>
  export type ProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    image?: boolean | Profile$imageArgs<ExtArgs>
    eventPreference?: boolean | Profile$eventPreferenceArgs<ExtArgs>
    coverPhoto?: boolean | Profile$coverPhotoArgs<ExtArgs>
    assets?: boolean | Profile$assetsArgs<ExtArgs>
    directMessages?: boolean | Profile$directMessagesArgs<ExtArgs>
    conversationsInitiated?: boolean | Profile$conversationsInitiatedArgs<ExtArgs>
    conversationsReceived?: boolean | Profile$conversationsReceivedArgs<ExtArgs>
    bookingToVenue?: boolean | Profile$bookingToVenueArgs<ExtArgs>
    bookingToServiceProvider?: boolean | Profile$bookingToServiceProviderArgs<ExtArgs>
    reviews?: boolean | Profile$reviewsArgs<ExtArgs>
    venues?: boolean | Profile$venuesArgs<ExtArgs>
    _count?: boolean | ProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    image?: boolean | Profile$imageArgs<ExtArgs>
    coverPhoto?: boolean | Profile$coverPhotoArgs<ExtArgs>
  }
  export type ProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    image?: boolean | Profile$imageArgs<ExtArgs>
    coverPhoto?: boolean | Profile$coverPhotoArgs<ExtArgs>
  }

  export type $ProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Profile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      image: Prisma.$FileInstancePayload<ExtArgs> | null
      eventPreference: Prisma.$EventTypePayload<ExtArgs>[]
      coverPhoto: Prisma.$FileInstancePayload<ExtArgs> | null
      assets: Prisma.$FileInstancePayload<ExtArgs>[]
      directMessages: Prisma.$DirectMessagePayload<ExtArgs>[]
      conversationsInitiated: Prisma.$ConversationPayload<ExtArgs>[]
      conversationsReceived: Prisma.$ConversationPayload<ExtArgs>[]
      bookingToVenue: Prisma.$BookingPayload<ExtArgs>[]
      bookingToServiceProvider: Prisma.$BookingPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      venues: Prisma.$VenuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      gender: $Enums.Gender
      imageId: string | null
      location: string | null
      coverPhotoId: string | null
      profession: string | null
      description: string | null
      experience: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["profile"]>
    composites: {}
  }

  type ProfileGetPayload<S extends boolean | null | undefined | ProfileDefaultArgs> = $Result.GetResult<Prisma.$ProfilePayload, S>

  type ProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface ProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Profile'], meta: { name: 'Profile' } }
    /**
     * Find zero or one Profile that matches the filter.
     * @param {ProfileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProfileFindUniqueArgs>(args: SelectSubset<T, ProfileFindUniqueArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Profile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProfileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProfileFindFirstArgs>(args?: SelectSubset<T, ProfileFindFirstArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Profile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProfileFindManyArgs>(args?: SelectSubset<T, ProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Profile.
     * @param {ProfileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
     */
    create<T extends ProfileCreateArgs>(args: SelectSubset<T, ProfileCreateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Profiles.
     * @param {ProfileCreateManyArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProfileCreateManyArgs>(args?: SelectSubset<T, ProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Profiles and returns the data saved in the database.
     * @param {ProfileCreateManyAndReturnArgs} args - Arguments to create many Profiles.
     * @example
     * // Create many Profiles
     * const profile = await prisma.profile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Profile.
     * @param {ProfileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
     */
    delete<T extends ProfileDeleteArgs>(args: SelectSubset<T, ProfileDeleteArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Profile.
     * @param {ProfileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProfileUpdateArgs>(args: SelectSubset<T, ProfileUpdateArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Profiles.
     * @param {ProfileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProfileDeleteManyArgs>(args?: SelectSubset<T, ProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProfileUpdateManyArgs>(args: SelectSubset<T, ProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles and returns the data updated in the database.
     * @param {ProfileUpdateManyAndReturnArgs} args - Arguments to update many Profiles.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Profiles and only return the `id`
     * const profileWithIdOnly = await prisma.profile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, ProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Profile.
     * @param {ProfileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
     */
    upsert<T extends ProfileUpsertArgs>(args: SelectSubset<T, ProfileUpsertArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends ProfileCountArgs>(
      args?: Subset<T, ProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Profile model
   */
  readonly fields: ProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    image<T extends Profile$imageArgs<ExtArgs> = {}>(args?: Subset<T, Profile$imageArgs<ExtArgs>>): Prisma__FileInstanceClient<$Result.GetResult<Prisma.$FileInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    eventPreference<T extends Profile$eventPreferenceArgs<ExtArgs> = {}>(args?: Subset<T, Profile$eventPreferenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    coverPhoto<T extends Profile$coverPhotoArgs<ExtArgs> = {}>(args?: Subset<T, Profile$coverPhotoArgs<ExtArgs>>): Prisma__FileInstanceClient<$Result.GetResult<Prisma.$FileInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    assets<T extends Profile$assetsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$assetsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    directMessages<T extends Profile$directMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Profile$directMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversationsInitiated<T extends Profile$conversationsInitiatedArgs<ExtArgs> = {}>(args?: Subset<T, Profile$conversationsInitiatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    conversationsReceived<T extends Profile$conversationsReceivedArgs<ExtArgs> = {}>(args?: Subset<T, Profile$conversationsReceivedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookingToVenue<T extends Profile$bookingToVenueArgs<ExtArgs> = {}>(args?: Subset<T, Profile$bookingToVenueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookingToServiceProvider<T extends Profile$bookingToServiceProviderArgs<ExtArgs> = {}>(args?: Subset<T, Profile$bookingToServiceProviderArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Profile$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Profile$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    venues<T extends Profile$venuesArgs<ExtArgs> = {}>(args?: Subset<T, Profile$venuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Profile model
   */
  interface ProfileFieldRefs {
    readonly id: FieldRef<"Profile", 'String'>
    readonly userId: FieldRef<"Profile", 'String'>
    readonly gender: FieldRef<"Profile", 'Gender'>
    readonly imageId: FieldRef<"Profile", 'String'>
    readonly location: FieldRef<"Profile", 'String'>
    readonly coverPhotoId: FieldRef<"Profile", 'String'>
    readonly profession: FieldRef<"Profile", 'String'>
    readonly description: FieldRef<"Profile", 'String'>
    readonly experience: FieldRef<"Profile", 'Int'>
    readonly createdAt: FieldRef<"Profile", 'DateTime'>
    readonly updatedAt: FieldRef<"Profile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Profile findUnique
   */
  export type ProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findUniqueOrThrow
   */
  export type ProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile findFirst
   */
  export type ProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findFirstOrThrow
   */
  export type ProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profile to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Profiles.
     */
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile findMany
   */
  export type ProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter, which Profiles to fetch.
     */
    where?: ProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Profiles to fetch.
     */
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Profiles.
     */
    cursor?: ProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Profiles.
     */
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * Profile create
   */
  export type ProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a Profile.
     */
    data: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
  }

  /**
   * Profile createMany
   */
  export type ProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Profile createManyAndReturn
   */
  export type ProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to create many Profiles.
     */
    data: ProfileCreateManyInput | ProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile update
   */
  export type ProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a Profile.
     */
    data: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
    /**
     * Choose, which Profile to update.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile updateMany
   */
  export type ProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
  }

  /**
   * Profile updateManyAndReturn
   */
  export type ProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * The data used to update Profiles.
     */
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyInput>
    /**
     * Filter which Profiles to update
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Profile upsert
   */
  export type ProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the Profile to update in case it exists.
     */
    where: ProfileWhereUniqueInput
    /**
     * In case the Profile found by the `where` argument doesn't exist, create a new Profile with this data.
     */
    create: XOR<ProfileCreateInput, ProfileUncheckedCreateInput>
    /**
     * In case the Profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProfileUpdateInput, ProfileUncheckedUpdateInput>
  }

  /**
   * Profile delete
   */
  export type ProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    /**
     * Filter which Profile to delete.
     */
    where: ProfileWhereUniqueInput
  }

  /**
   * Profile deleteMany
   */
  export type ProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Profiles to delete
     */
    where?: ProfileWhereInput
    /**
     * Limit how many Profiles to delete.
     */
    limit?: number
  }

  /**
   * Profile.image
   */
  export type Profile$imageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileInstance
     */
    select?: FileInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileInstance
     */
    omit?: FileInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInstanceInclude<ExtArgs> | null
    where?: FileInstanceWhereInput
  }

  /**
   * Profile.eventPreference
   */
  export type Profile$eventPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    where?: EventTypeWhereInput
    orderBy?: EventTypeOrderByWithRelationInput | EventTypeOrderByWithRelationInput[]
    cursor?: EventTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventTypeScalarFieldEnum | EventTypeScalarFieldEnum[]
  }

  /**
   * Profile.coverPhoto
   */
  export type Profile$coverPhotoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileInstance
     */
    select?: FileInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileInstance
     */
    omit?: FileInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInstanceInclude<ExtArgs> | null
    where?: FileInstanceWhereInput
  }

  /**
   * Profile.assets
   */
  export type Profile$assetsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileInstance
     */
    select?: FileInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileInstance
     */
    omit?: FileInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInstanceInclude<ExtArgs> | null
    where?: FileInstanceWhereInput
    orderBy?: FileInstanceOrderByWithRelationInput | FileInstanceOrderByWithRelationInput[]
    cursor?: FileInstanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileInstanceScalarFieldEnum | FileInstanceScalarFieldEnum[]
  }

  /**
   * Profile.directMessages
   */
  export type Profile$directMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    where?: DirectMessageWhereInput
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    cursor?: DirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * Profile.conversationsInitiated
   */
  export type Profile$conversationsInitiatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Profile.conversationsReceived
   */
  export type Profile$conversationsReceivedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    cursor?: ConversationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Profile.bookingToVenue
   */
  export type Profile$bookingToVenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Profile.bookingToServiceProvider
   */
  export type Profile$bookingToServiceProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Profile.reviews
   */
  export type Profile$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Profile.venues
   */
  export type Profile$venuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    where?: VenueWhereInput
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    cursor?: VenueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Profile without action
   */
  export type ProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
  }


  /**
   * Model EventType
   */

  export type AggregateEventType = {
    _count: EventTypeCountAggregateOutputType | null
    _min: EventTypeMinAggregateOutputType | null
    _max: EventTypeMaxAggregateOutputType | null
  }

  export type EventTypeMinAggregateOutputType = {
    id: string | null
    name: string | null
    bookingId: string | null
  }

  export type EventTypeMaxAggregateOutputType = {
    id: string | null
    name: string | null
    bookingId: string | null
  }

  export type EventTypeCountAggregateOutputType = {
    id: number
    name: number
    bookingId: number
    _all: number
  }


  export type EventTypeMinAggregateInputType = {
    id?: true
    name?: true
    bookingId?: true
  }

  export type EventTypeMaxAggregateInputType = {
    id?: true
    name?: true
    bookingId?: true
  }

  export type EventTypeCountAggregateInputType = {
    id?: true
    name?: true
    bookingId?: true
    _all?: true
  }

  export type EventTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventType to aggregate.
     */
    where?: EventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTypes to fetch.
     */
    orderBy?: EventTypeOrderByWithRelationInput | EventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventTypes
    **/
    _count?: true | EventTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventTypeMaxAggregateInputType
  }

  export type GetEventTypeAggregateType<T extends EventTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateEventType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventType[P]>
      : GetScalarType<T[P], AggregateEventType[P]>
  }




  export type EventTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventTypeWhereInput
    orderBy?: EventTypeOrderByWithAggregationInput | EventTypeOrderByWithAggregationInput[]
    by: EventTypeScalarFieldEnum[] | EventTypeScalarFieldEnum
    having?: EventTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventTypeCountAggregateInputType | true
    _min?: EventTypeMinAggregateInputType
    _max?: EventTypeMaxAggregateInputType
  }

  export type EventTypeGroupByOutputType = {
    id: string
    name: string
    bookingId: string
    _count: EventTypeCountAggregateOutputType | null
    _min: EventTypeMinAggregateOutputType | null
    _max: EventTypeMaxAggregateOutputType | null
  }

  type GetEventTypeGroupByPayload<T extends EventTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventTypeGroupByOutputType[P]>
            : GetScalarType<T[P], EventTypeGroupByOutputType[P]>
        }
      >
    >


  export type EventTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    bookingId?: boolean
    avatar?: boolean | EventType$avatarArgs<ExtArgs>
    profile?: boolean | EventType$profileArgs<ExtArgs>
    Booking?: boolean | EventType$BookingArgs<ExtArgs>
    _count?: boolean | EventTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventType"]>

  export type EventTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    bookingId?: boolean
    Booking?: boolean | EventType$BookingArgs<ExtArgs>
  }, ExtArgs["result"]["eventType"]>

  export type EventTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    bookingId?: boolean
    Booking?: boolean | EventType$BookingArgs<ExtArgs>
  }, ExtArgs["result"]["eventType"]>

  export type EventTypeSelectScalar = {
    id?: boolean
    name?: boolean
    bookingId?: boolean
  }

  export type EventTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "bookingId", ExtArgs["result"]["eventType"]>
  export type EventTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatar?: boolean | EventType$avatarArgs<ExtArgs>
    profile?: boolean | EventType$profileArgs<ExtArgs>
    Booking?: boolean | EventType$BookingArgs<ExtArgs>
    _count?: boolean | EventTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EventTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Booking?: boolean | EventType$BookingArgs<ExtArgs>
  }
  export type EventTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Booking?: boolean | EventType$BookingArgs<ExtArgs>
  }

  export type $EventTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventType"
    objects: {
      avatar: Prisma.$FileInstancePayload<ExtArgs> | null
      profile: Prisma.$ProfilePayload<ExtArgs>[]
      Booking: Prisma.$BookingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      bookingId: string
    }, ExtArgs["result"]["eventType"]>
    composites: {}
  }

  type EventTypeGetPayload<S extends boolean | null | undefined | EventTypeDefaultArgs> = $Result.GetResult<Prisma.$EventTypePayload, S>

  type EventTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventTypeCountAggregateInputType | true
    }

  export interface EventTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventType'], meta: { name: 'EventType' } }
    /**
     * Find zero or one EventType that matches the filter.
     * @param {EventTypeFindUniqueArgs} args - Arguments to find a EventType
     * @example
     * // Get one EventType
     * const eventType = await prisma.eventType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventTypeFindUniqueArgs>(args: SelectSubset<T, EventTypeFindUniqueArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EventType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventTypeFindUniqueOrThrowArgs} args - Arguments to find a EventType
     * @example
     * // Get one EventType
     * const eventType = await prisma.eventType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, EventTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeFindFirstArgs} args - Arguments to find a EventType
     * @example
     * // Get one EventType
     * const eventType = await prisma.eventType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventTypeFindFirstArgs>(args?: SelectSubset<T, EventTypeFindFirstArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EventType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeFindFirstOrThrowArgs} args - Arguments to find a EventType
     * @example
     * // Get one EventType
     * const eventType = await prisma.eventType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, EventTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EventTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventTypes
     * const eventTypes = await prisma.eventType.findMany()
     * 
     * // Get first 10 EventTypes
     * const eventTypes = await prisma.eventType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventTypeWithIdOnly = await prisma.eventType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventTypeFindManyArgs>(args?: SelectSubset<T, EventTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EventType.
     * @param {EventTypeCreateArgs} args - Arguments to create a EventType.
     * @example
     * // Create one EventType
     * const EventType = await prisma.eventType.create({
     *   data: {
     *     // ... data to create a EventType
     *   }
     * })
     * 
     */
    create<T extends EventTypeCreateArgs>(args: SelectSubset<T, EventTypeCreateArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EventTypes.
     * @param {EventTypeCreateManyArgs} args - Arguments to create many EventTypes.
     * @example
     * // Create many EventTypes
     * const eventType = await prisma.eventType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventTypeCreateManyArgs>(args?: SelectSubset<T, EventTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventTypes and returns the data saved in the database.
     * @param {EventTypeCreateManyAndReturnArgs} args - Arguments to create many EventTypes.
     * @example
     * // Create many EventTypes
     * const eventType = await prisma.eventType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventTypes and only return the `id`
     * const eventTypeWithIdOnly = await prisma.eventType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, EventTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EventType.
     * @param {EventTypeDeleteArgs} args - Arguments to delete one EventType.
     * @example
     * // Delete one EventType
     * const EventType = await prisma.eventType.delete({
     *   where: {
     *     // ... filter to delete one EventType
     *   }
     * })
     * 
     */
    delete<T extends EventTypeDeleteArgs>(args: SelectSubset<T, EventTypeDeleteArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EventType.
     * @param {EventTypeUpdateArgs} args - Arguments to update one EventType.
     * @example
     * // Update one EventType
     * const eventType = await prisma.eventType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventTypeUpdateArgs>(args: SelectSubset<T, EventTypeUpdateArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EventTypes.
     * @param {EventTypeDeleteManyArgs} args - Arguments to filter EventTypes to delete.
     * @example
     * // Delete a few EventTypes
     * const { count } = await prisma.eventType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventTypeDeleteManyArgs>(args?: SelectSubset<T, EventTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventTypes
     * const eventType = await prisma.eventType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventTypeUpdateManyArgs>(args: SelectSubset<T, EventTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventTypes and returns the data updated in the database.
     * @param {EventTypeUpdateManyAndReturnArgs} args - Arguments to update many EventTypes.
     * @example
     * // Update many EventTypes
     * const eventType = await prisma.eventType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EventTypes and only return the `id`
     * const eventTypeWithIdOnly = await prisma.eventType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, EventTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EventType.
     * @param {EventTypeUpsertArgs} args - Arguments to update or create a EventType.
     * @example
     * // Update or create a EventType
     * const eventType = await prisma.eventType.upsert({
     *   create: {
     *     // ... data to create a EventType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventType we want to update
     *   }
     * })
     */
    upsert<T extends EventTypeUpsertArgs>(args: SelectSubset<T, EventTypeUpsertArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EventTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeCountArgs} args - Arguments to filter EventTypes to count.
     * @example
     * // Count the number of EventTypes
     * const count = await prisma.eventType.count({
     *   where: {
     *     // ... the filter for the EventTypes we want to count
     *   }
     * })
    **/
    count<T extends EventTypeCountArgs>(
      args?: Subset<T, EventTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventTypeAggregateArgs>(args: Subset<T, EventTypeAggregateArgs>): Prisma.PrismaPromise<GetEventTypeAggregateType<T>>

    /**
     * Group by EventType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventTypeGroupByArgs['orderBy'] }
        : { orderBy?: EventTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventType model
   */
  readonly fields: EventTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    avatar<T extends EventType$avatarArgs<ExtArgs> = {}>(args?: Subset<T, EventType$avatarArgs<ExtArgs>>): Prisma__FileInstanceClient<$Result.GetResult<Prisma.$FileInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    profile<T extends EventType$profileArgs<ExtArgs> = {}>(args?: Subset<T, EventType$profileArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Booking<T extends EventType$BookingArgs<ExtArgs> = {}>(args?: Subset<T, EventType$BookingArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventType model
   */
  interface EventTypeFieldRefs {
    readonly id: FieldRef<"EventType", 'String'>
    readonly name: FieldRef<"EventType", 'String'>
    readonly bookingId: FieldRef<"EventType", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EventType findUnique
   */
  export type EventTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventType to fetch.
     */
    where: EventTypeWhereUniqueInput
  }

  /**
   * EventType findUniqueOrThrow
   */
  export type EventTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventType to fetch.
     */
    where: EventTypeWhereUniqueInput
  }

  /**
   * EventType findFirst
   */
  export type EventTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventType to fetch.
     */
    where?: EventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTypes to fetch.
     */
    orderBy?: EventTypeOrderByWithRelationInput | EventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventTypes.
     */
    cursor?: EventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventTypes.
     */
    distinct?: EventTypeScalarFieldEnum | EventTypeScalarFieldEnum[]
  }

  /**
   * EventType findFirstOrThrow
   */
  export type EventTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventType to fetch.
     */
    where?: EventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTypes to fetch.
     */
    orderBy?: EventTypeOrderByWithRelationInput | EventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventTypes.
     */
    cursor?: EventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventTypes.
     */
    distinct?: EventTypeScalarFieldEnum | EventTypeScalarFieldEnum[]
  }

  /**
   * EventType findMany
   */
  export type EventTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventTypes to fetch.
     */
    where?: EventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTypes to fetch.
     */
    orderBy?: EventTypeOrderByWithRelationInput | EventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventTypes.
     */
    cursor?: EventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTypes.
     */
    skip?: number
    distinct?: EventTypeScalarFieldEnum | EventTypeScalarFieldEnum[]
  }

  /**
   * EventType create
   */
  export type EventTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a EventType.
     */
    data: XOR<EventTypeCreateInput, EventTypeUncheckedCreateInput>
  }

  /**
   * EventType createMany
   */
  export type EventTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventTypes.
     */
    data: EventTypeCreateManyInput | EventTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventType createManyAndReturn
   */
  export type EventTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * The data used to create many EventTypes.
     */
    data: EventTypeCreateManyInput | EventTypeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventType update
   */
  export type EventTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a EventType.
     */
    data: XOR<EventTypeUpdateInput, EventTypeUncheckedUpdateInput>
    /**
     * Choose, which EventType to update.
     */
    where: EventTypeWhereUniqueInput
  }

  /**
   * EventType updateMany
   */
  export type EventTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventTypes.
     */
    data: XOR<EventTypeUpdateManyMutationInput, EventTypeUncheckedUpdateManyInput>
    /**
     * Filter which EventTypes to update
     */
    where?: EventTypeWhereInput
    /**
     * Limit how many EventTypes to update.
     */
    limit?: number
  }

  /**
   * EventType updateManyAndReturn
   */
  export type EventTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * The data used to update EventTypes.
     */
    data: XOR<EventTypeUpdateManyMutationInput, EventTypeUncheckedUpdateManyInput>
    /**
     * Filter which EventTypes to update
     */
    where?: EventTypeWhereInput
    /**
     * Limit how many EventTypes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventType upsert
   */
  export type EventTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the EventType to update in case it exists.
     */
    where: EventTypeWhereUniqueInput
    /**
     * In case the EventType found by the `where` argument doesn't exist, create a new EventType with this data.
     */
    create: XOR<EventTypeCreateInput, EventTypeUncheckedCreateInput>
    /**
     * In case the EventType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventTypeUpdateInput, EventTypeUncheckedUpdateInput>
  }

  /**
   * EventType delete
   */
  export type EventTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter which EventType to delete.
     */
    where: EventTypeWhereUniqueInput
  }

  /**
   * EventType deleteMany
   */
  export type EventTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventTypes to delete
     */
    where?: EventTypeWhereInput
    /**
     * Limit how many EventTypes to delete.
     */
    limit?: number
  }

  /**
   * EventType.avatar
   */
  export type EventType$avatarArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileInstance
     */
    select?: FileInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileInstance
     */
    omit?: FileInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInstanceInclude<ExtArgs> | null
    where?: FileInstanceWhereInput
  }

  /**
   * EventType.profile
   */
  export type EventType$profileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
    orderBy?: ProfileOrderByWithRelationInput | ProfileOrderByWithRelationInput[]
    cursor?: ProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProfileScalarFieldEnum | ProfileScalarFieldEnum[]
  }

  /**
   * EventType.Booking
   */
  export type EventType$BookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * EventType without action
   */
  export type EventTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
  }


  /**
   * Model Venue
   */

  export type AggregateVenue = {
    _count: VenueCountAggregateOutputType | null
    _avg: VenueAvgAggregateOutputType | null
    _sum: VenueSumAggregateOutputType | null
    _min: VenueMinAggregateOutputType | null
    _max: VenueMaxAggregateOutputType | null
  }

  export type VenueAvgAggregateOutputType = {
    capacity: number | null
    price: number | null
  }

  export type VenueSumAggregateOutputType = {
    capacity: number | null
    price: number | null
  }

  export type VenueMinAggregateOutputType = {
    id: string | null
    profileId: string | null
    name: string | null
    city: string | null
    area: string | null
    description: string | null
    capacity: number | null
    type: $Enums.VenueType | null
    cateringDescription: string | null
    parkingDescription: string | null
    availabilityDescription: string | null
    extraServiceDescription: string | null
    price: number | null
    bookingType: $Enums.BookingType | null
    verified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenueMaxAggregateOutputType = {
    id: string | null
    profileId: string | null
    name: string | null
    city: string | null
    area: string | null
    description: string | null
    capacity: number | null
    type: $Enums.VenueType | null
    cateringDescription: string | null
    parkingDescription: string | null
    availabilityDescription: string | null
    extraServiceDescription: string | null
    price: number | null
    bookingType: $Enums.BookingType | null
    verified: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VenueCountAggregateOutputType = {
    id: number
    profileId: number
    name: number
    city: number
    area: number
    description: number
    capacity: number
    bookedDates: number
    type: number
    cateringDescription: number
    parkingDescription: number
    availabilityDescription: number
    extraServiceDescription: number
    price: number
    bookingType: number
    verified: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VenueAvgAggregateInputType = {
    capacity?: true
    price?: true
  }

  export type VenueSumAggregateInputType = {
    capacity?: true
    price?: true
  }

  export type VenueMinAggregateInputType = {
    id?: true
    profileId?: true
    name?: true
    city?: true
    area?: true
    description?: true
    capacity?: true
    type?: true
    cateringDescription?: true
    parkingDescription?: true
    availabilityDescription?: true
    extraServiceDescription?: true
    price?: true
    bookingType?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenueMaxAggregateInputType = {
    id?: true
    profileId?: true
    name?: true
    city?: true
    area?: true
    description?: true
    capacity?: true
    type?: true
    cateringDescription?: true
    parkingDescription?: true
    availabilityDescription?: true
    extraServiceDescription?: true
    price?: true
    bookingType?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VenueCountAggregateInputType = {
    id?: true
    profileId?: true
    name?: true
    city?: true
    area?: true
    description?: true
    capacity?: true
    bookedDates?: true
    type?: true
    cateringDescription?: true
    parkingDescription?: true
    availabilityDescription?: true
    extraServiceDescription?: true
    price?: true
    bookingType?: true
    verified?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VenueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venue to aggregate.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Venues
    **/
    _count?: true | VenueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VenueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VenueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VenueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VenueMaxAggregateInputType
  }

  export type GetVenueAggregateType<T extends VenueAggregateArgs> = {
        [P in keyof T & keyof AggregateVenue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVenue[P]>
      : GetScalarType<T[P], AggregateVenue[P]>
  }




  export type VenueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VenueWhereInput
    orderBy?: VenueOrderByWithAggregationInput | VenueOrderByWithAggregationInput[]
    by: VenueScalarFieldEnum[] | VenueScalarFieldEnum
    having?: VenueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VenueCountAggregateInputType | true
    _avg?: VenueAvgAggregateInputType
    _sum?: VenueSumAggregateInputType
    _min?: VenueMinAggregateInputType
    _max?: VenueMaxAggregateInputType
  }

  export type VenueGroupByOutputType = {
    id: string
    profileId: string | null
    name: string
    city: string
    area: string
    description: string | null
    capacity: number
    bookedDates: Date[]
    type: $Enums.VenueType
    cateringDescription: string | null
    parkingDescription: string | null
    availabilityDescription: string | null
    extraServiceDescription: string | null
    price: number
    bookingType: $Enums.BookingType
    verified: boolean
    createdAt: Date
    updatedAt: Date
    _count: VenueCountAggregateOutputType | null
    _avg: VenueAvgAggregateOutputType | null
    _sum: VenueSumAggregateOutputType | null
    _min: VenueMinAggregateOutputType | null
    _max: VenueMaxAggregateOutputType | null
  }

  type GetVenueGroupByPayload<T extends VenueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VenueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VenueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VenueGroupByOutputType[P]>
            : GetScalarType<T[P], VenueGroupByOutputType[P]>
        }
      >
    >


  export type VenueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    name?: boolean
    city?: boolean
    area?: boolean
    description?: boolean
    capacity?: boolean
    bookedDates?: boolean
    type?: boolean
    cateringDescription?: boolean
    parkingDescription?: boolean
    availabilityDescription?: boolean
    extraServiceDescription?: boolean
    price?: boolean
    bookingType?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Profile?: boolean | Venue$ProfileArgs<ExtArgs>
    amenities?: boolean | Venue$amenitiesArgs<ExtArgs>
    arrangementsImage?: boolean | Venue$arrangementsImageArgs<ExtArgs>
    shifts?: boolean | Venue$shiftsArgs<ExtArgs>
    reviews?: boolean | Venue$reviewsArgs<ExtArgs>
    decoration?: boolean | Venue$decorationArgs<ExtArgs>
    employees?: boolean | Venue$employeesArgs<ExtArgs>
    bookings?: boolean | Venue$bookingsArgs<ExtArgs>
    _count?: boolean | VenueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["venue"]>

  export type VenueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    name?: boolean
    city?: boolean
    area?: boolean
    description?: boolean
    capacity?: boolean
    bookedDates?: boolean
    type?: boolean
    cateringDescription?: boolean
    parkingDescription?: boolean
    availabilityDescription?: boolean
    extraServiceDescription?: boolean
    price?: boolean
    bookingType?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Profile?: boolean | Venue$ProfileArgs<ExtArgs>
  }, ExtArgs["result"]["venue"]>

  export type VenueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    profileId?: boolean
    name?: boolean
    city?: boolean
    area?: boolean
    description?: boolean
    capacity?: boolean
    bookedDates?: boolean
    type?: boolean
    cateringDescription?: boolean
    parkingDescription?: boolean
    availabilityDescription?: boolean
    extraServiceDescription?: boolean
    price?: boolean
    bookingType?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Profile?: boolean | Venue$ProfileArgs<ExtArgs>
  }, ExtArgs["result"]["venue"]>

  export type VenueSelectScalar = {
    id?: boolean
    profileId?: boolean
    name?: boolean
    city?: boolean
    area?: boolean
    description?: boolean
    capacity?: boolean
    bookedDates?: boolean
    type?: boolean
    cateringDescription?: boolean
    parkingDescription?: boolean
    availabilityDescription?: boolean
    extraServiceDescription?: boolean
    price?: boolean
    bookingType?: boolean
    verified?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VenueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "profileId" | "name" | "city" | "area" | "description" | "capacity" | "bookedDates" | "type" | "cateringDescription" | "parkingDescription" | "availabilityDescription" | "extraServiceDescription" | "price" | "bookingType" | "verified" | "createdAt" | "updatedAt", ExtArgs["result"]["venue"]>
  export type VenueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Profile?: boolean | Venue$ProfileArgs<ExtArgs>
    amenities?: boolean | Venue$amenitiesArgs<ExtArgs>
    arrangementsImage?: boolean | Venue$arrangementsImageArgs<ExtArgs>
    shifts?: boolean | Venue$shiftsArgs<ExtArgs>
    reviews?: boolean | Venue$reviewsArgs<ExtArgs>
    decoration?: boolean | Venue$decorationArgs<ExtArgs>
    employees?: boolean | Venue$employeesArgs<ExtArgs>
    bookings?: boolean | Venue$bookingsArgs<ExtArgs>
    _count?: boolean | VenueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VenueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Profile?: boolean | Venue$ProfileArgs<ExtArgs>
  }
  export type VenueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Profile?: boolean | Venue$ProfileArgs<ExtArgs>
  }

  export type $VenuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Venue"
    objects: {
      Profile: Prisma.$ProfilePayload<ExtArgs> | null
      amenities: Prisma.$AmenitiesPayload<ExtArgs>[]
      arrangementsImage: Prisma.$FileInstancePayload<ExtArgs> | null
      shifts: Prisma.$ShiftPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      decoration: Prisma.$DecorationPayload<ExtArgs> | null
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      bookings: Prisma.$BookingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      profileId: string | null
      name: string
      city: string
      area: string
      description: string | null
      capacity: number
      bookedDates: Date[]
      type: $Enums.VenueType
      cateringDescription: string | null
      parkingDescription: string | null
      availabilityDescription: string | null
      extraServiceDescription: string | null
      price: number
      bookingType: $Enums.BookingType
      verified: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["venue"]>
    composites: {}
  }

  type VenueGetPayload<S extends boolean | null | undefined | VenueDefaultArgs> = $Result.GetResult<Prisma.$VenuePayload, S>

  type VenueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VenueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VenueCountAggregateInputType | true
    }

  export interface VenueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Venue'], meta: { name: 'Venue' } }
    /**
     * Find zero or one Venue that matches the filter.
     * @param {VenueFindUniqueArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VenueFindUniqueArgs>(args: SelectSubset<T, VenueFindUniqueArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Venue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VenueFindUniqueOrThrowArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VenueFindUniqueOrThrowArgs>(args: SelectSubset<T, VenueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Venue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindFirstArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VenueFindFirstArgs>(args?: SelectSubset<T, VenueFindFirstArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Venue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindFirstOrThrowArgs} args - Arguments to find a Venue
     * @example
     * // Get one Venue
     * const venue = await prisma.venue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VenueFindFirstOrThrowArgs>(args?: SelectSubset<T, VenueFindFirstOrThrowArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Venues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Venues
     * const venues = await prisma.venue.findMany()
     * 
     * // Get first 10 Venues
     * const venues = await prisma.venue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const venueWithIdOnly = await prisma.venue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VenueFindManyArgs>(args?: SelectSubset<T, VenueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Venue.
     * @param {VenueCreateArgs} args - Arguments to create a Venue.
     * @example
     * // Create one Venue
     * const Venue = await prisma.venue.create({
     *   data: {
     *     // ... data to create a Venue
     *   }
     * })
     * 
     */
    create<T extends VenueCreateArgs>(args: SelectSubset<T, VenueCreateArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Venues.
     * @param {VenueCreateManyArgs} args - Arguments to create many Venues.
     * @example
     * // Create many Venues
     * const venue = await prisma.venue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VenueCreateManyArgs>(args?: SelectSubset<T, VenueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Venues and returns the data saved in the database.
     * @param {VenueCreateManyAndReturnArgs} args - Arguments to create many Venues.
     * @example
     * // Create many Venues
     * const venue = await prisma.venue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Venues and only return the `id`
     * const venueWithIdOnly = await prisma.venue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VenueCreateManyAndReturnArgs>(args?: SelectSubset<T, VenueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Venue.
     * @param {VenueDeleteArgs} args - Arguments to delete one Venue.
     * @example
     * // Delete one Venue
     * const Venue = await prisma.venue.delete({
     *   where: {
     *     // ... filter to delete one Venue
     *   }
     * })
     * 
     */
    delete<T extends VenueDeleteArgs>(args: SelectSubset<T, VenueDeleteArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Venue.
     * @param {VenueUpdateArgs} args - Arguments to update one Venue.
     * @example
     * // Update one Venue
     * const venue = await prisma.venue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VenueUpdateArgs>(args: SelectSubset<T, VenueUpdateArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Venues.
     * @param {VenueDeleteManyArgs} args - Arguments to filter Venues to delete.
     * @example
     * // Delete a few Venues
     * const { count } = await prisma.venue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VenueDeleteManyArgs>(args?: SelectSubset<T, VenueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Venues
     * const venue = await prisma.venue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VenueUpdateManyArgs>(args: SelectSubset<T, VenueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Venues and returns the data updated in the database.
     * @param {VenueUpdateManyAndReturnArgs} args - Arguments to update many Venues.
     * @example
     * // Update many Venues
     * const venue = await prisma.venue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Venues and only return the `id`
     * const venueWithIdOnly = await prisma.venue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VenueUpdateManyAndReturnArgs>(args: SelectSubset<T, VenueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Venue.
     * @param {VenueUpsertArgs} args - Arguments to update or create a Venue.
     * @example
     * // Update or create a Venue
     * const venue = await prisma.venue.upsert({
     *   create: {
     *     // ... data to create a Venue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Venue we want to update
     *   }
     * })
     */
    upsert<T extends VenueUpsertArgs>(args: SelectSubset<T, VenueUpsertArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Venues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueCountArgs} args - Arguments to filter Venues to count.
     * @example
     * // Count the number of Venues
     * const count = await prisma.venue.count({
     *   where: {
     *     // ... the filter for the Venues we want to count
     *   }
     * })
    **/
    count<T extends VenueCountArgs>(
      args?: Subset<T, VenueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VenueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Venue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VenueAggregateArgs>(args: Subset<T, VenueAggregateArgs>): Prisma.PrismaPromise<GetVenueAggregateType<T>>

    /**
     * Group by Venue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VenueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VenueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VenueGroupByArgs['orderBy'] }
        : { orderBy?: VenueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VenueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVenueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Venue model
   */
  readonly fields: VenueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Venue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VenueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Profile<T extends Venue$ProfileArgs<ExtArgs> = {}>(args?: Subset<T, Venue$ProfileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    amenities<T extends Venue$amenitiesArgs<ExtArgs> = {}>(args?: Subset<T, Venue$amenitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    arrangementsImage<T extends Venue$arrangementsImageArgs<ExtArgs> = {}>(args?: Subset<T, Venue$arrangementsImageArgs<ExtArgs>>): Prisma__FileInstanceClient<$Result.GetResult<Prisma.$FileInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    shifts<T extends Venue$shiftsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$shiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Venue$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    decoration<T extends Venue$decorationArgs<ExtArgs> = {}>(args?: Subset<T, Venue$decorationArgs<ExtArgs>>): Prisma__DecorationClient<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    employees<T extends Venue$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Venue$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends Venue$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, Venue$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Venue model
   */
  interface VenueFieldRefs {
    readonly id: FieldRef<"Venue", 'String'>
    readonly profileId: FieldRef<"Venue", 'String'>
    readonly name: FieldRef<"Venue", 'String'>
    readonly city: FieldRef<"Venue", 'String'>
    readonly area: FieldRef<"Venue", 'String'>
    readonly description: FieldRef<"Venue", 'String'>
    readonly capacity: FieldRef<"Venue", 'Int'>
    readonly bookedDates: FieldRef<"Venue", 'DateTime[]'>
    readonly type: FieldRef<"Venue", 'VenueType'>
    readonly cateringDescription: FieldRef<"Venue", 'String'>
    readonly parkingDescription: FieldRef<"Venue", 'String'>
    readonly availabilityDescription: FieldRef<"Venue", 'String'>
    readonly extraServiceDescription: FieldRef<"Venue", 'String'>
    readonly price: FieldRef<"Venue", 'Int'>
    readonly bookingType: FieldRef<"Venue", 'BookingType'>
    readonly verified: FieldRef<"Venue", 'Boolean'>
    readonly createdAt: FieldRef<"Venue", 'DateTime'>
    readonly updatedAt: FieldRef<"Venue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Venue findUnique
   */
  export type VenueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue findUniqueOrThrow
   */
  export type VenueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue findFirst
   */
  export type VenueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Venues.
     */
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue findFirstOrThrow
   */
  export type VenueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venue to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Venues.
     */
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue findMany
   */
  export type VenueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter, which Venues to fetch.
     */
    where?: VenueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Venues to fetch.
     */
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Venues.
     */
    cursor?: VenueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Venues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Venues.
     */
    skip?: number
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Venue create
   */
  export type VenueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The data needed to create a Venue.
     */
    data: XOR<VenueCreateInput, VenueUncheckedCreateInput>
  }

  /**
   * Venue createMany
   */
  export type VenueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Venues.
     */
    data: VenueCreateManyInput | VenueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Venue createManyAndReturn
   */
  export type VenueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * The data used to create many Venues.
     */
    data: VenueCreateManyInput | VenueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Venue update
   */
  export type VenueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The data needed to update a Venue.
     */
    data: XOR<VenueUpdateInput, VenueUncheckedUpdateInput>
    /**
     * Choose, which Venue to update.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue updateMany
   */
  export type VenueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Venues.
     */
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyInput>
    /**
     * Filter which Venues to update
     */
    where?: VenueWhereInput
    /**
     * Limit how many Venues to update.
     */
    limit?: number
  }

  /**
   * Venue updateManyAndReturn
   */
  export type VenueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * The data used to update Venues.
     */
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyInput>
    /**
     * Filter which Venues to update
     */
    where?: VenueWhereInput
    /**
     * Limit how many Venues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Venue upsert
   */
  export type VenueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * The filter to search for the Venue to update in case it exists.
     */
    where: VenueWhereUniqueInput
    /**
     * In case the Venue found by the `where` argument doesn't exist, create a new Venue with this data.
     */
    create: XOR<VenueCreateInput, VenueUncheckedCreateInput>
    /**
     * In case the Venue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VenueUpdateInput, VenueUncheckedUpdateInput>
  }

  /**
   * Venue delete
   */
  export type VenueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    /**
     * Filter which Venue to delete.
     */
    where: VenueWhereUniqueInput
  }

  /**
   * Venue deleteMany
   */
  export type VenueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Venues to delete
     */
    where?: VenueWhereInput
    /**
     * Limit how many Venues to delete.
     */
    limit?: number
  }

  /**
   * Venue.Profile
   */
  export type Venue$ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * Venue.amenities
   */
  export type Venue$amenitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    where?: AmenitiesWhereInput
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    cursor?: AmenitiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AmenitiesScalarFieldEnum | AmenitiesScalarFieldEnum[]
  }

  /**
   * Venue.arrangementsImage
   */
  export type Venue$arrangementsImageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileInstance
     */
    select?: FileInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileInstance
     */
    omit?: FileInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInstanceInclude<ExtArgs> | null
    where?: FileInstanceWhereInput
  }

  /**
   * Venue.shifts
   */
  export type Venue$shiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    cursor?: ShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Venue.reviews
   */
  export type Venue$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Venue.decoration
   */
  export type Venue$decorationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecorationInclude<ExtArgs> | null
    where?: DecorationWhereInput
  }

  /**
   * Venue.employees
   */
  export type Venue$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Venue.bookings
   */
  export type Venue$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    cursor?: BookingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Venue without action
   */
  export type VenueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    venueId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    venueId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    role: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    venueId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeMinAggregateInputType = {
    id?: true
    venueId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    venueId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    venueId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    venueId: string
    firstName: string
    lastName: string
    email: string
    phone: string
    role: string
    createdAt: Date
    updatedAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    shifts?: boolean | Employee$shiftsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    venueId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "venueId" | "firstName" | "lastName" | "email" | "phone" | "role" | "createdAt" | "updatedAt", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    shifts?: boolean | Employee$shiftsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      venue: Prisma.$VenuePayload<ExtArgs>
      shifts: Prisma.$ShiftPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      venueId: string
      firstName: string
      lastName: string
      email: string
      phone: string
      role: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    shifts<T extends Employee$shiftsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$shiftsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly venueId: FieldRef<"Employee", 'String'>
    readonly firstName: FieldRef<"Employee", 'String'>
    readonly lastName: FieldRef<"Employee", 'String'>
    readonly email: FieldRef<"Employee", 'String'>
    readonly phone: FieldRef<"Employee", 'String'>
    readonly role: FieldRef<"Employee", 'String'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.shifts
   */
  export type Employee$shiftsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    cursor?: ShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Shift
   */

  export type AggregateShift = {
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  export type ShiftAvgAggregateOutputType = {
    duration: number | null
  }

  export type ShiftSumAggregateOutputType = {
    duration: number | null
  }

  export type ShiftMinAggregateOutputType = {
    id: string | null
    venueId: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    shiftName: string | null
    employeeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftMaxAggregateOutputType = {
    id: string | null
    venueId: string | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    shiftName: string | null
    employeeId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftCountAggregateOutputType = {
    id: number
    venueId: number
    startTime: number
    endTime: number
    duration: number
    shiftName: number
    employeeId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShiftAvgAggregateInputType = {
    duration?: true
  }

  export type ShiftSumAggregateInputType = {
    duration?: true
  }

  export type ShiftMinAggregateInputType = {
    id?: true
    venueId?: true
    startTime?: true
    endTime?: true
    duration?: true
    shiftName?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftMaxAggregateInputType = {
    id?: true
    venueId?: true
    startTime?: true
    endTime?: true
    duration?: true
    shiftName?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftCountAggregateInputType = {
    id?: true
    venueId?: true
    startTime?: true
    endTime?: true
    duration?: true
    shiftName?: true
    employeeId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shift to aggregate.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shifts
    **/
    _count?: true | ShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftMaxAggregateInputType
  }

  export type GetShiftAggregateType<T extends ShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShift[P]>
      : GetScalarType<T[P], AggregateShift[P]>
  }




  export type ShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithAggregationInput | ShiftOrderByWithAggregationInput[]
    by: ShiftScalarFieldEnum[] | ShiftScalarFieldEnum
    having?: ShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftCountAggregateInputType | true
    _avg?: ShiftAvgAggregateInputType
    _sum?: ShiftSumAggregateInputType
    _min?: ShiftMinAggregateInputType
    _max?: ShiftMaxAggregateInputType
  }

  export type ShiftGroupByOutputType = {
    id: string
    venueId: string
    startTime: Date
    endTime: Date
    duration: number
    shiftName: string
    employeeId: string
    createdAt: Date
    updatedAt: Date
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  type GetShiftGroupByPayload<T extends ShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftGroupByOutputType[P]>
        }
      >
    >


  export type ShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    shiftName?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    shiftName?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    shiftName?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectScalar = {
    id?: boolean
    venueId?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    shiftName?: boolean
    employeeId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShiftOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "venueId" | "startTime" | "endTime" | "duration" | "shiftName" | "employeeId" | "createdAt" | "updatedAt", ExtArgs["result"]["shift"]>
  export type ShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type ShiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type ShiftIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | VenueDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $ShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shift"
    objects: {
      venue: Prisma.$VenuePayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      venueId: string
      startTime: Date
      endTime: Date
      duration: number
      shiftName: string
      employeeId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shift"]>
    composites: {}
  }

  type ShiftGetPayload<S extends boolean | null | undefined | ShiftDefaultArgs> = $Result.GetResult<Prisma.$ShiftPayload, S>

  type ShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ShiftFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ShiftCountAggregateInputType | true
    }

  export interface ShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shift'], meta: { name: 'Shift' } }
    /**
     * Find zero or one Shift that matches the filter.
     * @param {ShiftFindUniqueArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftFindUniqueArgs>(args: SelectSubset<T, ShiftFindUniqueArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Shift that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ShiftFindUniqueOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftFindFirstArgs>(args?: SelectSubset<T, ShiftFindFirstArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Shift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Shifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shifts
     * const shifts = await prisma.shift.findMany()
     * 
     * // Get first 10 Shifts
     * const shifts = await prisma.shift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftWithIdOnly = await prisma.shift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftFindManyArgs>(args?: SelectSubset<T, ShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Shift.
     * @param {ShiftCreateArgs} args - Arguments to create a Shift.
     * @example
     * // Create one Shift
     * const Shift = await prisma.shift.create({
     *   data: {
     *     // ... data to create a Shift
     *   }
     * })
     * 
     */
    create<T extends ShiftCreateArgs>(args: SelectSubset<T, ShiftCreateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Shifts.
     * @param {ShiftCreateManyArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftCreateManyArgs>(args?: SelectSubset<T, ShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shifts and returns the data saved in the database.
     * @param {ShiftCreateManyAndReturnArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shifts and only return the `id`
     * const shiftWithIdOnly = await prisma.shift.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Shift.
     * @param {ShiftDeleteArgs} args - Arguments to delete one Shift.
     * @example
     * // Delete one Shift
     * const Shift = await prisma.shift.delete({
     *   where: {
     *     // ... filter to delete one Shift
     *   }
     * })
     * 
     */
    delete<T extends ShiftDeleteArgs>(args: SelectSubset<T, ShiftDeleteArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Shift.
     * @param {ShiftUpdateArgs} args - Arguments to update one Shift.
     * @example
     * // Update one Shift
     * const shift = await prisma.shift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftUpdateArgs>(args: SelectSubset<T, ShiftUpdateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Shifts.
     * @param {ShiftDeleteManyArgs} args - Arguments to filter Shifts to delete.
     * @example
     * // Delete a few Shifts
     * const { count } = await prisma.shift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftDeleteManyArgs>(args?: SelectSubset<T, ShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftUpdateManyArgs>(args: SelectSubset<T, ShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts and returns the data updated in the database.
     * @param {ShiftUpdateManyAndReturnArgs} args - Arguments to update many Shifts.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Shifts and only return the `id`
     * const shiftWithIdOnly = await prisma.shift.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ShiftUpdateManyAndReturnArgs>(args: SelectSubset<T, ShiftUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Shift.
     * @param {ShiftUpsertArgs} args - Arguments to update or create a Shift.
     * @example
     * // Update or create a Shift
     * const shift = await prisma.shift.upsert({
     *   create: {
     *     // ... data to create a Shift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shift we want to update
     *   }
     * })
     */
    upsert<T extends ShiftUpsertArgs>(args: SelectSubset<T, ShiftUpsertArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftCountArgs} args - Arguments to filter Shifts to count.
     * @example
     * // Count the number of Shifts
     * const count = await prisma.shift.count({
     *   where: {
     *     // ... the filter for the Shifts we want to count
     *   }
     * })
    **/
    count<T extends ShiftCountArgs>(
      args?: Subset<T, ShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftAggregateArgs>(args: Subset<T, ShiftAggregateArgs>): Prisma.PrismaPromise<GetShiftAggregateType<T>>

    /**
     * Group by Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftGroupByArgs['orderBy'] }
        : { orderBy?: ShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shift model
   */
  readonly fields: ShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shift model
   */
  interface ShiftFieldRefs {
    readonly id: FieldRef<"Shift", 'String'>
    readonly venueId: FieldRef<"Shift", 'String'>
    readonly startTime: FieldRef<"Shift", 'DateTime'>
    readonly endTime: FieldRef<"Shift", 'DateTime'>
    readonly duration: FieldRef<"Shift", 'Int'>
    readonly shiftName: FieldRef<"Shift", 'String'>
    readonly employeeId: FieldRef<"Shift", 'String'>
    readonly createdAt: FieldRef<"Shift", 'DateTime'>
    readonly updatedAt: FieldRef<"Shift", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shift findUnique
   */
  export type ShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findUniqueOrThrow
   */
  export type ShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findFirst
   */
  export type ShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findFirstOrThrow
   */
  export type ShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findMany
   */
  export type ShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shifts to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift create
   */
  export type ShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a Shift.
     */
    data: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
  }

  /**
   * Shift createMany
   */
  export type ShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shift createManyAndReturn
   */
  export type ShiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shift update
   */
  export type ShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a Shift.
     */
    data: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
    /**
     * Choose, which Shift to update.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift updateMany
   */
  export type ShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to update.
     */
    limit?: number
  }

  /**
   * Shift updateManyAndReturn
   */
  export type ShiftUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shift upsert
   */
  export type ShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the Shift to update in case it exists.
     */
    where: ShiftWhereUniqueInput
    /**
     * In case the Shift found by the `where` argument doesn't exist, create a new Shift with this data.
     */
    create: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
    /**
     * In case the Shift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
  }

  /**
   * Shift delete
   */
  export type ShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter which Shift to delete.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift deleteMany
   */
  export type ShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shifts to delete
     */
    where?: ShiftWhereInput
    /**
     * Limit how many Shifts to delete.
     */
    limit?: number
  }

  /**
   * Shift without action
   */
  export type ShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Shift
     */
    omit?: ShiftOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
  }


  /**
   * Model Booking
   */

  export type AggregateBooking = {
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  export type BookingAvgAggregateOutputType = {
    duration: number | null
    guestNumber: number | null
    totalCost: number | null
    totalAmount: number | null
    paid: number | null
    due: number | null
  }

  export type BookingSumAggregateOutputType = {
    duration: number | null
    guestNumber: number | null
    totalCost: number | null
    totalAmount: number | null
    paid: number | null
    due: number | null
  }

  export type BookingMinAggregateOutputType = {
    id: string | null
    bookedById: string | null
    venueId: string | null
    serviceProviderId: string | null
    eventName: string | null
    location: string | null
    plannerName: string | null
    selectedDate: Date | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    bookingType: $Enums.BookingType | null
    guestNumber: number | null
    decoration: string | null
    totalCost: number | null
    bookingStatus: $Enums.BookingStatus | null
    totalAmount: number | null
    paid: number | null
    due: number | null
    accept: $Enums.AcceptanceStatus | null
    isEventFinished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingMaxAggregateOutputType = {
    id: string | null
    bookedById: string | null
    venueId: string | null
    serviceProviderId: string | null
    eventName: string | null
    location: string | null
    plannerName: string | null
    selectedDate: Date | null
    startTime: Date | null
    endTime: Date | null
    duration: number | null
    bookingType: $Enums.BookingType | null
    guestNumber: number | null
    decoration: string | null
    totalCost: number | null
    bookingStatus: $Enums.BookingStatus | null
    totalAmount: number | null
    paid: number | null
    due: number | null
    accept: $Enums.AcceptanceStatus | null
    isEventFinished: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BookingCountAggregateOutputType = {
    id: number
    bookedById: number
    venueId: number
    serviceProviderId: number
    eventName: number
    location: number
    plannerName: number
    selectedDate: number
    startTime: number
    endTime: number
    duration: number
    bookingType: number
    guestNumber: number
    decoration: number
    services: number
    totalCost: number
    bookingStatus: number
    totalAmount: number
    paid: number
    due: number
    accept: number
    isEventFinished: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BookingAvgAggregateInputType = {
    duration?: true
    guestNumber?: true
    totalCost?: true
    totalAmount?: true
    paid?: true
    due?: true
  }

  export type BookingSumAggregateInputType = {
    duration?: true
    guestNumber?: true
    totalCost?: true
    totalAmount?: true
    paid?: true
    due?: true
  }

  export type BookingMinAggregateInputType = {
    id?: true
    bookedById?: true
    venueId?: true
    serviceProviderId?: true
    eventName?: true
    location?: true
    plannerName?: true
    selectedDate?: true
    startTime?: true
    endTime?: true
    duration?: true
    bookingType?: true
    guestNumber?: true
    decoration?: true
    totalCost?: true
    bookingStatus?: true
    totalAmount?: true
    paid?: true
    due?: true
    accept?: true
    isEventFinished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingMaxAggregateInputType = {
    id?: true
    bookedById?: true
    venueId?: true
    serviceProviderId?: true
    eventName?: true
    location?: true
    plannerName?: true
    selectedDate?: true
    startTime?: true
    endTime?: true
    duration?: true
    bookingType?: true
    guestNumber?: true
    decoration?: true
    totalCost?: true
    bookingStatus?: true
    totalAmount?: true
    paid?: true
    due?: true
    accept?: true
    isEventFinished?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BookingCountAggregateInputType = {
    id?: true
    bookedById?: true
    venueId?: true
    serviceProviderId?: true
    eventName?: true
    location?: true
    plannerName?: true
    selectedDate?: true
    startTime?: true
    endTime?: true
    duration?: true
    bookingType?: true
    guestNumber?: true
    decoration?: true
    services?: true
    totalCost?: true
    bookingStatus?: true
    totalAmount?: true
    paid?: true
    due?: true
    accept?: true
    isEventFinished?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BookingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Booking to aggregate.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bookings
    **/
    _count?: true | BookingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BookingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BookingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BookingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BookingMaxAggregateInputType
  }

  export type GetBookingAggregateType<T extends BookingAggregateArgs> = {
        [P in keyof T & keyof AggregateBooking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBooking[P]>
      : GetScalarType<T[P], AggregateBooking[P]>
  }




  export type BookingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BookingWhereInput
    orderBy?: BookingOrderByWithAggregationInput | BookingOrderByWithAggregationInput[]
    by: BookingScalarFieldEnum[] | BookingScalarFieldEnum
    having?: BookingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BookingCountAggregateInputType | true
    _avg?: BookingAvgAggregateInputType
    _sum?: BookingSumAggregateInputType
    _min?: BookingMinAggregateInputType
    _max?: BookingMaxAggregateInputType
  }

  export type BookingGroupByOutputType = {
    id: string
    bookedById: string
    venueId: string | null
    serviceProviderId: string | null
    eventName: string
    location: string
    plannerName: string
    selectedDate: Date
    startTime: Date
    endTime: Date
    duration: number
    bookingType: $Enums.BookingType
    guestNumber: number
    decoration: string | null
    services: string[]
    totalCost: number
    bookingStatus: $Enums.BookingStatus
    totalAmount: number
    paid: number
    due: number
    accept: $Enums.AcceptanceStatus
    isEventFinished: boolean
    createdAt: Date
    updatedAt: Date
    _count: BookingCountAggregateOutputType | null
    _avg: BookingAvgAggregateOutputType | null
    _sum: BookingSumAggregateOutputType | null
    _min: BookingMinAggregateOutputType | null
    _max: BookingMaxAggregateOutputType | null
  }

  type GetBookingGroupByPayload<T extends BookingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BookingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BookingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BookingGroupByOutputType[P]>
            : GetScalarType<T[P], BookingGroupByOutputType[P]>
        }
      >
    >


  export type BookingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookedById?: boolean
    venueId?: boolean
    serviceProviderId?: boolean
    eventName?: boolean
    location?: boolean
    plannerName?: boolean
    selectedDate?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    bookingType?: boolean
    guestNumber?: boolean
    decoration?: boolean
    services?: boolean
    totalCost?: boolean
    bookingStatus?: boolean
    totalAmount?: boolean
    paid?: boolean
    due?: boolean
    accept?: boolean
    isEventFinished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookedBy?: boolean | ProfileDefaultArgs<ExtArgs>
    venue?: boolean | Booking$venueArgs<ExtArgs>
    serviceProvider?: boolean | Booking$serviceProviderArgs<ExtArgs>
    eventType?: boolean | Booking$eventTypeArgs<ExtArgs>
    payment?: boolean | Booking$paymentArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookedById?: boolean
    venueId?: boolean
    serviceProviderId?: boolean
    eventName?: boolean
    location?: boolean
    plannerName?: boolean
    selectedDate?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    bookingType?: boolean
    guestNumber?: boolean
    decoration?: boolean
    services?: boolean
    totalCost?: boolean
    bookingStatus?: boolean
    totalAmount?: boolean
    paid?: boolean
    due?: boolean
    accept?: boolean
    isEventFinished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookedBy?: boolean | ProfileDefaultArgs<ExtArgs>
    venue?: boolean | Booking$venueArgs<ExtArgs>
    serviceProvider?: boolean | Booking$serviceProviderArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookedById?: boolean
    venueId?: boolean
    serviceProviderId?: boolean
    eventName?: boolean
    location?: boolean
    plannerName?: boolean
    selectedDate?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    bookingType?: boolean
    guestNumber?: boolean
    decoration?: boolean
    services?: boolean
    totalCost?: boolean
    bookingStatus?: boolean
    totalAmount?: boolean
    paid?: boolean
    due?: boolean
    accept?: boolean
    isEventFinished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookedBy?: boolean | ProfileDefaultArgs<ExtArgs>
    venue?: boolean | Booking$venueArgs<ExtArgs>
    serviceProvider?: boolean | Booking$serviceProviderArgs<ExtArgs>
  }, ExtArgs["result"]["booking"]>

  export type BookingSelectScalar = {
    id?: boolean
    bookedById?: boolean
    venueId?: boolean
    serviceProviderId?: boolean
    eventName?: boolean
    location?: boolean
    plannerName?: boolean
    selectedDate?: boolean
    startTime?: boolean
    endTime?: boolean
    duration?: boolean
    bookingType?: boolean
    guestNumber?: boolean
    decoration?: boolean
    services?: boolean
    totalCost?: boolean
    bookingStatus?: boolean
    totalAmount?: boolean
    paid?: boolean
    due?: boolean
    accept?: boolean
    isEventFinished?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BookingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookedById" | "venueId" | "serviceProviderId" | "eventName" | "location" | "plannerName" | "selectedDate" | "startTime" | "endTime" | "duration" | "bookingType" | "guestNumber" | "decoration" | "services" | "totalCost" | "bookingStatus" | "totalAmount" | "paid" | "due" | "accept" | "isEventFinished" | "createdAt" | "updatedAt", ExtArgs["result"]["booking"]>
  export type BookingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookedBy?: boolean | ProfileDefaultArgs<ExtArgs>
    venue?: boolean | Booking$venueArgs<ExtArgs>
    serviceProvider?: boolean | Booking$serviceProviderArgs<ExtArgs>
    eventType?: boolean | Booking$eventTypeArgs<ExtArgs>
    payment?: boolean | Booking$paymentArgs<ExtArgs>
    _count?: boolean | BookingCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BookingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookedBy?: boolean | ProfileDefaultArgs<ExtArgs>
    venue?: boolean | Booking$venueArgs<ExtArgs>
    serviceProvider?: boolean | Booking$serviceProviderArgs<ExtArgs>
  }
  export type BookingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookedBy?: boolean | ProfileDefaultArgs<ExtArgs>
    venue?: boolean | Booking$venueArgs<ExtArgs>
    serviceProvider?: boolean | Booking$serviceProviderArgs<ExtArgs>
  }

  export type $BookingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Booking"
    objects: {
      bookedBy: Prisma.$ProfilePayload<ExtArgs>
      venue: Prisma.$VenuePayload<ExtArgs> | null
      serviceProvider: Prisma.$ProfilePayload<ExtArgs> | null
      eventType: Prisma.$EventTypePayload<ExtArgs> | null
      payment: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookedById: string
      venueId: string | null
      serviceProviderId: string | null
      eventName: string
      location: string
      plannerName: string
      selectedDate: Date
      startTime: Date
      endTime: Date
      duration: number
      bookingType: $Enums.BookingType
      guestNumber: number
      decoration: string | null
      services: string[]
      totalCost: number
      bookingStatus: $Enums.BookingStatus
      totalAmount: number
      paid: number
      due: number
      accept: $Enums.AcceptanceStatus
      isEventFinished: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["booking"]>
    composites: {}
  }

  type BookingGetPayload<S extends boolean | null | undefined | BookingDefaultArgs> = $Result.GetResult<Prisma.$BookingPayload, S>

  type BookingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BookingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BookingCountAggregateInputType | true
    }

  export interface BookingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Booking'], meta: { name: 'Booking' } }
    /**
     * Find zero or one Booking that matches the filter.
     * @param {BookingFindUniqueArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BookingFindUniqueArgs>(args: SelectSubset<T, BookingFindUniqueArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Booking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BookingFindUniqueOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BookingFindUniqueOrThrowArgs>(args: SelectSubset<T, BookingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BookingFindFirstArgs>(args?: SelectSubset<T, BookingFindFirstArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Booking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindFirstOrThrowArgs} args - Arguments to find a Booking
     * @example
     * // Get one Booking
     * const booking = await prisma.booking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BookingFindFirstOrThrowArgs>(args?: SelectSubset<T, BookingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bookings
     * const bookings = await prisma.booking.findMany()
     * 
     * // Get first 10 Bookings
     * const bookings = await prisma.booking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bookingWithIdOnly = await prisma.booking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BookingFindManyArgs>(args?: SelectSubset<T, BookingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Booking.
     * @param {BookingCreateArgs} args - Arguments to create a Booking.
     * @example
     * // Create one Booking
     * const Booking = await prisma.booking.create({
     *   data: {
     *     // ... data to create a Booking
     *   }
     * })
     * 
     */
    create<T extends BookingCreateArgs>(args: SelectSubset<T, BookingCreateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bookings.
     * @param {BookingCreateManyArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BookingCreateManyArgs>(args?: SelectSubset<T, BookingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bookings and returns the data saved in the database.
     * @param {BookingCreateManyAndReturnArgs} args - Arguments to create many Bookings.
     * @example
     * // Create many Bookings
     * const booking = await prisma.booking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BookingCreateManyAndReturnArgs>(args?: SelectSubset<T, BookingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Booking.
     * @param {BookingDeleteArgs} args - Arguments to delete one Booking.
     * @example
     * // Delete one Booking
     * const Booking = await prisma.booking.delete({
     *   where: {
     *     // ... filter to delete one Booking
     *   }
     * })
     * 
     */
    delete<T extends BookingDeleteArgs>(args: SelectSubset<T, BookingDeleteArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Booking.
     * @param {BookingUpdateArgs} args - Arguments to update one Booking.
     * @example
     * // Update one Booking
     * const booking = await prisma.booking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BookingUpdateArgs>(args: SelectSubset<T, BookingUpdateArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bookings.
     * @param {BookingDeleteManyArgs} args - Arguments to filter Bookings to delete.
     * @example
     * // Delete a few Bookings
     * const { count } = await prisma.booking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BookingDeleteManyArgs>(args?: SelectSubset<T, BookingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BookingUpdateManyArgs>(args: SelectSubset<T, BookingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bookings and returns the data updated in the database.
     * @param {BookingUpdateManyAndReturnArgs} args - Arguments to update many Bookings.
     * @example
     * // Update many Bookings
     * const booking = await prisma.booking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bookings and only return the `id`
     * const bookingWithIdOnly = await prisma.booking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BookingUpdateManyAndReturnArgs>(args: SelectSubset<T, BookingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Booking.
     * @param {BookingUpsertArgs} args - Arguments to update or create a Booking.
     * @example
     * // Update or create a Booking
     * const booking = await prisma.booking.upsert({
     *   create: {
     *     // ... data to create a Booking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Booking we want to update
     *   }
     * })
     */
    upsert<T extends BookingUpsertArgs>(args: SelectSubset<T, BookingUpsertArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingCountArgs} args - Arguments to filter Bookings to count.
     * @example
     * // Count the number of Bookings
     * const count = await prisma.booking.count({
     *   where: {
     *     // ... the filter for the Bookings we want to count
     *   }
     * })
    **/
    count<T extends BookingCountArgs>(
      args?: Subset<T, BookingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BookingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BookingAggregateArgs>(args: Subset<T, BookingAggregateArgs>): Prisma.PrismaPromise<GetBookingAggregateType<T>>

    /**
     * Group by Booking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BookingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BookingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BookingGroupByArgs['orderBy'] }
        : { orderBy?: BookingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BookingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBookingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Booking model
   */
  readonly fields: BookingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Booking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BookingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookedBy<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    venue<T extends Booking$venueArgs<ExtArgs> = {}>(args?: Subset<T, Booking$venueArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    serviceProvider<T extends Booking$serviceProviderArgs<ExtArgs> = {}>(args?: Subset<T, Booking$serviceProviderArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    eventType<T extends Booking$eventTypeArgs<ExtArgs> = {}>(args?: Subset<T, Booking$eventTypeArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    payment<T extends Booking$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Booking$paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Booking model
   */
  interface BookingFieldRefs {
    readonly id: FieldRef<"Booking", 'String'>
    readonly bookedById: FieldRef<"Booking", 'String'>
    readonly venueId: FieldRef<"Booking", 'String'>
    readonly serviceProviderId: FieldRef<"Booking", 'String'>
    readonly eventName: FieldRef<"Booking", 'String'>
    readonly location: FieldRef<"Booking", 'String'>
    readonly plannerName: FieldRef<"Booking", 'String'>
    readonly selectedDate: FieldRef<"Booking", 'DateTime'>
    readonly startTime: FieldRef<"Booking", 'DateTime'>
    readonly endTime: FieldRef<"Booking", 'DateTime'>
    readonly duration: FieldRef<"Booking", 'Int'>
    readonly bookingType: FieldRef<"Booking", 'BookingType'>
    readonly guestNumber: FieldRef<"Booking", 'Int'>
    readonly decoration: FieldRef<"Booking", 'String'>
    readonly services: FieldRef<"Booking", 'String[]'>
    readonly totalCost: FieldRef<"Booking", 'Int'>
    readonly bookingStatus: FieldRef<"Booking", 'BookingStatus'>
    readonly totalAmount: FieldRef<"Booking", 'Int'>
    readonly paid: FieldRef<"Booking", 'Int'>
    readonly due: FieldRef<"Booking", 'Int'>
    readonly accept: FieldRef<"Booking", 'AcceptanceStatus'>
    readonly isEventFinished: FieldRef<"Booking", 'Boolean'>
    readonly createdAt: FieldRef<"Booking", 'DateTime'>
    readonly updatedAt: FieldRef<"Booking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Booking findUnique
   */
  export type BookingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findUniqueOrThrow
   */
  export type BookingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking findFirst
   */
  export type BookingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findFirstOrThrow
   */
  export type BookingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Booking to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bookings.
     */
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking findMany
   */
  export type BookingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter, which Bookings to fetch.
     */
    where?: BookingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bookings to fetch.
     */
    orderBy?: BookingOrderByWithRelationInput | BookingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bookings.
     */
    cursor?: BookingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bookings.
     */
    skip?: number
    distinct?: BookingScalarFieldEnum | BookingScalarFieldEnum[]
  }

  /**
   * Booking create
   */
  export type BookingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to create a Booking.
     */
    data: XOR<BookingCreateInput, BookingUncheckedCreateInput>
  }

  /**
   * Booking createMany
   */
  export type BookingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Booking createManyAndReturn
   */
  export type BookingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to create many Bookings.
     */
    data: BookingCreateManyInput | BookingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking update
   */
  export type BookingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The data needed to update a Booking.
     */
    data: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
    /**
     * Choose, which Booking to update.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking updateMany
   */
  export type BookingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
  }

  /**
   * Booking updateManyAndReturn
   */
  export type BookingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * The data used to update Bookings.
     */
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyInput>
    /**
     * Filter which Bookings to update
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Booking upsert
   */
  export type BookingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * The filter to search for the Booking to update in case it exists.
     */
    where: BookingWhereUniqueInput
    /**
     * In case the Booking found by the `where` argument doesn't exist, create a new Booking with this data.
     */
    create: XOR<BookingCreateInput, BookingUncheckedCreateInput>
    /**
     * In case the Booking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BookingUpdateInput, BookingUncheckedUpdateInput>
  }

  /**
   * Booking delete
   */
  export type BookingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    /**
     * Filter which Booking to delete.
     */
    where: BookingWhereUniqueInput
  }

  /**
   * Booking deleteMany
   */
  export type BookingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bookings to delete
     */
    where?: BookingWhereInput
    /**
     * Limit how many Bookings to delete.
     */
    limit?: number
  }

  /**
   * Booking.venue
   */
  export type Booking$venueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    where?: VenueWhereInput
  }

  /**
   * Booking.serviceProvider
   */
  export type Booking$serviceProviderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * Booking.eventType
   */
  export type Booking$eventTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    where?: EventTypeWhereInput
  }

  /**
   * Booking.payment
   */
  export type Booking$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Booking without action
   */
  export type BookingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    bookingId: string | null
    paymentStatus: $Enums.PaymentStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    amount: number | null
    transactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    bookingId: string | null
    paymentStatus: $Enums.PaymentStatus | null
    paymentMethod: $Enums.PaymentMethod | null
    amount: number | null
    transactionId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    bookingId: number
    paymentStatus: number
    paymentMethod: number
    amount: number
    transactionId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    bookingId?: true
    paymentStatus?: true
    paymentMethod?: true
    amount?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    bookingId?: true
    paymentStatus?: true
    paymentMethod?: true
    amount?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    bookingId?: true
    paymentStatus?: true
    paymentMethod?: true
    amount?: true
    transactionId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    bookingId: string
    paymentStatus: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    amount: number
    transactionId: string | null
    createdAt: Date
    updatedAt: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    amount?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingInfo?: boolean | Payment$bookingInfoArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    amount?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingInfo?: boolean | Payment$bookingInfoArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bookingId?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    amount?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bookingInfo?: boolean | Payment$bookingInfoArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    bookingId?: boolean
    paymentStatus?: boolean
    paymentMethod?: boolean
    amount?: boolean
    transactionId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bookingId" | "paymentStatus" | "paymentMethod" | "amount" | "transactionId" | "createdAt" | "updatedAt", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingInfo?: boolean | Payment$bookingInfoArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingInfo?: boolean | Payment$bookingInfoArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bookingInfo?: boolean | Payment$bookingInfoArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      bookingInfo: Prisma.$BookingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bookingId: string
      paymentStatus: $Enums.PaymentStatus
      paymentMethod: $Enums.PaymentMethod
      amount: number
      transactionId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bookingInfo<T extends Payment$bookingInfoArgs<ExtArgs> = {}>(args?: Subset<T, Payment$bookingInfoArgs<ExtArgs>>): Prisma__BookingClient<$Result.GetResult<Prisma.$BookingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly bookingId: FieldRef<"Payment", 'String'>
    readonly paymentStatus: FieldRef<"Payment", 'PaymentStatus'>
    readonly paymentMethod: FieldRef<"Payment", 'PaymentMethod'>
    readonly amount: FieldRef<"Payment", 'Int'>
    readonly transactionId: FieldRef<"Payment", 'String'>
    readonly createdAt: FieldRef<"Payment", 'DateTime'>
    readonly updatedAt: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.bookingInfo
   */
  export type Payment$bookingInfoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Booking
     */
    select?: BookingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Booking
     */
    omit?: BookingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BookingInclude<ExtArgs> | null
    where?: BookingWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Decoration
   */

  export type AggregateDecoration = {
    _count: DecorationCountAggregateOutputType | null
    _min: DecorationMinAggregateOutputType | null
    _max: DecorationMaxAggregateOutputType | null
  }

  export type DecorationMinAggregateOutputType = {
    id: string | null
    venueId: string | null
  }

  export type DecorationMaxAggregateOutputType = {
    id: string | null
    venueId: string | null
  }

  export type DecorationCountAggregateOutputType = {
    id: number
    venueId: number
    tableShapes: number
    seatingStyles: number
    lighting: number
    flowerColors: number
    flowerTypes: number
    fragrances: number
    _all: number
  }


  export type DecorationMinAggregateInputType = {
    id?: true
    venueId?: true
  }

  export type DecorationMaxAggregateInputType = {
    id?: true
    venueId?: true
  }

  export type DecorationCountAggregateInputType = {
    id?: true
    venueId?: true
    tableShapes?: true
    seatingStyles?: true
    lighting?: true
    flowerColors?: true
    flowerTypes?: true
    fragrances?: true
    _all?: true
  }

  export type DecorationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Decoration to aggregate.
     */
    where?: DecorationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Decorations to fetch.
     */
    orderBy?: DecorationOrderByWithRelationInput | DecorationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DecorationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Decorations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Decorations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Decorations
    **/
    _count?: true | DecorationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DecorationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DecorationMaxAggregateInputType
  }

  export type GetDecorationAggregateType<T extends DecorationAggregateArgs> = {
        [P in keyof T & keyof AggregateDecoration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDecoration[P]>
      : GetScalarType<T[P], AggregateDecoration[P]>
  }




  export type DecorationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DecorationWhereInput
    orderBy?: DecorationOrderByWithAggregationInput | DecorationOrderByWithAggregationInput[]
    by: DecorationScalarFieldEnum[] | DecorationScalarFieldEnum
    having?: DecorationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DecorationCountAggregateInputType | true
    _min?: DecorationMinAggregateInputType
    _max?: DecorationMaxAggregateInputType
  }

  export type DecorationGroupByOutputType = {
    id: string
    venueId: string
    tableShapes: $Enums.TableShape[]
    seatingStyles: $Enums.SeatingStyle[]
    lighting: $Enums.LightingStyle[]
    flowerColors: $Enums.FlowerColor[]
    flowerTypes: $Enums.FlowerType[]
    fragrances: $Enums.Fragrance[]
    _count: DecorationCountAggregateOutputType | null
    _min: DecorationMinAggregateOutputType | null
    _max: DecorationMaxAggregateOutputType | null
  }

  type GetDecorationGroupByPayload<T extends DecorationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DecorationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DecorationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DecorationGroupByOutputType[P]>
            : GetScalarType<T[P], DecorationGroupByOutputType[P]>
        }
      >
    >


  export type DecorationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    tableShapes?: boolean
    seatingStyles?: boolean
    lighting?: boolean
    flowerColors?: boolean
    flowerTypes?: boolean
    fragrances?: boolean
    venue?: boolean | Decoration$venueArgs<ExtArgs>
  }, ExtArgs["result"]["decoration"]>

  export type DecorationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    tableShapes?: boolean
    seatingStyles?: boolean
    lighting?: boolean
    flowerColors?: boolean
    flowerTypes?: boolean
    fragrances?: boolean
    venue?: boolean | Decoration$venueArgs<ExtArgs>
  }, ExtArgs["result"]["decoration"]>

  export type DecorationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    tableShapes?: boolean
    seatingStyles?: boolean
    lighting?: boolean
    flowerColors?: boolean
    flowerTypes?: boolean
    fragrances?: boolean
    venue?: boolean | Decoration$venueArgs<ExtArgs>
  }, ExtArgs["result"]["decoration"]>

  export type DecorationSelectScalar = {
    id?: boolean
    venueId?: boolean
    tableShapes?: boolean
    seatingStyles?: boolean
    lighting?: boolean
    flowerColors?: boolean
    flowerTypes?: boolean
    fragrances?: boolean
  }

  export type DecorationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "venueId" | "tableShapes" | "seatingStyles" | "lighting" | "flowerColors" | "flowerTypes" | "fragrances", ExtArgs["result"]["decoration"]>
  export type DecorationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | Decoration$venueArgs<ExtArgs>
  }
  export type DecorationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | Decoration$venueArgs<ExtArgs>
  }
  export type DecorationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    venue?: boolean | Decoration$venueArgs<ExtArgs>
  }

  export type $DecorationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Decoration"
    objects: {
      venue: Prisma.$VenuePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      venueId: string
      tableShapes: $Enums.TableShape[]
      seatingStyles: $Enums.SeatingStyle[]
      lighting: $Enums.LightingStyle[]
      flowerColors: $Enums.FlowerColor[]
      flowerTypes: $Enums.FlowerType[]
      fragrances: $Enums.Fragrance[]
    }, ExtArgs["result"]["decoration"]>
    composites: {}
  }

  type DecorationGetPayload<S extends boolean | null | undefined | DecorationDefaultArgs> = $Result.GetResult<Prisma.$DecorationPayload, S>

  type DecorationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DecorationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DecorationCountAggregateInputType | true
    }

  export interface DecorationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Decoration'], meta: { name: 'Decoration' } }
    /**
     * Find zero or one Decoration that matches the filter.
     * @param {DecorationFindUniqueArgs} args - Arguments to find a Decoration
     * @example
     * // Get one Decoration
     * const decoration = await prisma.decoration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DecorationFindUniqueArgs>(args: SelectSubset<T, DecorationFindUniqueArgs<ExtArgs>>): Prisma__DecorationClient<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Decoration that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DecorationFindUniqueOrThrowArgs} args - Arguments to find a Decoration
     * @example
     * // Get one Decoration
     * const decoration = await prisma.decoration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DecorationFindUniqueOrThrowArgs>(args: SelectSubset<T, DecorationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DecorationClient<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Decoration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecorationFindFirstArgs} args - Arguments to find a Decoration
     * @example
     * // Get one Decoration
     * const decoration = await prisma.decoration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DecorationFindFirstArgs>(args?: SelectSubset<T, DecorationFindFirstArgs<ExtArgs>>): Prisma__DecorationClient<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Decoration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecorationFindFirstOrThrowArgs} args - Arguments to find a Decoration
     * @example
     * // Get one Decoration
     * const decoration = await prisma.decoration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DecorationFindFirstOrThrowArgs>(args?: SelectSubset<T, DecorationFindFirstOrThrowArgs<ExtArgs>>): Prisma__DecorationClient<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Decorations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecorationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Decorations
     * const decorations = await prisma.decoration.findMany()
     * 
     * // Get first 10 Decorations
     * const decorations = await prisma.decoration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const decorationWithIdOnly = await prisma.decoration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DecorationFindManyArgs>(args?: SelectSubset<T, DecorationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Decoration.
     * @param {DecorationCreateArgs} args - Arguments to create a Decoration.
     * @example
     * // Create one Decoration
     * const Decoration = await prisma.decoration.create({
     *   data: {
     *     // ... data to create a Decoration
     *   }
     * })
     * 
     */
    create<T extends DecorationCreateArgs>(args: SelectSubset<T, DecorationCreateArgs<ExtArgs>>): Prisma__DecorationClient<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Decorations.
     * @param {DecorationCreateManyArgs} args - Arguments to create many Decorations.
     * @example
     * // Create many Decorations
     * const decoration = await prisma.decoration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DecorationCreateManyArgs>(args?: SelectSubset<T, DecorationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Decorations and returns the data saved in the database.
     * @param {DecorationCreateManyAndReturnArgs} args - Arguments to create many Decorations.
     * @example
     * // Create many Decorations
     * const decoration = await prisma.decoration.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Decorations and only return the `id`
     * const decorationWithIdOnly = await prisma.decoration.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DecorationCreateManyAndReturnArgs>(args?: SelectSubset<T, DecorationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Decoration.
     * @param {DecorationDeleteArgs} args - Arguments to delete one Decoration.
     * @example
     * // Delete one Decoration
     * const Decoration = await prisma.decoration.delete({
     *   where: {
     *     // ... filter to delete one Decoration
     *   }
     * })
     * 
     */
    delete<T extends DecorationDeleteArgs>(args: SelectSubset<T, DecorationDeleteArgs<ExtArgs>>): Prisma__DecorationClient<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Decoration.
     * @param {DecorationUpdateArgs} args - Arguments to update one Decoration.
     * @example
     * // Update one Decoration
     * const decoration = await prisma.decoration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DecorationUpdateArgs>(args: SelectSubset<T, DecorationUpdateArgs<ExtArgs>>): Prisma__DecorationClient<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Decorations.
     * @param {DecorationDeleteManyArgs} args - Arguments to filter Decorations to delete.
     * @example
     * // Delete a few Decorations
     * const { count } = await prisma.decoration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DecorationDeleteManyArgs>(args?: SelectSubset<T, DecorationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Decorations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecorationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Decorations
     * const decoration = await prisma.decoration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DecorationUpdateManyArgs>(args: SelectSubset<T, DecorationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Decorations and returns the data updated in the database.
     * @param {DecorationUpdateManyAndReturnArgs} args - Arguments to update many Decorations.
     * @example
     * // Update many Decorations
     * const decoration = await prisma.decoration.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Decorations and only return the `id`
     * const decorationWithIdOnly = await prisma.decoration.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DecorationUpdateManyAndReturnArgs>(args: SelectSubset<T, DecorationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Decoration.
     * @param {DecorationUpsertArgs} args - Arguments to update or create a Decoration.
     * @example
     * // Update or create a Decoration
     * const decoration = await prisma.decoration.upsert({
     *   create: {
     *     // ... data to create a Decoration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Decoration we want to update
     *   }
     * })
     */
    upsert<T extends DecorationUpsertArgs>(args: SelectSubset<T, DecorationUpsertArgs<ExtArgs>>): Prisma__DecorationClient<$Result.GetResult<Prisma.$DecorationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Decorations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecorationCountArgs} args - Arguments to filter Decorations to count.
     * @example
     * // Count the number of Decorations
     * const count = await prisma.decoration.count({
     *   where: {
     *     // ... the filter for the Decorations we want to count
     *   }
     * })
    **/
    count<T extends DecorationCountArgs>(
      args?: Subset<T, DecorationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DecorationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Decoration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecorationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DecorationAggregateArgs>(args: Subset<T, DecorationAggregateArgs>): Prisma.PrismaPromise<GetDecorationAggregateType<T>>

    /**
     * Group by Decoration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecorationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DecorationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DecorationGroupByArgs['orderBy'] }
        : { orderBy?: DecorationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DecorationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDecorationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Decoration model
   */
  readonly fields: DecorationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Decoration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DecorationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    venue<T extends Decoration$venueArgs<ExtArgs> = {}>(args?: Subset<T, Decoration$venueArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Decoration model
   */
  interface DecorationFieldRefs {
    readonly id: FieldRef<"Decoration", 'String'>
    readonly venueId: FieldRef<"Decoration", 'String'>
    readonly tableShapes: FieldRef<"Decoration", 'TableShape[]'>
    readonly seatingStyles: FieldRef<"Decoration", 'SeatingStyle[]'>
    readonly lighting: FieldRef<"Decoration", 'LightingStyle[]'>
    readonly flowerColors: FieldRef<"Decoration", 'FlowerColor[]'>
    readonly flowerTypes: FieldRef<"Decoration", 'FlowerType[]'>
    readonly fragrances: FieldRef<"Decoration", 'Fragrance[]'>
  }
    

  // Custom InputTypes
  /**
   * Decoration findUnique
   */
  export type DecorationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecorationInclude<ExtArgs> | null
    /**
     * Filter, which Decoration to fetch.
     */
    where: DecorationWhereUniqueInput
  }

  /**
   * Decoration findUniqueOrThrow
   */
  export type DecorationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecorationInclude<ExtArgs> | null
    /**
     * Filter, which Decoration to fetch.
     */
    where: DecorationWhereUniqueInput
  }

  /**
   * Decoration findFirst
   */
  export type DecorationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecorationInclude<ExtArgs> | null
    /**
     * Filter, which Decoration to fetch.
     */
    where?: DecorationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Decorations to fetch.
     */
    orderBy?: DecorationOrderByWithRelationInput | DecorationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Decorations.
     */
    cursor?: DecorationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Decorations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Decorations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Decorations.
     */
    distinct?: DecorationScalarFieldEnum | DecorationScalarFieldEnum[]
  }

  /**
   * Decoration findFirstOrThrow
   */
  export type DecorationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecorationInclude<ExtArgs> | null
    /**
     * Filter, which Decoration to fetch.
     */
    where?: DecorationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Decorations to fetch.
     */
    orderBy?: DecorationOrderByWithRelationInput | DecorationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Decorations.
     */
    cursor?: DecorationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Decorations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Decorations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Decorations.
     */
    distinct?: DecorationScalarFieldEnum | DecorationScalarFieldEnum[]
  }

  /**
   * Decoration findMany
   */
  export type DecorationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecorationInclude<ExtArgs> | null
    /**
     * Filter, which Decorations to fetch.
     */
    where?: DecorationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Decorations to fetch.
     */
    orderBy?: DecorationOrderByWithRelationInput | DecorationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Decorations.
     */
    cursor?: DecorationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Decorations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Decorations.
     */
    skip?: number
    distinct?: DecorationScalarFieldEnum | DecorationScalarFieldEnum[]
  }

  /**
   * Decoration create
   */
  export type DecorationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecorationInclude<ExtArgs> | null
    /**
     * The data needed to create a Decoration.
     */
    data: XOR<DecorationCreateInput, DecorationUncheckedCreateInput>
  }

  /**
   * Decoration createMany
   */
  export type DecorationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Decorations.
     */
    data: DecorationCreateManyInput | DecorationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Decoration createManyAndReturn
   */
  export type DecorationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * The data used to create many Decorations.
     */
    data: DecorationCreateManyInput | DecorationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecorationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Decoration update
   */
  export type DecorationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecorationInclude<ExtArgs> | null
    /**
     * The data needed to update a Decoration.
     */
    data: XOR<DecorationUpdateInput, DecorationUncheckedUpdateInput>
    /**
     * Choose, which Decoration to update.
     */
    where: DecorationWhereUniqueInput
  }

  /**
   * Decoration updateMany
   */
  export type DecorationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Decorations.
     */
    data: XOR<DecorationUpdateManyMutationInput, DecorationUncheckedUpdateManyInput>
    /**
     * Filter which Decorations to update
     */
    where?: DecorationWhereInput
    /**
     * Limit how many Decorations to update.
     */
    limit?: number
  }

  /**
   * Decoration updateManyAndReturn
   */
  export type DecorationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * The data used to update Decorations.
     */
    data: XOR<DecorationUpdateManyMutationInput, DecorationUncheckedUpdateManyInput>
    /**
     * Filter which Decorations to update
     */
    where?: DecorationWhereInput
    /**
     * Limit how many Decorations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecorationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Decoration upsert
   */
  export type DecorationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecorationInclude<ExtArgs> | null
    /**
     * The filter to search for the Decoration to update in case it exists.
     */
    where: DecorationWhereUniqueInput
    /**
     * In case the Decoration found by the `where` argument doesn't exist, create a new Decoration with this data.
     */
    create: XOR<DecorationCreateInput, DecorationUncheckedCreateInput>
    /**
     * In case the Decoration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DecorationUpdateInput, DecorationUncheckedUpdateInput>
  }

  /**
   * Decoration delete
   */
  export type DecorationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecorationInclude<ExtArgs> | null
    /**
     * Filter which Decoration to delete.
     */
    where: DecorationWhereUniqueInput
  }

  /**
   * Decoration deleteMany
   */
  export type DecorationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Decorations to delete
     */
    where?: DecorationWhereInput
    /**
     * Limit how many Decorations to delete.
     */
    limit?: number
  }

  /**
   * Decoration.venue
   */
  export type Decoration$venueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    where?: VenueWhereInput
  }

  /**
   * Decoration without action
   */
  export type DecorationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decoration
     */
    select?: DecorationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Decoration
     */
    omit?: DecorationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecorationInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    venueId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    profileId: string | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    venueId: string | null
    rating: number | null
    comment: string | null
    createdAt: Date | null
    profileId: string | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    venueId: number
    rating: number
    comment: number
    createdAt: number
    profileId: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    venueId?: true
    rating?: true
    comment?: true
    createdAt?: true
    profileId?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    venueId?: true
    rating?: true
    comment?: true
    createdAt?: true
    profileId?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    venueId?: true
    rating?: true
    comment?: true
    createdAt?: true
    profileId?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    venueId: string
    rating: number
    comment: string | null
    createdAt: Date
    profileId: string | null
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    profileId?: boolean
    Venue?: boolean | VenueDefaultArgs<ExtArgs>
    Profile?: boolean | Review$ProfileArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    profileId?: boolean
    Venue?: boolean | VenueDefaultArgs<ExtArgs>
    Profile?: boolean | Review$ProfileArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    venueId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    profileId?: boolean
    Venue?: boolean | VenueDefaultArgs<ExtArgs>
    Profile?: boolean | Review$ProfileArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    venueId?: boolean
    rating?: boolean
    comment?: boolean
    createdAt?: boolean
    profileId?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "venueId" | "rating" | "comment" | "createdAt" | "profileId", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Venue?: boolean | VenueDefaultArgs<ExtArgs>
    Profile?: boolean | Review$ProfileArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Venue?: boolean | VenueDefaultArgs<ExtArgs>
    Profile?: boolean | Review$ProfileArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Venue?: boolean | VenueDefaultArgs<ExtArgs>
    Profile?: boolean | Review$ProfileArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      Venue: Prisma.$VenuePayload<ExtArgs>
      Profile: Prisma.$ProfilePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      venueId: string
      rating: number
      comment: string | null
      createdAt: Date
      profileId: string | null
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Venue<T extends VenueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VenueDefaultArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Profile<T extends Review$ProfileArgs<ExtArgs> = {}>(args?: Subset<T, Review$ProfileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly venueId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Int'>
    readonly comment: FieldRef<"Review", 'String'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly profileId: FieldRef<"Review", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review.Profile
   */
  export type Review$ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model Amenities
   */

  export type AggregateAmenities = {
    _count: AmenitiesCountAggregateOutputType | null
    _min: AmenitiesMinAggregateOutputType | null
    _max: AmenitiesMaxAggregateOutputType | null
  }

  export type AmenitiesMinAggregateOutputType = {
    id: string | null
    name: string | null
    default: boolean | null
  }

  export type AmenitiesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    default: boolean | null
  }

  export type AmenitiesCountAggregateOutputType = {
    id: number
    name: number
    default: number
    _all: number
  }


  export type AmenitiesMinAggregateInputType = {
    id?: true
    name?: true
    default?: true
  }

  export type AmenitiesMaxAggregateInputType = {
    id?: true
    name?: true
    default?: true
  }

  export type AmenitiesCountAggregateInputType = {
    id?: true
    name?: true
    default?: true
    _all?: true
  }

  export type AmenitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenities to aggregate.
     */
    where?: AmenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AmenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Amenities
    **/
    _count?: true | AmenitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AmenitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AmenitiesMaxAggregateInputType
  }

  export type GetAmenitiesAggregateType<T extends AmenitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateAmenities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAmenities[P]>
      : GetScalarType<T[P], AggregateAmenities[P]>
  }




  export type AmenitiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AmenitiesWhereInput
    orderBy?: AmenitiesOrderByWithAggregationInput | AmenitiesOrderByWithAggregationInput[]
    by: AmenitiesScalarFieldEnum[] | AmenitiesScalarFieldEnum
    having?: AmenitiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AmenitiesCountAggregateInputType | true
    _min?: AmenitiesMinAggregateInputType
    _max?: AmenitiesMaxAggregateInputType
  }

  export type AmenitiesGroupByOutputType = {
    id: string
    name: string
    default: boolean
    _count: AmenitiesCountAggregateOutputType | null
    _min: AmenitiesMinAggregateOutputType | null
    _max: AmenitiesMaxAggregateOutputType | null
  }

  type GetAmenitiesGroupByPayload<T extends AmenitiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AmenitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AmenitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AmenitiesGroupByOutputType[P]>
            : GetScalarType<T[P], AmenitiesGroupByOutputType[P]>
        }
      >
    >


  export type AmenitiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    default?: boolean
    Venue?: boolean | Amenities$VenueArgs<ExtArgs>
    _count?: boolean | AmenitiesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["amenities"]>

  export type AmenitiesSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    default?: boolean
  }, ExtArgs["result"]["amenities"]>

  export type AmenitiesSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    default?: boolean
  }, ExtArgs["result"]["amenities"]>

  export type AmenitiesSelectScalar = {
    id?: boolean
    name?: boolean
    default?: boolean
  }

  export type AmenitiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "default", ExtArgs["result"]["amenities"]>
  export type AmenitiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Venue?: boolean | Amenities$VenueArgs<ExtArgs>
    _count?: boolean | AmenitiesCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AmenitiesIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AmenitiesIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AmenitiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Amenities"
    objects: {
      Venue: Prisma.$VenuePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      default: boolean
    }, ExtArgs["result"]["amenities"]>
    composites: {}
  }

  type AmenitiesGetPayload<S extends boolean | null | undefined | AmenitiesDefaultArgs> = $Result.GetResult<Prisma.$AmenitiesPayload, S>

  type AmenitiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AmenitiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AmenitiesCountAggregateInputType | true
    }

  export interface AmenitiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Amenities'], meta: { name: 'Amenities' } }
    /**
     * Find zero or one Amenities that matches the filter.
     * @param {AmenitiesFindUniqueArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AmenitiesFindUniqueArgs>(args: SelectSubset<T, AmenitiesFindUniqueArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Amenities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AmenitiesFindUniqueOrThrowArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AmenitiesFindUniqueOrThrowArgs>(args: SelectSubset<T, AmenitiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesFindFirstArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AmenitiesFindFirstArgs>(args?: SelectSubset<T, AmenitiesFindFirstArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Amenities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesFindFirstOrThrowArgs} args - Arguments to find a Amenities
     * @example
     * // Get one Amenities
     * const amenities = await prisma.amenities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AmenitiesFindFirstOrThrowArgs>(args?: SelectSubset<T, AmenitiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Amenities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Amenities
     * const amenities = await prisma.amenities.findMany()
     * 
     * // Get first 10 Amenities
     * const amenities = await prisma.amenities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const amenitiesWithIdOnly = await prisma.amenities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AmenitiesFindManyArgs>(args?: SelectSubset<T, AmenitiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Amenities.
     * @param {AmenitiesCreateArgs} args - Arguments to create a Amenities.
     * @example
     * // Create one Amenities
     * const Amenities = await prisma.amenities.create({
     *   data: {
     *     // ... data to create a Amenities
     *   }
     * })
     * 
     */
    create<T extends AmenitiesCreateArgs>(args: SelectSubset<T, AmenitiesCreateArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Amenities.
     * @param {AmenitiesCreateManyArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenities = await prisma.amenities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AmenitiesCreateManyArgs>(args?: SelectSubset<T, AmenitiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Amenities and returns the data saved in the database.
     * @param {AmenitiesCreateManyAndReturnArgs} args - Arguments to create many Amenities.
     * @example
     * // Create many Amenities
     * const amenities = await prisma.amenities.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Amenities and only return the `id`
     * const amenitiesWithIdOnly = await prisma.amenities.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AmenitiesCreateManyAndReturnArgs>(args?: SelectSubset<T, AmenitiesCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Amenities.
     * @param {AmenitiesDeleteArgs} args - Arguments to delete one Amenities.
     * @example
     * // Delete one Amenities
     * const Amenities = await prisma.amenities.delete({
     *   where: {
     *     // ... filter to delete one Amenities
     *   }
     * })
     * 
     */
    delete<T extends AmenitiesDeleteArgs>(args: SelectSubset<T, AmenitiesDeleteArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Amenities.
     * @param {AmenitiesUpdateArgs} args - Arguments to update one Amenities.
     * @example
     * // Update one Amenities
     * const amenities = await prisma.amenities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AmenitiesUpdateArgs>(args: SelectSubset<T, AmenitiesUpdateArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Amenities.
     * @param {AmenitiesDeleteManyArgs} args - Arguments to filter Amenities to delete.
     * @example
     * // Delete a few Amenities
     * const { count } = await prisma.amenities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AmenitiesDeleteManyArgs>(args?: SelectSubset<T, AmenitiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Amenities
     * const amenities = await prisma.amenities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AmenitiesUpdateManyArgs>(args: SelectSubset<T, AmenitiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Amenities and returns the data updated in the database.
     * @param {AmenitiesUpdateManyAndReturnArgs} args - Arguments to update many Amenities.
     * @example
     * // Update many Amenities
     * const amenities = await prisma.amenities.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Amenities and only return the `id`
     * const amenitiesWithIdOnly = await prisma.amenities.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AmenitiesUpdateManyAndReturnArgs>(args: SelectSubset<T, AmenitiesUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Amenities.
     * @param {AmenitiesUpsertArgs} args - Arguments to update or create a Amenities.
     * @example
     * // Update or create a Amenities
     * const amenities = await prisma.amenities.upsert({
     *   create: {
     *     // ... data to create a Amenities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Amenities we want to update
     *   }
     * })
     */
    upsert<T extends AmenitiesUpsertArgs>(args: SelectSubset<T, AmenitiesUpsertArgs<ExtArgs>>): Prisma__AmenitiesClient<$Result.GetResult<Prisma.$AmenitiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesCountArgs} args - Arguments to filter Amenities to count.
     * @example
     * // Count the number of Amenities
     * const count = await prisma.amenities.count({
     *   where: {
     *     // ... the filter for the Amenities we want to count
     *   }
     * })
    **/
    count<T extends AmenitiesCountArgs>(
      args?: Subset<T, AmenitiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AmenitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AmenitiesAggregateArgs>(args: Subset<T, AmenitiesAggregateArgs>): Prisma.PrismaPromise<GetAmenitiesAggregateType<T>>

    /**
     * Group by Amenities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AmenitiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AmenitiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AmenitiesGroupByArgs['orderBy'] }
        : { orderBy?: AmenitiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AmenitiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAmenitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Amenities model
   */
  readonly fields: AmenitiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Amenities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AmenitiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Venue<T extends Amenities$VenueArgs<ExtArgs> = {}>(args?: Subset<T, Amenities$VenueArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Amenities model
   */
  interface AmenitiesFieldRefs {
    readonly id: FieldRef<"Amenities", 'String'>
    readonly name: FieldRef<"Amenities", 'String'>
    readonly default: FieldRef<"Amenities", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * Amenities findUnique
   */
  export type AmenitiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where: AmenitiesWhereUniqueInput
  }

  /**
   * Amenities findUniqueOrThrow
   */
  export type AmenitiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where: AmenitiesWhereUniqueInput
  }

  /**
   * Amenities findFirst
   */
  export type AmenitiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenitiesScalarFieldEnum | AmenitiesScalarFieldEnum[]
  }

  /**
   * Amenities findFirstOrThrow
   */
  export type AmenitiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Amenities.
     */
    cursor?: AmenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Amenities.
     */
    distinct?: AmenitiesScalarFieldEnum | AmenitiesScalarFieldEnum[]
  }

  /**
   * Amenities findMany
   */
  export type AmenitiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * Filter, which Amenities to fetch.
     */
    where?: AmenitiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Amenities to fetch.
     */
    orderBy?: AmenitiesOrderByWithRelationInput | AmenitiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Amenities.
     */
    cursor?: AmenitiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Amenities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Amenities.
     */
    skip?: number
    distinct?: AmenitiesScalarFieldEnum | AmenitiesScalarFieldEnum[]
  }

  /**
   * Amenities create
   */
  export type AmenitiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * The data needed to create a Amenities.
     */
    data: XOR<AmenitiesCreateInput, AmenitiesUncheckedCreateInput>
  }

  /**
   * Amenities createMany
   */
  export type AmenitiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Amenities.
     */
    data: AmenitiesCreateManyInput | AmenitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Amenities createManyAndReturn
   */
  export type AmenitiesCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * The data used to create many Amenities.
     */
    data: AmenitiesCreateManyInput | AmenitiesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Amenities update
   */
  export type AmenitiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * The data needed to update a Amenities.
     */
    data: XOR<AmenitiesUpdateInput, AmenitiesUncheckedUpdateInput>
    /**
     * Choose, which Amenities to update.
     */
    where: AmenitiesWhereUniqueInput
  }

  /**
   * Amenities updateMany
   */
  export type AmenitiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenitiesUpdateManyMutationInput, AmenitiesUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenitiesWhereInput
    /**
     * Limit how many Amenities to update.
     */
    limit?: number
  }

  /**
   * Amenities updateManyAndReturn
   */
  export type AmenitiesUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * The data used to update Amenities.
     */
    data: XOR<AmenitiesUpdateManyMutationInput, AmenitiesUncheckedUpdateManyInput>
    /**
     * Filter which Amenities to update
     */
    where?: AmenitiesWhereInput
    /**
     * Limit how many Amenities to update.
     */
    limit?: number
  }

  /**
   * Amenities upsert
   */
  export type AmenitiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * The filter to search for the Amenities to update in case it exists.
     */
    where: AmenitiesWhereUniqueInput
    /**
     * In case the Amenities found by the `where` argument doesn't exist, create a new Amenities with this data.
     */
    create: XOR<AmenitiesCreateInput, AmenitiesUncheckedCreateInput>
    /**
     * In case the Amenities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AmenitiesUpdateInput, AmenitiesUncheckedUpdateInput>
  }

  /**
   * Amenities delete
   */
  export type AmenitiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
    /**
     * Filter which Amenities to delete.
     */
    where: AmenitiesWhereUniqueInput
  }

  /**
   * Amenities deleteMany
   */
  export type AmenitiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Amenities to delete
     */
    where?: AmenitiesWhereInput
    /**
     * Limit how many Amenities to delete.
     */
    limit?: number
  }

  /**
   * Amenities.Venue
   */
  export type Amenities$VenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    where?: VenueWhereInput
    orderBy?: VenueOrderByWithRelationInput | VenueOrderByWithRelationInput[]
    cursor?: VenueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VenueScalarFieldEnum | VenueScalarFieldEnum[]
  }

  /**
   * Amenities without action
   */
  export type AmenitiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Amenities
     */
    select?: AmenitiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Amenities
     */
    omit?: AmenitiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AmenitiesInclude<ExtArgs> | null
  }


  /**
   * Model FileInstance
   */

  export type AggregateFileInstance = {
    _count: FileInstanceCountAggregateOutputType | null
    _min: FileInstanceMinAggregateOutputType | null
    _max: FileInstanceMaxAggregateOutputType | null
  }

  export type FileInstanceMinAggregateOutputType = {
    id: string | null
    name: string | null
    fileId: string | null
    path: string | null
    createdAt: Date | null
    expiresAt: Date | null
    bucket: string | null
    type: $Enums.FileType | null
    venueId: string | null
    eventPreferenceId: string | null
    profileId: string | null
    directMessageId: string | null
  }

  export type FileInstanceMaxAggregateOutputType = {
    id: string | null
    name: string | null
    fileId: string | null
    path: string | null
    createdAt: Date | null
    expiresAt: Date | null
    bucket: string | null
    type: $Enums.FileType | null
    venueId: string | null
    eventPreferenceId: string | null
    profileId: string | null
    directMessageId: string | null
  }

  export type FileInstanceCountAggregateOutputType = {
    id: number
    name: number
    fileId: number
    path: number
    createdAt: number
    expiresAt: number
    bucket: number
    type: number
    venueId: number
    eventPreferenceId: number
    profileId: number
    directMessageId: number
    _all: number
  }


  export type FileInstanceMinAggregateInputType = {
    id?: true
    name?: true
    fileId?: true
    path?: true
    createdAt?: true
    expiresAt?: true
    bucket?: true
    type?: true
    venueId?: true
    eventPreferenceId?: true
    profileId?: true
    directMessageId?: true
  }

  export type FileInstanceMaxAggregateInputType = {
    id?: true
    name?: true
    fileId?: true
    path?: true
    createdAt?: true
    expiresAt?: true
    bucket?: true
    type?: true
    venueId?: true
    eventPreferenceId?: true
    profileId?: true
    directMessageId?: true
  }

  export type FileInstanceCountAggregateInputType = {
    id?: true
    name?: true
    fileId?: true
    path?: true
    createdAt?: true
    expiresAt?: true
    bucket?: true
    type?: true
    venueId?: true
    eventPreferenceId?: true
    profileId?: true
    directMessageId?: true
    _all?: true
  }

  export type FileInstanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileInstance to aggregate.
     */
    where?: FileInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileInstances to fetch.
     */
    orderBy?: FileInstanceOrderByWithRelationInput | FileInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileInstances
    **/
    _count?: true | FileInstanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileInstanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileInstanceMaxAggregateInputType
  }

  export type GetFileInstanceAggregateType<T extends FileInstanceAggregateArgs> = {
        [P in keyof T & keyof AggregateFileInstance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileInstance[P]>
      : GetScalarType<T[P], AggregateFileInstance[P]>
  }




  export type FileInstanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileInstanceWhereInput
    orderBy?: FileInstanceOrderByWithAggregationInput | FileInstanceOrderByWithAggregationInput[]
    by: FileInstanceScalarFieldEnum[] | FileInstanceScalarFieldEnum
    having?: FileInstanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileInstanceCountAggregateInputType | true
    _min?: FileInstanceMinAggregateInputType
    _max?: FileInstanceMaxAggregateInputType
  }

  export type FileInstanceGroupByOutputType = {
    id: string
    name: string
    fileId: string
    path: string
    createdAt: Date
    expiresAt: Date
    bucket: string
    type: $Enums.FileType
    venueId: string | null
    eventPreferenceId: string | null
    profileId: string | null
    directMessageId: string | null
    _count: FileInstanceCountAggregateOutputType | null
    _min: FileInstanceMinAggregateOutputType | null
    _max: FileInstanceMaxAggregateOutputType | null
  }

  type GetFileInstanceGroupByPayload<T extends FileInstanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileInstanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileInstanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileInstanceGroupByOutputType[P]>
            : GetScalarType<T[P], FileInstanceGroupByOutputType[P]>
        }
      >
    >


  export type FileInstanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fileId?: boolean
    path?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    bucket?: boolean
    type?: boolean
    venueId?: boolean
    eventPreferenceId?: boolean
    profileId?: boolean
    directMessageId?: boolean
    Venue?: boolean | FileInstance$VenueArgs<ExtArgs>
    imageOfProfile?: boolean | FileInstance$imageOfProfileArgs<ExtArgs>
    coverPhotoOfProfile?: boolean | FileInstance$coverPhotoOfProfileArgs<ExtArgs>
    EventPreference?: boolean | FileInstance$EventPreferenceArgs<ExtArgs>
    Profile?: boolean | FileInstance$ProfileArgs<ExtArgs>
    DirectMessage?: boolean | FileInstance$DirectMessageArgs<ExtArgs>
  }, ExtArgs["result"]["fileInstance"]>

  export type FileInstanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fileId?: boolean
    path?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    bucket?: boolean
    type?: boolean
    venueId?: boolean
    eventPreferenceId?: boolean
    profileId?: boolean
    directMessageId?: boolean
    Venue?: boolean | FileInstance$VenueArgs<ExtArgs>
    EventPreference?: boolean | FileInstance$EventPreferenceArgs<ExtArgs>
    Profile?: boolean | FileInstance$ProfileArgs<ExtArgs>
    DirectMessage?: boolean | FileInstance$DirectMessageArgs<ExtArgs>
  }, ExtArgs["result"]["fileInstance"]>

  export type FileInstanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    fileId?: boolean
    path?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    bucket?: boolean
    type?: boolean
    venueId?: boolean
    eventPreferenceId?: boolean
    profileId?: boolean
    directMessageId?: boolean
    Venue?: boolean | FileInstance$VenueArgs<ExtArgs>
    EventPreference?: boolean | FileInstance$EventPreferenceArgs<ExtArgs>
    Profile?: boolean | FileInstance$ProfileArgs<ExtArgs>
    DirectMessage?: boolean | FileInstance$DirectMessageArgs<ExtArgs>
  }, ExtArgs["result"]["fileInstance"]>

  export type FileInstanceSelectScalar = {
    id?: boolean
    name?: boolean
    fileId?: boolean
    path?: boolean
    createdAt?: boolean
    expiresAt?: boolean
    bucket?: boolean
    type?: boolean
    venueId?: boolean
    eventPreferenceId?: boolean
    profileId?: boolean
    directMessageId?: boolean
  }

  export type FileInstanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "fileId" | "path" | "createdAt" | "expiresAt" | "bucket" | "type" | "venueId" | "eventPreferenceId" | "profileId" | "directMessageId", ExtArgs["result"]["fileInstance"]>
  export type FileInstanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Venue?: boolean | FileInstance$VenueArgs<ExtArgs>
    imageOfProfile?: boolean | FileInstance$imageOfProfileArgs<ExtArgs>
    coverPhotoOfProfile?: boolean | FileInstance$coverPhotoOfProfileArgs<ExtArgs>
    EventPreference?: boolean | FileInstance$EventPreferenceArgs<ExtArgs>
    Profile?: boolean | FileInstance$ProfileArgs<ExtArgs>
    DirectMessage?: boolean | FileInstance$DirectMessageArgs<ExtArgs>
  }
  export type FileInstanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Venue?: boolean | FileInstance$VenueArgs<ExtArgs>
    EventPreference?: boolean | FileInstance$EventPreferenceArgs<ExtArgs>
    Profile?: boolean | FileInstance$ProfileArgs<ExtArgs>
    DirectMessage?: boolean | FileInstance$DirectMessageArgs<ExtArgs>
  }
  export type FileInstanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Venue?: boolean | FileInstance$VenueArgs<ExtArgs>
    EventPreference?: boolean | FileInstance$EventPreferenceArgs<ExtArgs>
    Profile?: boolean | FileInstance$ProfileArgs<ExtArgs>
    DirectMessage?: boolean | FileInstance$DirectMessageArgs<ExtArgs>
  }

  export type $FileInstancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileInstance"
    objects: {
      Venue: Prisma.$VenuePayload<ExtArgs> | null
      imageOfProfile: Prisma.$ProfilePayload<ExtArgs> | null
      coverPhotoOfProfile: Prisma.$ProfilePayload<ExtArgs> | null
      EventPreference: Prisma.$EventTypePayload<ExtArgs> | null
      Profile: Prisma.$ProfilePayload<ExtArgs> | null
      DirectMessage: Prisma.$DirectMessagePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      fileId: string
      path: string
      createdAt: Date
      expiresAt: Date
      bucket: string
      type: $Enums.FileType
      venueId: string | null
      eventPreferenceId: string | null
      profileId: string | null
      directMessageId: string | null
    }, ExtArgs["result"]["fileInstance"]>
    composites: {}
  }

  type FileInstanceGetPayload<S extends boolean | null | undefined | FileInstanceDefaultArgs> = $Result.GetResult<Prisma.$FileInstancePayload, S>

  type FileInstanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileInstanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileInstanceCountAggregateInputType | true
    }

  export interface FileInstanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileInstance'], meta: { name: 'FileInstance' } }
    /**
     * Find zero or one FileInstance that matches the filter.
     * @param {FileInstanceFindUniqueArgs} args - Arguments to find a FileInstance
     * @example
     * // Get one FileInstance
     * const fileInstance = await prisma.fileInstance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileInstanceFindUniqueArgs>(args: SelectSubset<T, FileInstanceFindUniqueArgs<ExtArgs>>): Prisma__FileInstanceClient<$Result.GetResult<Prisma.$FileInstancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FileInstance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileInstanceFindUniqueOrThrowArgs} args - Arguments to find a FileInstance
     * @example
     * // Get one FileInstance
     * const fileInstance = await prisma.fileInstance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileInstanceFindUniqueOrThrowArgs>(args: SelectSubset<T, FileInstanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileInstanceClient<$Result.GetResult<Prisma.$FileInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileInstance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileInstanceFindFirstArgs} args - Arguments to find a FileInstance
     * @example
     * // Get one FileInstance
     * const fileInstance = await prisma.fileInstance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileInstanceFindFirstArgs>(args?: SelectSubset<T, FileInstanceFindFirstArgs<ExtArgs>>): Prisma__FileInstanceClient<$Result.GetResult<Prisma.$FileInstancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileInstance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileInstanceFindFirstOrThrowArgs} args - Arguments to find a FileInstance
     * @example
     * // Get one FileInstance
     * const fileInstance = await prisma.fileInstance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileInstanceFindFirstOrThrowArgs>(args?: SelectSubset<T, FileInstanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileInstanceClient<$Result.GetResult<Prisma.$FileInstancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileInstances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileInstanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileInstances
     * const fileInstances = await prisma.fileInstance.findMany()
     * 
     * // Get first 10 FileInstances
     * const fileInstances = await prisma.fileInstance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileInstanceWithIdOnly = await prisma.fileInstance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileInstanceFindManyArgs>(args?: SelectSubset<T, FileInstanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileInstancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FileInstance.
     * @param {FileInstanceCreateArgs} args - Arguments to create a FileInstance.
     * @example
     * // Create one FileInstance
     * const FileInstance = await prisma.fileInstance.create({
     *   data: {
     *     // ... data to create a FileInstance
     *   }
     * })
     * 
     */
    create<T extends FileInstanceCreateArgs>(args: SelectSubset<T, FileInstanceCreateArgs<ExtArgs>>): Prisma__FileInstanceClient<$Result.GetResult<Prisma.$FileInstancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FileInstances.
     * @param {FileInstanceCreateManyArgs} args - Arguments to create many FileInstances.
     * @example
     * // Create many FileInstances
     * const fileInstance = await prisma.fileInstance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileInstanceCreateManyArgs>(args?: SelectSubset<T, FileInstanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileInstances and returns the data saved in the database.
     * @param {FileInstanceCreateManyAndReturnArgs} args - Arguments to create many FileInstances.
     * @example
     * // Create many FileInstances
     * const fileInstance = await prisma.fileInstance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileInstances and only return the `id`
     * const fileInstanceWithIdOnly = await prisma.fileInstance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileInstanceCreateManyAndReturnArgs>(args?: SelectSubset<T, FileInstanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileInstancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FileInstance.
     * @param {FileInstanceDeleteArgs} args - Arguments to delete one FileInstance.
     * @example
     * // Delete one FileInstance
     * const FileInstance = await prisma.fileInstance.delete({
     *   where: {
     *     // ... filter to delete one FileInstance
     *   }
     * })
     * 
     */
    delete<T extends FileInstanceDeleteArgs>(args: SelectSubset<T, FileInstanceDeleteArgs<ExtArgs>>): Prisma__FileInstanceClient<$Result.GetResult<Prisma.$FileInstancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FileInstance.
     * @param {FileInstanceUpdateArgs} args - Arguments to update one FileInstance.
     * @example
     * // Update one FileInstance
     * const fileInstance = await prisma.fileInstance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileInstanceUpdateArgs>(args: SelectSubset<T, FileInstanceUpdateArgs<ExtArgs>>): Prisma__FileInstanceClient<$Result.GetResult<Prisma.$FileInstancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FileInstances.
     * @param {FileInstanceDeleteManyArgs} args - Arguments to filter FileInstances to delete.
     * @example
     * // Delete a few FileInstances
     * const { count } = await prisma.fileInstance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileInstanceDeleteManyArgs>(args?: SelectSubset<T, FileInstanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileInstanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileInstances
     * const fileInstance = await prisma.fileInstance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileInstanceUpdateManyArgs>(args: SelectSubset<T, FileInstanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileInstances and returns the data updated in the database.
     * @param {FileInstanceUpdateManyAndReturnArgs} args - Arguments to update many FileInstances.
     * @example
     * // Update many FileInstances
     * const fileInstance = await prisma.fileInstance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FileInstances and only return the `id`
     * const fileInstanceWithIdOnly = await prisma.fileInstance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileInstanceUpdateManyAndReturnArgs>(args: SelectSubset<T, FileInstanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileInstancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FileInstance.
     * @param {FileInstanceUpsertArgs} args - Arguments to update or create a FileInstance.
     * @example
     * // Update or create a FileInstance
     * const fileInstance = await prisma.fileInstance.upsert({
     *   create: {
     *     // ... data to create a FileInstance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileInstance we want to update
     *   }
     * })
     */
    upsert<T extends FileInstanceUpsertArgs>(args: SelectSubset<T, FileInstanceUpsertArgs<ExtArgs>>): Prisma__FileInstanceClient<$Result.GetResult<Prisma.$FileInstancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FileInstances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileInstanceCountArgs} args - Arguments to filter FileInstances to count.
     * @example
     * // Count the number of FileInstances
     * const count = await prisma.fileInstance.count({
     *   where: {
     *     // ... the filter for the FileInstances we want to count
     *   }
     * })
    **/
    count<T extends FileInstanceCountArgs>(
      args?: Subset<T, FileInstanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileInstanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileInstanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileInstanceAggregateArgs>(args: Subset<T, FileInstanceAggregateArgs>): Prisma.PrismaPromise<GetFileInstanceAggregateType<T>>

    /**
     * Group by FileInstance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileInstanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileInstanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileInstanceGroupByArgs['orderBy'] }
        : { orderBy?: FileInstanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileInstanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileInstanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileInstance model
   */
  readonly fields: FileInstanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileInstance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileInstanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Venue<T extends FileInstance$VenueArgs<ExtArgs> = {}>(args?: Subset<T, FileInstance$VenueArgs<ExtArgs>>): Prisma__VenueClient<$Result.GetResult<Prisma.$VenuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    imageOfProfile<T extends FileInstance$imageOfProfileArgs<ExtArgs> = {}>(args?: Subset<T, FileInstance$imageOfProfileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    coverPhotoOfProfile<T extends FileInstance$coverPhotoOfProfileArgs<ExtArgs> = {}>(args?: Subset<T, FileInstance$coverPhotoOfProfileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    EventPreference<T extends FileInstance$EventPreferenceArgs<ExtArgs> = {}>(args?: Subset<T, FileInstance$EventPreferenceArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    Profile<T extends FileInstance$ProfileArgs<ExtArgs> = {}>(args?: Subset<T, FileInstance$ProfileArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    DirectMessage<T extends FileInstance$DirectMessageArgs<ExtArgs> = {}>(args?: Subset<T, FileInstance$DirectMessageArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileInstance model
   */
  interface FileInstanceFieldRefs {
    readonly id: FieldRef<"FileInstance", 'String'>
    readonly name: FieldRef<"FileInstance", 'String'>
    readonly fileId: FieldRef<"FileInstance", 'String'>
    readonly path: FieldRef<"FileInstance", 'String'>
    readonly createdAt: FieldRef<"FileInstance", 'DateTime'>
    readonly expiresAt: FieldRef<"FileInstance", 'DateTime'>
    readonly bucket: FieldRef<"FileInstance", 'String'>
    readonly type: FieldRef<"FileInstance", 'FileType'>
    readonly venueId: FieldRef<"FileInstance", 'String'>
    readonly eventPreferenceId: FieldRef<"FileInstance", 'String'>
    readonly profileId: FieldRef<"FileInstance", 'String'>
    readonly directMessageId: FieldRef<"FileInstance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * FileInstance findUnique
   */
  export type FileInstanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileInstance
     */
    select?: FileInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileInstance
     */
    omit?: FileInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInstanceInclude<ExtArgs> | null
    /**
     * Filter, which FileInstance to fetch.
     */
    where: FileInstanceWhereUniqueInput
  }

  /**
   * FileInstance findUniqueOrThrow
   */
  export type FileInstanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileInstance
     */
    select?: FileInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileInstance
     */
    omit?: FileInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInstanceInclude<ExtArgs> | null
    /**
     * Filter, which FileInstance to fetch.
     */
    where: FileInstanceWhereUniqueInput
  }

  /**
   * FileInstance findFirst
   */
  export type FileInstanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileInstance
     */
    select?: FileInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileInstance
     */
    omit?: FileInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInstanceInclude<ExtArgs> | null
    /**
     * Filter, which FileInstance to fetch.
     */
    where?: FileInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileInstances to fetch.
     */
    orderBy?: FileInstanceOrderByWithRelationInput | FileInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileInstances.
     */
    cursor?: FileInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileInstances.
     */
    distinct?: FileInstanceScalarFieldEnum | FileInstanceScalarFieldEnum[]
  }

  /**
   * FileInstance findFirstOrThrow
   */
  export type FileInstanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileInstance
     */
    select?: FileInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileInstance
     */
    omit?: FileInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInstanceInclude<ExtArgs> | null
    /**
     * Filter, which FileInstance to fetch.
     */
    where?: FileInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileInstances to fetch.
     */
    orderBy?: FileInstanceOrderByWithRelationInput | FileInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileInstances.
     */
    cursor?: FileInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileInstances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileInstances.
     */
    distinct?: FileInstanceScalarFieldEnum | FileInstanceScalarFieldEnum[]
  }

  /**
   * FileInstance findMany
   */
  export type FileInstanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileInstance
     */
    select?: FileInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileInstance
     */
    omit?: FileInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInstanceInclude<ExtArgs> | null
    /**
     * Filter, which FileInstances to fetch.
     */
    where?: FileInstanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileInstances to fetch.
     */
    orderBy?: FileInstanceOrderByWithRelationInput | FileInstanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileInstances.
     */
    cursor?: FileInstanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` FileInstances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileInstances.
     */
    skip?: number
    distinct?: FileInstanceScalarFieldEnum | FileInstanceScalarFieldEnum[]
  }

  /**
   * FileInstance create
   */
  export type FileInstanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileInstance
     */
    select?: FileInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileInstance
     */
    omit?: FileInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInstanceInclude<ExtArgs> | null
    /**
     * The data needed to create a FileInstance.
     */
    data: XOR<FileInstanceCreateInput, FileInstanceUncheckedCreateInput>
  }

  /**
   * FileInstance createMany
   */
  export type FileInstanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileInstances.
     */
    data: FileInstanceCreateManyInput | FileInstanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileInstance createManyAndReturn
   */
  export type FileInstanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileInstance
     */
    select?: FileInstanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileInstance
     */
    omit?: FileInstanceOmit<ExtArgs> | null
    /**
     * The data used to create many FileInstances.
     */
    data: FileInstanceCreateManyInput | FileInstanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInstanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileInstance update
   */
  export type FileInstanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileInstance
     */
    select?: FileInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileInstance
     */
    omit?: FileInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInstanceInclude<ExtArgs> | null
    /**
     * The data needed to update a FileInstance.
     */
    data: XOR<FileInstanceUpdateInput, FileInstanceUncheckedUpdateInput>
    /**
     * Choose, which FileInstance to update.
     */
    where: FileInstanceWhereUniqueInput
  }

  /**
   * FileInstance updateMany
   */
  export type FileInstanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileInstances.
     */
    data: XOR<FileInstanceUpdateManyMutationInput, FileInstanceUncheckedUpdateManyInput>
    /**
     * Filter which FileInstances to update
     */
    where?: FileInstanceWhereInput
    /**
     * Limit how many FileInstances to update.
     */
    limit?: number
  }

  /**
   * FileInstance updateManyAndReturn
   */
  export type FileInstanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileInstance
     */
    select?: FileInstanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileInstance
     */
    omit?: FileInstanceOmit<ExtArgs> | null
    /**
     * The data used to update FileInstances.
     */
    data: XOR<FileInstanceUpdateManyMutationInput, FileInstanceUncheckedUpdateManyInput>
    /**
     * Filter which FileInstances to update
     */
    where?: FileInstanceWhereInput
    /**
     * Limit how many FileInstances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInstanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * FileInstance upsert
   */
  export type FileInstanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileInstance
     */
    select?: FileInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileInstance
     */
    omit?: FileInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInstanceInclude<ExtArgs> | null
    /**
     * The filter to search for the FileInstance to update in case it exists.
     */
    where: FileInstanceWhereUniqueInput
    /**
     * In case the FileInstance found by the `where` argument doesn't exist, create a new FileInstance with this data.
     */
    create: XOR<FileInstanceCreateInput, FileInstanceUncheckedCreateInput>
    /**
     * In case the FileInstance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileInstanceUpdateInput, FileInstanceUncheckedUpdateInput>
  }

  /**
   * FileInstance delete
   */
  export type FileInstanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileInstance
     */
    select?: FileInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileInstance
     */
    omit?: FileInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInstanceInclude<ExtArgs> | null
    /**
     * Filter which FileInstance to delete.
     */
    where: FileInstanceWhereUniqueInput
  }

  /**
   * FileInstance deleteMany
   */
  export type FileInstanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileInstances to delete
     */
    where?: FileInstanceWhereInput
    /**
     * Limit how many FileInstances to delete.
     */
    limit?: number
  }

  /**
   * FileInstance.Venue
   */
  export type FileInstance$VenueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Venue
     */
    select?: VenueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Venue
     */
    omit?: VenueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VenueInclude<ExtArgs> | null
    where?: VenueWhereInput
  }

  /**
   * FileInstance.imageOfProfile
   */
  export type FileInstance$imageOfProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * FileInstance.coverPhotoOfProfile
   */
  export type FileInstance$coverPhotoOfProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * FileInstance.EventPreference
   */
  export type FileInstance$EventPreferenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EventType
     */
    omit?: EventTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    where?: EventTypeWhereInput
  }

  /**
   * FileInstance.Profile
   */
  export type FileInstance$ProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Profile
     */
    select?: ProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Profile
     */
    omit?: ProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProfileInclude<ExtArgs> | null
    where?: ProfileWhereInput
  }

  /**
   * FileInstance.DirectMessage
   */
  export type FileInstance$DirectMessageArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    where?: DirectMessageWhereInput
  }

  /**
   * FileInstance without action
   */
  export type FileInstanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileInstance
     */
    select?: FileInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileInstance
     */
    omit?: FileInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInstanceInclude<ExtArgs> | null
  }


  /**
   * Model Conversation
   */

  export type AggregateConversation = {
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  export type ConversationMinAggregateOutputType = {
    id: string | null
    memberOneId: string | null
    memberTwoId: string | null
  }

  export type ConversationMaxAggregateOutputType = {
    id: string | null
    memberOneId: string | null
    memberTwoId: string | null
  }

  export type ConversationCountAggregateOutputType = {
    id: number
    memberOneId: number
    memberTwoId: number
    _all: number
  }


  export type ConversationMinAggregateInputType = {
    id?: true
    memberOneId?: true
    memberTwoId?: true
  }

  export type ConversationMaxAggregateInputType = {
    id?: true
    memberOneId?: true
    memberTwoId?: true
  }

  export type ConversationCountAggregateInputType = {
    id?: true
    memberOneId?: true
    memberTwoId?: true
    _all?: true
  }

  export type ConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversation to aggregate.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Conversations
    **/
    _count?: true | ConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConversationMaxAggregateInputType
  }

  export type GetConversationAggregateType<T extends ConversationAggregateArgs> = {
        [P in keyof T & keyof AggregateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConversation[P]>
      : GetScalarType<T[P], AggregateConversation[P]>
  }




  export type ConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConversationWhereInput
    orderBy?: ConversationOrderByWithAggregationInput | ConversationOrderByWithAggregationInput[]
    by: ConversationScalarFieldEnum[] | ConversationScalarFieldEnum
    having?: ConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConversationCountAggregateInputType | true
    _min?: ConversationMinAggregateInputType
    _max?: ConversationMaxAggregateInputType
  }

  export type ConversationGroupByOutputType = {
    id: string
    memberOneId: string
    memberTwoId: string
    _count: ConversationCountAggregateOutputType | null
    _min: ConversationMinAggregateOutputType | null
    _max: ConversationMaxAggregateOutputType | null
  }

  type GetConversationGroupByPayload<T extends ConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConversationGroupByOutputType[P]>
            : GetScalarType<T[P], ConversationGroupByOutputType[P]>
        }
      >
    >


  export type ConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberOneId?: boolean
    memberTwoId?: boolean
    memberOne?: boolean | ProfileDefaultArgs<ExtArgs>
    memberTwo?: boolean | ProfileDefaultArgs<ExtArgs>
    directMessages?: boolean | Conversation$directMessagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberOneId?: boolean
    memberTwoId?: boolean
    memberOne?: boolean | ProfileDefaultArgs<ExtArgs>
    memberTwo?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    memberOneId?: boolean
    memberTwoId?: boolean
    memberOne?: boolean | ProfileDefaultArgs<ExtArgs>
    memberTwo?: boolean | ProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["conversation"]>

  export type ConversationSelectScalar = {
    id?: boolean
    memberOneId?: boolean
    memberTwoId?: boolean
  }

  export type ConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "memberOneId" | "memberTwoId", ExtArgs["result"]["conversation"]>
  export type ConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberOne?: boolean | ProfileDefaultArgs<ExtArgs>
    memberTwo?: boolean | ProfileDefaultArgs<ExtArgs>
    directMessages?: boolean | Conversation$directMessagesArgs<ExtArgs>
    _count?: boolean | ConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberOne?: boolean | ProfileDefaultArgs<ExtArgs>
    memberTwo?: boolean | ProfileDefaultArgs<ExtArgs>
  }
  export type ConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    memberOne?: boolean | ProfileDefaultArgs<ExtArgs>
    memberTwo?: boolean | ProfileDefaultArgs<ExtArgs>
  }

  export type $ConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Conversation"
    objects: {
      memberOne: Prisma.$ProfilePayload<ExtArgs>
      memberTwo: Prisma.$ProfilePayload<ExtArgs>
      directMessages: Prisma.$DirectMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      memberOneId: string
      memberTwoId: string
    }, ExtArgs["result"]["conversation"]>
    composites: {}
  }

  type ConversationGetPayload<S extends boolean | null | undefined | ConversationDefaultArgs> = $Result.GetResult<Prisma.$ConversationPayload, S>

  type ConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ConversationCountAggregateInputType | true
    }

  export interface ConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Conversation'], meta: { name: 'Conversation' } }
    /**
     * Find zero or one Conversation that matches the filter.
     * @param {ConversationFindUniqueArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConversationFindUniqueArgs>(args: SelectSubset<T, ConversationFindUniqueArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Conversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ConversationFindUniqueOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, ConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConversationFindFirstArgs>(args?: SelectSubset<T, ConversationFindFirstArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Conversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindFirstOrThrowArgs} args - Arguments to find a Conversation
     * @example
     * // Get one Conversation
     * const conversation = await prisma.conversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, ConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Conversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Conversations
     * const conversations = await prisma.conversation.findMany()
     * 
     * // Get first 10 Conversations
     * const conversations = await prisma.conversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const conversationWithIdOnly = await prisma.conversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConversationFindManyArgs>(args?: SelectSubset<T, ConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Conversation.
     * @param {ConversationCreateArgs} args - Arguments to create a Conversation.
     * @example
     * // Create one Conversation
     * const Conversation = await prisma.conversation.create({
     *   data: {
     *     // ... data to create a Conversation
     *   }
     * })
     * 
     */
    create<T extends ConversationCreateArgs>(args: SelectSubset<T, ConversationCreateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Conversations.
     * @param {ConversationCreateManyArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConversationCreateManyArgs>(args?: SelectSubset<T, ConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Conversations and returns the data saved in the database.
     * @param {ConversationCreateManyAndReturnArgs} args - Arguments to create many Conversations.
     * @example
     * // Create many Conversations
     * const conversation = await prisma.conversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, ConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Conversation.
     * @param {ConversationDeleteArgs} args - Arguments to delete one Conversation.
     * @example
     * // Delete one Conversation
     * const Conversation = await prisma.conversation.delete({
     *   where: {
     *     // ... filter to delete one Conversation
     *   }
     * })
     * 
     */
    delete<T extends ConversationDeleteArgs>(args: SelectSubset<T, ConversationDeleteArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Conversation.
     * @param {ConversationUpdateArgs} args - Arguments to update one Conversation.
     * @example
     * // Update one Conversation
     * const conversation = await prisma.conversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConversationUpdateArgs>(args: SelectSubset<T, ConversationUpdateArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Conversations.
     * @param {ConversationDeleteManyArgs} args - Arguments to filter Conversations to delete.
     * @example
     * // Delete a few Conversations
     * const { count } = await prisma.conversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConversationDeleteManyArgs>(args?: SelectSubset<T, ConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConversationUpdateManyArgs>(args: SelectSubset<T, ConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Conversations and returns the data updated in the database.
     * @param {ConversationUpdateManyAndReturnArgs} args - Arguments to update many Conversations.
     * @example
     * // Update many Conversations
     * const conversation = await prisma.conversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Conversations and only return the `id`
     * const conversationWithIdOnly = await prisma.conversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, ConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Conversation.
     * @param {ConversationUpsertArgs} args - Arguments to update or create a Conversation.
     * @example
     * // Update or create a Conversation
     * const conversation = await prisma.conversation.upsert({
     *   create: {
     *     // ... data to create a Conversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Conversation we want to update
     *   }
     * })
     */
    upsert<T extends ConversationUpsertArgs>(args: SelectSubset<T, ConversationUpsertArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Conversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationCountArgs} args - Arguments to filter Conversations to count.
     * @example
     * // Count the number of Conversations
     * const count = await prisma.conversation.count({
     *   where: {
     *     // ... the filter for the Conversations we want to count
     *   }
     * })
    **/
    count<T extends ConversationCountArgs>(
      args?: Subset<T, ConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConversationAggregateArgs>(args: Subset<T, ConversationAggregateArgs>): Prisma.PrismaPromise<GetConversationAggregateType<T>>

    /**
     * Group by Conversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConversationGroupByArgs['orderBy'] }
        : { orderBy?: ConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Conversation model
   */
  readonly fields: ConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Conversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    memberOne<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    memberTwo<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    directMessages<T extends Conversation$directMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Conversation$directMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Conversation model
   */
  interface ConversationFieldRefs {
    readonly id: FieldRef<"Conversation", 'String'>
    readonly memberOneId: FieldRef<"Conversation", 'String'>
    readonly memberTwoId: FieldRef<"Conversation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Conversation findUnique
   */
  export type ConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findUniqueOrThrow
   */
  export type ConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation findFirst
   */
  export type ConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findFirstOrThrow
   */
  export type ConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversation to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Conversations.
     */
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation findMany
   */
  export type ConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter, which Conversations to fetch.
     */
    where?: ConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Conversations to fetch.
     */
    orderBy?: ConversationOrderByWithRelationInput | ConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Conversations.
     */
    cursor?: ConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Conversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Conversations.
     */
    skip?: number
    distinct?: ConversationScalarFieldEnum | ConversationScalarFieldEnum[]
  }

  /**
   * Conversation create
   */
  export type ConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a Conversation.
     */
    data: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
  }

  /**
   * Conversation createMany
   */
  export type ConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Conversation createManyAndReturn
   */
  export type ConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to create many Conversations.
     */
    data: ConversationCreateManyInput | ConversationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation update
   */
  export type ConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a Conversation.
     */
    data: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
    /**
     * Choose, which Conversation to update.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation updateMany
   */
  export type ConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
  }

  /**
   * Conversation updateManyAndReturn
   */
  export type ConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * The data used to update Conversations.
     */
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyInput>
    /**
     * Filter which Conversations to update
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Conversation upsert
   */
  export type ConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the Conversation to update in case it exists.
     */
    where: ConversationWhereUniqueInput
    /**
     * In case the Conversation found by the `where` argument doesn't exist, create a new Conversation with this data.
     */
    create: XOR<ConversationCreateInput, ConversationUncheckedCreateInput>
    /**
     * In case the Conversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConversationUpdateInput, ConversationUncheckedUpdateInput>
  }

  /**
   * Conversation delete
   */
  export type ConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
    /**
     * Filter which Conversation to delete.
     */
    where: ConversationWhereUniqueInput
  }

  /**
   * Conversation deleteMany
   */
  export type ConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Conversations to delete
     */
    where?: ConversationWhereInput
    /**
     * Limit how many Conversations to delete.
     */
    limit?: number
  }

  /**
   * Conversation.directMessages
   */
  export type Conversation$directMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    where?: DirectMessageWhereInput
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    cursor?: DirectMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * Conversation without action
   */
  export type ConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Conversation
     */
    select?: ConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Conversation
     */
    omit?: ConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ConversationInclude<ExtArgs> | null
  }


  /**
   * Model DirectMessage
   */

  export type AggregateDirectMessage = {
    _count: DirectMessageCountAggregateOutputType | null
    _min: DirectMessageMinAggregateOutputType | null
    _max: DirectMessageMaxAggregateOutputType | null
  }

  export type DirectMessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    memberId: string | null
    conversationId: string | null
    deleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DirectMessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    memberId: string | null
    conversationId: string | null
    deleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DirectMessageCountAggregateOutputType = {
    id: number
    content: number
    memberId: number
    conversationId: number
    deleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DirectMessageMinAggregateInputType = {
    id?: true
    content?: true
    memberId?: true
    conversationId?: true
    deleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DirectMessageMaxAggregateInputType = {
    id?: true
    content?: true
    memberId?: true
    conversationId?: true
    deleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DirectMessageCountAggregateInputType = {
    id?: true
    content?: true
    memberId?: true
    conversationId?: true
    deleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DirectMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DirectMessage to aggregate.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DirectMessages
    **/
    _count?: true | DirectMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DirectMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DirectMessageMaxAggregateInputType
  }

  export type GetDirectMessageAggregateType<T extends DirectMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateDirectMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDirectMessage[P]>
      : GetScalarType<T[P], AggregateDirectMessage[P]>
  }




  export type DirectMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DirectMessageWhereInput
    orderBy?: DirectMessageOrderByWithAggregationInput | DirectMessageOrderByWithAggregationInput[]
    by: DirectMessageScalarFieldEnum[] | DirectMessageScalarFieldEnum
    having?: DirectMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DirectMessageCountAggregateInputType | true
    _min?: DirectMessageMinAggregateInputType
    _max?: DirectMessageMaxAggregateInputType
  }

  export type DirectMessageGroupByOutputType = {
    id: string
    content: string
    memberId: string
    conversationId: string
    deleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: DirectMessageCountAggregateOutputType | null
    _min: DirectMessageMinAggregateOutputType | null
    _max: DirectMessageMaxAggregateOutputType | null
  }

  type GetDirectMessageGroupByPayload<T extends DirectMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DirectMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DirectMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DirectMessageGroupByOutputType[P]>
            : GetScalarType<T[P], DirectMessageGroupByOutputType[P]>
        }
      >
    >


  export type DirectMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    memberId?: boolean
    conversationId?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    file?: boolean | DirectMessage$fileArgs<ExtArgs>
    member?: boolean | ProfileDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["directMessage"]>

  export type DirectMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    memberId?: boolean
    conversationId?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | ProfileDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["directMessage"]>

  export type DirectMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    memberId?: boolean
    conversationId?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    member?: boolean | ProfileDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["directMessage"]>

  export type DirectMessageSelectScalar = {
    id?: boolean
    content?: boolean
    memberId?: boolean
    conversationId?: boolean
    deleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DirectMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "memberId" | "conversationId" | "deleted" | "createdAt" | "updatedAt", ExtArgs["result"]["directMessage"]>
  export type DirectMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | DirectMessage$fileArgs<ExtArgs>
    member?: boolean | ProfileDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type DirectMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | ProfileDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }
  export type DirectMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    member?: boolean | ProfileDefaultArgs<ExtArgs>
    conversation?: boolean | ConversationDefaultArgs<ExtArgs>
  }

  export type $DirectMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DirectMessage"
    objects: {
      file: Prisma.$FileInstancePayload<ExtArgs> | null
      member: Prisma.$ProfilePayload<ExtArgs>
      conversation: Prisma.$ConversationPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      memberId: string
      conversationId: string
      deleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["directMessage"]>
    composites: {}
  }

  type DirectMessageGetPayload<S extends boolean | null | undefined | DirectMessageDefaultArgs> = $Result.GetResult<Prisma.$DirectMessagePayload, S>

  type DirectMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DirectMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DirectMessageCountAggregateInputType | true
    }

  export interface DirectMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DirectMessage'], meta: { name: 'DirectMessage' } }
    /**
     * Find zero or one DirectMessage that matches the filter.
     * @param {DirectMessageFindUniqueArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DirectMessageFindUniqueArgs>(args: SelectSubset<T, DirectMessageFindUniqueArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DirectMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DirectMessageFindUniqueOrThrowArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DirectMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, DirectMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DirectMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindFirstArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DirectMessageFindFirstArgs>(args?: SelectSubset<T, DirectMessageFindFirstArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DirectMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindFirstOrThrowArgs} args - Arguments to find a DirectMessage
     * @example
     * // Get one DirectMessage
     * const directMessage = await prisma.directMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DirectMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, DirectMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DirectMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DirectMessages
     * const directMessages = await prisma.directMessage.findMany()
     * 
     * // Get first 10 DirectMessages
     * const directMessages = await prisma.directMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const directMessageWithIdOnly = await prisma.directMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DirectMessageFindManyArgs>(args?: SelectSubset<T, DirectMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DirectMessage.
     * @param {DirectMessageCreateArgs} args - Arguments to create a DirectMessage.
     * @example
     * // Create one DirectMessage
     * const DirectMessage = await prisma.directMessage.create({
     *   data: {
     *     // ... data to create a DirectMessage
     *   }
     * })
     * 
     */
    create<T extends DirectMessageCreateArgs>(args: SelectSubset<T, DirectMessageCreateArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DirectMessages.
     * @param {DirectMessageCreateManyArgs} args - Arguments to create many DirectMessages.
     * @example
     * // Create many DirectMessages
     * const directMessage = await prisma.directMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DirectMessageCreateManyArgs>(args?: SelectSubset<T, DirectMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DirectMessages and returns the data saved in the database.
     * @param {DirectMessageCreateManyAndReturnArgs} args - Arguments to create many DirectMessages.
     * @example
     * // Create many DirectMessages
     * const directMessage = await prisma.directMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DirectMessages and only return the `id`
     * const directMessageWithIdOnly = await prisma.directMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DirectMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, DirectMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DirectMessage.
     * @param {DirectMessageDeleteArgs} args - Arguments to delete one DirectMessage.
     * @example
     * // Delete one DirectMessage
     * const DirectMessage = await prisma.directMessage.delete({
     *   where: {
     *     // ... filter to delete one DirectMessage
     *   }
     * })
     * 
     */
    delete<T extends DirectMessageDeleteArgs>(args: SelectSubset<T, DirectMessageDeleteArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DirectMessage.
     * @param {DirectMessageUpdateArgs} args - Arguments to update one DirectMessage.
     * @example
     * // Update one DirectMessage
     * const directMessage = await prisma.directMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DirectMessageUpdateArgs>(args: SelectSubset<T, DirectMessageUpdateArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DirectMessages.
     * @param {DirectMessageDeleteManyArgs} args - Arguments to filter DirectMessages to delete.
     * @example
     * // Delete a few DirectMessages
     * const { count } = await prisma.directMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DirectMessageDeleteManyArgs>(args?: SelectSubset<T, DirectMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DirectMessages
     * const directMessage = await prisma.directMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DirectMessageUpdateManyArgs>(args: SelectSubset<T, DirectMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DirectMessages and returns the data updated in the database.
     * @param {DirectMessageUpdateManyAndReturnArgs} args - Arguments to update many DirectMessages.
     * @example
     * // Update many DirectMessages
     * const directMessage = await prisma.directMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DirectMessages and only return the `id`
     * const directMessageWithIdOnly = await prisma.directMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DirectMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, DirectMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DirectMessage.
     * @param {DirectMessageUpsertArgs} args - Arguments to update or create a DirectMessage.
     * @example
     * // Update or create a DirectMessage
     * const directMessage = await prisma.directMessage.upsert({
     *   create: {
     *     // ... data to create a DirectMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DirectMessage we want to update
     *   }
     * })
     */
    upsert<T extends DirectMessageUpsertArgs>(args: SelectSubset<T, DirectMessageUpsertArgs<ExtArgs>>): Prisma__DirectMessageClient<$Result.GetResult<Prisma.$DirectMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DirectMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageCountArgs} args - Arguments to filter DirectMessages to count.
     * @example
     * // Count the number of DirectMessages
     * const count = await prisma.directMessage.count({
     *   where: {
     *     // ... the filter for the DirectMessages we want to count
     *   }
     * })
    **/
    count<T extends DirectMessageCountArgs>(
      args?: Subset<T, DirectMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DirectMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DirectMessageAggregateArgs>(args: Subset<T, DirectMessageAggregateArgs>): Prisma.PrismaPromise<GetDirectMessageAggregateType<T>>

    /**
     * Group by DirectMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DirectMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DirectMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DirectMessageGroupByArgs['orderBy'] }
        : { orderBy?: DirectMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DirectMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDirectMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DirectMessage model
   */
  readonly fields: DirectMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DirectMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DirectMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    file<T extends DirectMessage$fileArgs<ExtArgs> = {}>(args?: Subset<T, DirectMessage$fileArgs<ExtArgs>>): Prisma__FileInstanceClient<$Result.GetResult<Prisma.$FileInstancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    member<T extends ProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProfileDefaultArgs<ExtArgs>>): Prisma__ProfileClient<$Result.GetResult<Prisma.$ProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    conversation<T extends ConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ConversationDefaultArgs<ExtArgs>>): Prisma__ConversationClient<$Result.GetResult<Prisma.$ConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DirectMessage model
   */
  interface DirectMessageFieldRefs {
    readonly id: FieldRef<"DirectMessage", 'String'>
    readonly content: FieldRef<"DirectMessage", 'String'>
    readonly memberId: FieldRef<"DirectMessage", 'String'>
    readonly conversationId: FieldRef<"DirectMessage", 'String'>
    readonly deleted: FieldRef<"DirectMessage", 'Boolean'>
    readonly createdAt: FieldRef<"DirectMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"DirectMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DirectMessage findUnique
   */
  export type DirectMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage findUniqueOrThrow
   */
  export type DirectMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage findFirst
   */
  export type DirectMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectMessages.
     */
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * DirectMessage findFirstOrThrow
   */
  export type DirectMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * Filter, which DirectMessage to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DirectMessages.
     */
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * DirectMessage findMany
   */
  export type DirectMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * Filter, which DirectMessages to fetch.
     */
    where?: DirectMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DirectMessages to fetch.
     */
    orderBy?: DirectMessageOrderByWithRelationInput | DirectMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DirectMessages.
     */
    cursor?: DirectMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DirectMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DirectMessages.
     */
    skip?: number
    distinct?: DirectMessageScalarFieldEnum | DirectMessageScalarFieldEnum[]
  }

  /**
   * DirectMessage create
   */
  export type DirectMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a DirectMessage.
     */
    data: XOR<DirectMessageCreateInput, DirectMessageUncheckedCreateInput>
  }

  /**
   * DirectMessage createMany
   */
  export type DirectMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DirectMessages.
     */
    data: DirectMessageCreateManyInput | DirectMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DirectMessage createManyAndReturn
   */
  export type DirectMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * The data used to create many DirectMessages.
     */
    data: DirectMessageCreateManyInput | DirectMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DirectMessage update
   */
  export type DirectMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a DirectMessage.
     */
    data: XOR<DirectMessageUpdateInput, DirectMessageUncheckedUpdateInput>
    /**
     * Choose, which DirectMessage to update.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage updateMany
   */
  export type DirectMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DirectMessages.
     */
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyInput>
    /**
     * Filter which DirectMessages to update
     */
    where?: DirectMessageWhereInput
    /**
     * Limit how many DirectMessages to update.
     */
    limit?: number
  }

  /**
   * DirectMessage updateManyAndReturn
   */
  export type DirectMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * The data used to update DirectMessages.
     */
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyInput>
    /**
     * Filter which DirectMessages to update
     */
    where?: DirectMessageWhereInput
    /**
     * Limit how many DirectMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DirectMessage upsert
   */
  export type DirectMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the DirectMessage to update in case it exists.
     */
    where: DirectMessageWhereUniqueInput
    /**
     * In case the DirectMessage found by the `where` argument doesn't exist, create a new DirectMessage with this data.
     */
    create: XOR<DirectMessageCreateInput, DirectMessageUncheckedCreateInput>
    /**
     * In case the DirectMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DirectMessageUpdateInput, DirectMessageUncheckedUpdateInput>
  }

  /**
   * DirectMessage delete
   */
  export type DirectMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
    /**
     * Filter which DirectMessage to delete.
     */
    where: DirectMessageWhereUniqueInput
  }

  /**
   * DirectMessage deleteMany
   */
  export type DirectMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DirectMessages to delete
     */
    where?: DirectMessageWhereInput
    /**
     * Limit how many DirectMessages to delete.
     */
    limit?: number
  }

  /**
   * DirectMessage.file
   */
  export type DirectMessage$fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileInstance
     */
    select?: FileInstanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileInstance
     */
    omit?: FileInstanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInstanceInclude<ExtArgs> | null
    where?: FileInstanceWhereInput
  }

  /**
   * DirectMessage without action
   */
  export type DirectMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DirectMessage
     */
    select?: DirectMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DirectMessage
     */
    omit?: DirectMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DirectMessageInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    phone: 'phone',
    password: 'password',
    name: 'name',
    role: 'role',
    isVerified: 'isVerified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    gender: 'gender',
    imageId: 'imageId',
    location: 'location',
    coverPhotoId: 'coverPhotoId',
    profession: 'profession',
    description: 'description',
    experience: 'experience',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const EventTypeScalarFieldEnum: {
    id: 'id',
    name: 'name',
    bookingId: 'bookingId'
  };

  export type EventTypeScalarFieldEnum = (typeof EventTypeScalarFieldEnum)[keyof typeof EventTypeScalarFieldEnum]


  export const VenueScalarFieldEnum: {
    id: 'id',
    profileId: 'profileId',
    name: 'name',
    city: 'city',
    area: 'area',
    description: 'description',
    capacity: 'capacity',
    bookedDates: 'bookedDates',
    type: 'type',
    cateringDescription: 'cateringDescription',
    parkingDescription: 'parkingDescription',
    availabilityDescription: 'availabilityDescription',
    extraServiceDescription: 'extraServiceDescription',
    price: 'price',
    bookingType: 'bookingType',
    verified: 'verified',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VenueScalarFieldEnum = (typeof VenueScalarFieldEnum)[keyof typeof VenueScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    venueId: 'venueId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const ShiftScalarFieldEnum: {
    id: 'id',
    venueId: 'venueId',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    shiftName: 'shiftName',
    employeeId: 'employeeId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShiftScalarFieldEnum = (typeof ShiftScalarFieldEnum)[keyof typeof ShiftScalarFieldEnum]


  export const BookingScalarFieldEnum: {
    id: 'id',
    bookedById: 'bookedById',
    venueId: 'venueId',
    serviceProviderId: 'serviceProviderId',
    eventName: 'eventName',
    location: 'location',
    plannerName: 'plannerName',
    selectedDate: 'selectedDate',
    startTime: 'startTime',
    endTime: 'endTime',
    duration: 'duration',
    bookingType: 'bookingType',
    guestNumber: 'guestNumber',
    decoration: 'decoration',
    services: 'services',
    totalCost: 'totalCost',
    bookingStatus: 'bookingStatus',
    totalAmount: 'totalAmount',
    paid: 'paid',
    due: 'due',
    accept: 'accept',
    isEventFinished: 'isEventFinished',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BookingScalarFieldEnum = (typeof BookingScalarFieldEnum)[keyof typeof BookingScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    bookingId: 'bookingId',
    paymentStatus: 'paymentStatus',
    paymentMethod: 'paymentMethod',
    amount: 'amount',
    transactionId: 'transactionId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const DecorationScalarFieldEnum: {
    id: 'id',
    venueId: 'venueId',
    tableShapes: 'tableShapes',
    seatingStyles: 'seatingStyles',
    lighting: 'lighting',
    flowerColors: 'flowerColors',
    flowerTypes: 'flowerTypes',
    fragrances: 'fragrances'
  };

  export type DecorationScalarFieldEnum = (typeof DecorationScalarFieldEnum)[keyof typeof DecorationScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    venueId: 'venueId',
    rating: 'rating',
    comment: 'comment',
    createdAt: 'createdAt',
    profileId: 'profileId'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const AmenitiesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    default: 'default'
  };

  export type AmenitiesScalarFieldEnum = (typeof AmenitiesScalarFieldEnum)[keyof typeof AmenitiesScalarFieldEnum]


  export const FileInstanceScalarFieldEnum: {
    id: 'id',
    name: 'name',
    fileId: 'fileId',
    path: 'path',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt',
    bucket: 'bucket',
    type: 'type',
    venueId: 'venueId',
    eventPreferenceId: 'eventPreferenceId',
    profileId: 'profileId',
    directMessageId: 'directMessageId'
  };

  export type FileInstanceScalarFieldEnum = (typeof FileInstanceScalarFieldEnum)[keyof typeof FileInstanceScalarFieldEnum]


  export const ConversationScalarFieldEnum: {
    id: 'id',
    memberOneId: 'memberOneId',
    memberTwoId: 'memberTwoId'
  };

  export type ConversationScalarFieldEnum = (typeof ConversationScalarFieldEnum)[keyof typeof ConversationScalarFieldEnum]


  export const DirectMessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    memberId: 'memberId',
    conversationId: 'conversationId',
    deleted: 'deleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DirectMessageScalarFieldEnum = (typeof DirectMessageScalarFieldEnum)[keyof typeof DirectMessageScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'VenueType'
   */
  export type EnumVenueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VenueType'>
    


  /**
   * Reference to a field of type 'VenueType[]'
   */
  export type ListEnumVenueTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VenueType[]'>
    


  /**
   * Reference to a field of type 'BookingType'
   */
  export type EnumBookingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingType'>
    


  /**
   * Reference to a field of type 'BookingType[]'
   */
  export type ListEnumBookingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingType[]'>
    


  /**
   * Reference to a field of type 'BookingStatus'
   */
  export type EnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus'>
    


  /**
   * Reference to a field of type 'BookingStatus[]'
   */
  export type ListEnumBookingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BookingStatus[]'>
    


  /**
   * Reference to a field of type 'AcceptanceStatus'
   */
  export type EnumAcceptanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AcceptanceStatus'>
    


  /**
   * Reference to a field of type 'AcceptanceStatus[]'
   */
  export type ListEnumAcceptanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AcceptanceStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentStatus'
   */
  export type EnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus'>
    


  /**
   * Reference to a field of type 'PaymentStatus[]'
   */
  export type ListEnumPaymentStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'TableShape[]'
   */
  export type ListEnumTableShapeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TableShape[]'>
    


  /**
   * Reference to a field of type 'TableShape'
   */
  export type EnumTableShapeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TableShape'>
    


  /**
   * Reference to a field of type 'SeatingStyle[]'
   */
  export type ListEnumSeatingStyleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SeatingStyle[]'>
    


  /**
   * Reference to a field of type 'SeatingStyle'
   */
  export type EnumSeatingStyleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SeatingStyle'>
    


  /**
   * Reference to a field of type 'LightingStyle[]'
   */
  export type ListEnumLightingStyleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LightingStyle[]'>
    


  /**
   * Reference to a field of type 'LightingStyle'
   */
  export type EnumLightingStyleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LightingStyle'>
    


  /**
   * Reference to a field of type 'FlowerColor[]'
   */
  export type ListEnumFlowerColorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlowerColor[]'>
    


  /**
   * Reference to a field of type 'FlowerColor'
   */
  export type EnumFlowerColorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlowerColor'>
    


  /**
   * Reference to a field of type 'FlowerType[]'
   */
  export type ListEnumFlowerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlowerType[]'>
    


  /**
   * Reference to a field of type 'FlowerType'
   */
  export type EnumFlowerTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FlowerType'>
    


  /**
   * Reference to a field of type 'Fragrance[]'
   */
  export type ListEnumFragranceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Fragrance[]'>
    


  /**
   * Reference to a field of type 'Fragrance'
   */
  export type EnumFragranceFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Fragrance'>
    


  /**
   * Reference to a field of type 'FileType'
   */
  export type EnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType'>
    


  /**
   * Reference to a field of type 'FileType[]'
   */
  export type ListEnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    phone?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    profile?: ProfileOrderByWithRelationInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    isVerified?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
  }, "id" | "email" | "phone">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    phone?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    isVerified?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProfileWhereInput = {
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    id?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    gender?: EnumGenderFilter<"Profile"> | $Enums.Gender
    imageId?: StringNullableFilter<"Profile"> | string | null
    location?: StringNullableFilter<"Profile"> | string | null
    coverPhotoId?: StringNullableFilter<"Profile"> | string | null
    profession?: StringNullableFilter<"Profile"> | string | null
    description?: StringNullableFilter<"Profile"> | string | null
    experience?: IntNullableFilter<"Profile"> | number | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    image?: XOR<FileInstanceNullableScalarRelationFilter, FileInstanceWhereInput> | null
    eventPreference?: EventTypeListRelationFilter
    coverPhoto?: XOR<FileInstanceNullableScalarRelationFilter, FileInstanceWhereInput> | null
    assets?: FileInstanceListRelationFilter
    directMessages?: DirectMessageListRelationFilter
    conversationsInitiated?: ConversationListRelationFilter
    conversationsReceived?: ConversationListRelationFilter
    bookingToVenue?: BookingListRelationFilter
    bookingToServiceProvider?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    venues?: VenueListRelationFilter
  }

  export type ProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    gender?: SortOrder
    imageId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    coverPhotoId?: SortOrderInput | SortOrder
    profession?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    image?: FileInstanceOrderByWithRelationInput
    eventPreference?: EventTypeOrderByRelationAggregateInput
    coverPhoto?: FileInstanceOrderByWithRelationInput
    assets?: FileInstanceOrderByRelationAggregateInput
    directMessages?: DirectMessageOrderByRelationAggregateInput
    conversationsInitiated?: ConversationOrderByRelationAggregateInput
    conversationsReceived?: ConversationOrderByRelationAggregateInput
    bookingToVenue?: BookingOrderByRelationAggregateInput
    bookingToServiceProvider?: BookingOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    venues?: VenueOrderByRelationAggregateInput
  }

  export type ProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    imageId?: string
    coverPhotoId?: string
    AND?: ProfileWhereInput | ProfileWhereInput[]
    OR?: ProfileWhereInput[]
    NOT?: ProfileWhereInput | ProfileWhereInput[]
    gender?: EnumGenderFilter<"Profile"> | $Enums.Gender
    location?: StringNullableFilter<"Profile"> | string | null
    profession?: StringNullableFilter<"Profile"> | string | null
    description?: StringNullableFilter<"Profile"> | string | null
    experience?: IntNullableFilter<"Profile"> | number | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    image?: XOR<FileInstanceNullableScalarRelationFilter, FileInstanceWhereInput> | null
    eventPreference?: EventTypeListRelationFilter
    coverPhoto?: XOR<FileInstanceNullableScalarRelationFilter, FileInstanceWhereInput> | null
    assets?: FileInstanceListRelationFilter
    directMessages?: DirectMessageListRelationFilter
    conversationsInitiated?: ConversationListRelationFilter
    conversationsReceived?: ConversationListRelationFilter
    bookingToVenue?: BookingListRelationFilter
    bookingToServiceProvider?: BookingListRelationFilter
    reviews?: ReviewListRelationFilter
    venues?: VenueListRelationFilter
  }, "id" | "userId" | "imageId" | "coverPhotoId">

  export type ProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    gender?: SortOrder
    imageId?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    coverPhotoId?: SortOrderInput | SortOrder
    profession?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    experience?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProfileCountOrderByAggregateInput
    _avg?: ProfileAvgOrderByAggregateInput
    _max?: ProfileMaxOrderByAggregateInput
    _min?: ProfileMinOrderByAggregateInput
    _sum?: ProfileSumOrderByAggregateInput
  }

  export type ProfileScalarWhereWithAggregatesInput = {
    AND?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    OR?: ProfileScalarWhereWithAggregatesInput[]
    NOT?: ProfileScalarWhereWithAggregatesInput | ProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Profile"> | string
    userId?: StringWithAggregatesFilter<"Profile"> | string
    gender?: EnumGenderWithAggregatesFilter<"Profile"> | $Enums.Gender
    imageId?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    location?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    coverPhotoId?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    profession?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    description?: StringNullableWithAggregatesFilter<"Profile"> | string | null
    experience?: IntNullableWithAggregatesFilter<"Profile"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Profile"> | Date | string
  }

  export type EventTypeWhereInput = {
    AND?: EventTypeWhereInput | EventTypeWhereInput[]
    OR?: EventTypeWhereInput[]
    NOT?: EventTypeWhereInput | EventTypeWhereInput[]
    id?: StringFilter<"EventType"> | string
    name?: StringFilter<"EventType"> | string
    bookingId?: StringFilter<"EventType"> | string
    avatar?: XOR<FileInstanceNullableScalarRelationFilter, FileInstanceWhereInput> | null
    profile?: ProfileListRelationFilter
    Booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
  }

  export type EventTypeOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    bookingId?: SortOrder
    avatar?: FileInstanceOrderByWithRelationInput
    profile?: ProfileOrderByRelationAggregateInput
    Booking?: BookingOrderByWithRelationInput
  }

  export type EventTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    bookingId?: string
    AND?: EventTypeWhereInput | EventTypeWhereInput[]
    OR?: EventTypeWhereInput[]
    NOT?: EventTypeWhereInput | EventTypeWhereInput[]
    avatar?: XOR<FileInstanceNullableScalarRelationFilter, FileInstanceWhereInput> | null
    profile?: ProfileListRelationFilter
    Booking?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
  }, "id" | "name" | "bookingId">

  export type EventTypeOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    bookingId?: SortOrder
    _count?: EventTypeCountOrderByAggregateInput
    _max?: EventTypeMaxOrderByAggregateInput
    _min?: EventTypeMinOrderByAggregateInput
  }

  export type EventTypeScalarWhereWithAggregatesInput = {
    AND?: EventTypeScalarWhereWithAggregatesInput | EventTypeScalarWhereWithAggregatesInput[]
    OR?: EventTypeScalarWhereWithAggregatesInput[]
    NOT?: EventTypeScalarWhereWithAggregatesInput | EventTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventType"> | string
    name?: StringWithAggregatesFilter<"EventType"> | string
    bookingId?: StringWithAggregatesFilter<"EventType"> | string
  }

  export type VenueWhereInput = {
    AND?: VenueWhereInput | VenueWhereInput[]
    OR?: VenueWhereInput[]
    NOT?: VenueWhereInput | VenueWhereInput[]
    id?: StringFilter<"Venue"> | string
    profileId?: StringNullableFilter<"Venue"> | string | null
    name?: StringFilter<"Venue"> | string
    city?: StringFilter<"Venue"> | string
    area?: StringFilter<"Venue"> | string
    description?: StringNullableFilter<"Venue"> | string | null
    capacity?: IntFilter<"Venue"> | number
    bookedDates?: DateTimeNullableListFilter<"Venue">
    type?: EnumVenueTypeFilter<"Venue"> | $Enums.VenueType
    cateringDescription?: StringNullableFilter<"Venue"> | string | null
    parkingDescription?: StringNullableFilter<"Venue"> | string | null
    availabilityDescription?: StringNullableFilter<"Venue"> | string | null
    extraServiceDescription?: StringNullableFilter<"Venue"> | string | null
    price?: IntFilter<"Venue"> | number
    bookingType?: EnumBookingTypeFilter<"Venue"> | $Enums.BookingType
    verified?: BoolFilter<"Venue"> | boolean
    createdAt?: DateTimeFilter<"Venue"> | Date | string
    updatedAt?: DateTimeFilter<"Venue"> | Date | string
    Profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    amenities?: AmenitiesListRelationFilter
    arrangementsImage?: XOR<FileInstanceNullableScalarRelationFilter, FileInstanceWhereInput> | null
    shifts?: ShiftListRelationFilter
    reviews?: ReviewListRelationFilter
    decoration?: XOR<DecorationNullableScalarRelationFilter, DecorationWhereInput> | null
    employees?: EmployeeListRelationFilter
    bookings?: BookingListRelationFilter
  }

  export type VenueOrderByWithRelationInput = {
    id?: SortOrder
    profileId?: SortOrderInput | SortOrder
    name?: SortOrder
    city?: SortOrder
    area?: SortOrder
    description?: SortOrderInput | SortOrder
    capacity?: SortOrder
    bookedDates?: SortOrder
    type?: SortOrder
    cateringDescription?: SortOrderInput | SortOrder
    parkingDescription?: SortOrderInput | SortOrder
    availabilityDescription?: SortOrderInput | SortOrder
    extraServiceDescription?: SortOrderInput | SortOrder
    price?: SortOrder
    bookingType?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Profile?: ProfileOrderByWithRelationInput
    amenities?: AmenitiesOrderByRelationAggregateInput
    arrangementsImage?: FileInstanceOrderByWithRelationInput
    shifts?: ShiftOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    decoration?: DecorationOrderByWithRelationInput
    employees?: EmployeeOrderByRelationAggregateInput
    bookings?: BookingOrderByRelationAggregateInput
  }

  export type VenueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VenueWhereInput | VenueWhereInput[]
    OR?: VenueWhereInput[]
    NOT?: VenueWhereInput | VenueWhereInput[]
    profileId?: StringNullableFilter<"Venue"> | string | null
    name?: StringFilter<"Venue"> | string
    city?: StringFilter<"Venue"> | string
    area?: StringFilter<"Venue"> | string
    description?: StringNullableFilter<"Venue"> | string | null
    capacity?: IntFilter<"Venue"> | number
    bookedDates?: DateTimeNullableListFilter<"Venue">
    type?: EnumVenueTypeFilter<"Venue"> | $Enums.VenueType
    cateringDescription?: StringNullableFilter<"Venue"> | string | null
    parkingDescription?: StringNullableFilter<"Venue"> | string | null
    availabilityDescription?: StringNullableFilter<"Venue"> | string | null
    extraServiceDescription?: StringNullableFilter<"Venue"> | string | null
    price?: IntFilter<"Venue"> | number
    bookingType?: EnumBookingTypeFilter<"Venue"> | $Enums.BookingType
    verified?: BoolFilter<"Venue"> | boolean
    createdAt?: DateTimeFilter<"Venue"> | Date | string
    updatedAt?: DateTimeFilter<"Venue"> | Date | string
    Profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    amenities?: AmenitiesListRelationFilter
    arrangementsImage?: XOR<FileInstanceNullableScalarRelationFilter, FileInstanceWhereInput> | null
    shifts?: ShiftListRelationFilter
    reviews?: ReviewListRelationFilter
    decoration?: XOR<DecorationNullableScalarRelationFilter, DecorationWhereInput> | null
    employees?: EmployeeListRelationFilter
    bookings?: BookingListRelationFilter
  }, "id">

  export type VenueOrderByWithAggregationInput = {
    id?: SortOrder
    profileId?: SortOrderInput | SortOrder
    name?: SortOrder
    city?: SortOrder
    area?: SortOrder
    description?: SortOrderInput | SortOrder
    capacity?: SortOrder
    bookedDates?: SortOrder
    type?: SortOrder
    cateringDescription?: SortOrderInput | SortOrder
    parkingDescription?: SortOrderInput | SortOrder
    availabilityDescription?: SortOrderInput | SortOrder
    extraServiceDescription?: SortOrderInput | SortOrder
    price?: SortOrder
    bookingType?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VenueCountOrderByAggregateInput
    _avg?: VenueAvgOrderByAggregateInput
    _max?: VenueMaxOrderByAggregateInput
    _min?: VenueMinOrderByAggregateInput
    _sum?: VenueSumOrderByAggregateInput
  }

  export type VenueScalarWhereWithAggregatesInput = {
    AND?: VenueScalarWhereWithAggregatesInput | VenueScalarWhereWithAggregatesInput[]
    OR?: VenueScalarWhereWithAggregatesInput[]
    NOT?: VenueScalarWhereWithAggregatesInput | VenueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Venue"> | string
    profileId?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    name?: StringWithAggregatesFilter<"Venue"> | string
    city?: StringWithAggregatesFilter<"Venue"> | string
    area?: StringWithAggregatesFilter<"Venue"> | string
    description?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    capacity?: IntWithAggregatesFilter<"Venue"> | number
    bookedDates?: DateTimeNullableListFilter<"Venue">
    type?: EnumVenueTypeWithAggregatesFilter<"Venue"> | $Enums.VenueType
    cateringDescription?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    parkingDescription?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    availabilityDescription?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    extraServiceDescription?: StringNullableWithAggregatesFilter<"Venue"> | string | null
    price?: IntWithAggregatesFilter<"Venue"> | number
    bookingType?: EnumBookingTypeWithAggregatesFilter<"Venue"> | $Enums.BookingType
    verified?: BoolWithAggregatesFilter<"Venue"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Venue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Venue"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    venueId?: StringFilter<"Employee"> | string
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    email?: StringFilter<"Employee"> | string
    phone?: StringFilter<"Employee"> | string
    role?: StringFilter<"Employee"> | string
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
    shifts?: ShiftListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    venueId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venue?: VenueOrderByWithRelationInput
    shifts?: ShiftOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    phone?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    venueId?: StringFilter<"Employee"> | string
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    role?: StringFilter<"Employee"> | string
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
    shifts?: ShiftListRelationFilter
  }, "id" | "email" | "phone">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    venueId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    venueId?: StringWithAggregatesFilter<"Employee"> | string
    firstName?: StringWithAggregatesFilter<"Employee"> | string
    lastName?: StringWithAggregatesFilter<"Employee"> | string
    email?: StringWithAggregatesFilter<"Employee"> | string
    phone?: StringWithAggregatesFilter<"Employee"> | string
    role?: StringWithAggregatesFilter<"Employee"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type ShiftWhereInput = {
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    id?: StringFilter<"Shift"> | string
    venueId?: StringFilter<"Shift"> | string
    startTime?: DateTimeFilter<"Shift"> | Date | string
    endTime?: DateTimeFilter<"Shift"> | Date | string
    duration?: IntFilter<"Shift"> | number
    shiftName?: StringFilter<"Shift"> | string
    employeeId?: StringFilter<"Shift"> | string
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type ShiftOrderByWithRelationInput = {
    id?: SortOrder
    venueId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    shiftName?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    venue?: VenueOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
  }

  export type ShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    venueId?: StringFilter<"Shift"> | string
    startTime?: DateTimeFilter<"Shift"> | Date | string
    endTime?: DateTimeFilter<"Shift"> | Date | string
    duration?: IntFilter<"Shift"> | number
    shiftName?: StringFilter<"Shift"> | string
    employeeId?: StringFilter<"Shift"> | string
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
    venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type ShiftOrderByWithAggregationInput = {
    id?: SortOrder
    venueId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    shiftName?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShiftCountOrderByAggregateInput
    _avg?: ShiftAvgOrderByAggregateInput
    _max?: ShiftMaxOrderByAggregateInput
    _min?: ShiftMinOrderByAggregateInput
    _sum?: ShiftSumOrderByAggregateInput
  }

  export type ShiftScalarWhereWithAggregatesInput = {
    AND?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    OR?: ShiftScalarWhereWithAggregatesInput[]
    NOT?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shift"> | string
    venueId?: StringWithAggregatesFilter<"Shift"> | string
    startTime?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    duration?: IntWithAggregatesFilter<"Shift"> | number
    shiftName?: StringWithAggregatesFilter<"Shift"> | string
    employeeId?: StringWithAggregatesFilter<"Shift"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
  }

  export type BookingWhereInput = {
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    id?: StringFilter<"Booking"> | string
    bookedById?: StringFilter<"Booking"> | string
    venueId?: StringNullableFilter<"Booking"> | string | null
    serviceProviderId?: StringNullableFilter<"Booking"> | string | null
    eventName?: StringFilter<"Booking"> | string
    location?: StringFilter<"Booking"> | string
    plannerName?: StringFilter<"Booking"> | string
    selectedDate?: DateTimeFilter<"Booking"> | Date | string
    startTime?: DateTimeFilter<"Booking"> | Date | string
    endTime?: DateTimeFilter<"Booking"> | Date | string
    duration?: IntFilter<"Booking"> | number
    bookingType?: EnumBookingTypeFilter<"Booking"> | $Enums.BookingType
    guestNumber?: IntFilter<"Booking"> | number
    decoration?: StringNullableFilter<"Booking"> | string | null
    services?: StringNullableListFilter<"Booking">
    totalCost?: IntFilter<"Booking"> | number
    bookingStatus?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    totalAmount?: IntFilter<"Booking"> | number
    paid?: IntFilter<"Booking"> | number
    due?: IntFilter<"Booking"> | number
    accept?: EnumAcceptanceStatusFilter<"Booking"> | $Enums.AcceptanceStatus
    isEventFinished?: BoolFilter<"Booking"> | boolean
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    bookedBy?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    venue?: XOR<VenueNullableScalarRelationFilter, VenueWhereInput> | null
    serviceProvider?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    eventType?: XOR<EventTypeNullableScalarRelationFilter, EventTypeWhereInput> | null
    payment?: PaymentListRelationFilter
  }

  export type BookingOrderByWithRelationInput = {
    id?: SortOrder
    bookedById?: SortOrder
    venueId?: SortOrderInput | SortOrder
    serviceProviderId?: SortOrderInput | SortOrder
    eventName?: SortOrder
    location?: SortOrder
    plannerName?: SortOrder
    selectedDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    bookingType?: SortOrder
    guestNumber?: SortOrder
    decoration?: SortOrderInput | SortOrder
    services?: SortOrder
    totalCost?: SortOrder
    bookingStatus?: SortOrder
    totalAmount?: SortOrder
    paid?: SortOrder
    due?: SortOrder
    accept?: SortOrder
    isEventFinished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookedBy?: ProfileOrderByWithRelationInput
    venue?: VenueOrderByWithRelationInput
    serviceProvider?: ProfileOrderByWithRelationInput
    eventType?: EventTypeOrderByWithRelationInput
    payment?: PaymentOrderByRelationAggregateInput
  }

  export type BookingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BookingWhereInput | BookingWhereInput[]
    OR?: BookingWhereInput[]
    NOT?: BookingWhereInput | BookingWhereInput[]
    bookedById?: StringFilter<"Booking"> | string
    venueId?: StringNullableFilter<"Booking"> | string | null
    serviceProviderId?: StringNullableFilter<"Booking"> | string | null
    eventName?: StringFilter<"Booking"> | string
    location?: StringFilter<"Booking"> | string
    plannerName?: StringFilter<"Booking"> | string
    selectedDate?: DateTimeFilter<"Booking"> | Date | string
    startTime?: DateTimeFilter<"Booking"> | Date | string
    endTime?: DateTimeFilter<"Booking"> | Date | string
    duration?: IntFilter<"Booking"> | number
    bookingType?: EnumBookingTypeFilter<"Booking"> | $Enums.BookingType
    guestNumber?: IntFilter<"Booking"> | number
    decoration?: StringNullableFilter<"Booking"> | string | null
    services?: StringNullableListFilter<"Booking">
    totalCost?: IntFilter<"Booking"> | number
    bookingStatus?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    totalAmount?: IntFilter<"Booking"> | number
    paid?: IntFilter<"Booking"> | number
    due?: IntFilter<"Booking"> | number
    accept?: EnumAcceptanceStatusFilter<"Booking"> | $Enums.AcceptanceStatus
    isEventFinished?: BoolFilter<"Booking"> | boolean
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
    bookedBy?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    venue?: XOR<VenueNullableScalarRelationFilter, VenueWhereInput> | null
    serviceProvider?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    eventType?: XOR<EventTypeNullableScalarRelationFilter, EventTypeWhereInput> | null
    payment?: PaymentListRelationFilter
  }, "id">

  export type BookingOrderByWithAggregationInput = {
    id?: SortOrder
    bookedById?: SortOrder
    venueId?: SortOrderInput | SortOrder
    serviceProviderId?: SortOrderInput | SortOrder
    eventName?: SortOrder
    location?: SortOrder
    plannerName?: SortOrder
    selectedDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    bookingType?: SortOrder
    guestNumber?: SortOrder
    decoration?: SortOrderInput | SortOrder
    services?: SortOrder
    totalCost?: SortOrder
    bookingStatus?: SortOrder
    totalAmount?: SortOrder
    paid?: SortOrder
    due?: SortOrder
    accept?: SortOrder
    isEventFinished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BookingCountOrderByAggregateInput
    _avg?: BookingAvgOrderByAggregateInput
    _max?: BookingMaxOrderByAggregateInput
    _min?: BookingMinOrderByAggregateInput
    _sum?: BookingSumOrderByAggregateInput
  }

  export type BookingScalarWhereWithAggregatesInput = {
    AND?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    OR?: BookingScalarWhereWithAggregatesInput[]
    NOT?: BookingScalarWhereWithAggregatesInput | BookingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Booking"> | string
    bookedById?: StringWithAggregatesFilter<"Booking"> | string
    venueId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    serviceProviderId?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    eventName?: StringWithAggregatesFilter<"Booking"> | string
    location?: StringWithAggregatesFilter<"Booking"> | string
    plannerName?: StringWithAggregatesFilter<"Booking"> | string
    selectedDate?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    startTime?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    duration?: IntWithAggregatesFilter<"Booking"> | number
    bookingType?: EnumBookingTypeWithAggregatesFilter<"Booking"> | $Enums.BookingType
    guestNumber?: IntWithAggregatesFilter<"Booking"> | number
    decoration?: StringNullableWithAggregatesFilter<"Booking"> | string | null
    services?: StringNullableListFilter<"Booking">
    totalCost?: IntWithAggregatesFilter<"Booking"> | number
    bookingStatus?: EnumBookingStatusWithAggregatesFilter<"Booking"> | $Enums.BookingStatus
    totalAmount?: IntWithAggregatesFilter<"Booking"> | number
    paid?: IntWithAggregatesFilter<"Booking"> | number
    due?: IntWithAggregatesFilter<"Booking"> | number
    accept?: EnumAcceptanceStatusWithAggregatesFilter<"Booking"> | $Enums.AcceptanceStatus
    isEventFinished?: BoolWithAggregatesFilter<"Booking"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Booking"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    bookingId?: StringFilter<"Payment"> | string
    paymentStatus?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    amount?: IntFilter<"Payment"> | number
    transactionId?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    bookingInfo?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bookingInfo?: BookingOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    bookingId?: StringFilter<"Payment"> | string
    paymentStatus?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    amount?: IntFilter<"Payment"> | number
    transactionId?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
    bookingInfo?: XOR<BookingNullableScalarRelationFilter, BookingWhereInput> | null
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    bookingId?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    bookingId?: StringWithAggregatesFilter<"Payment"> | string
    paymentStatus?: EnumPaymentStatusWithAggregatesFilter<"Payment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodWithAggregatesFilter<"Payment"> | $Enums.PaymentMethod
    amount?: IntWithAggregatesFilter<"Payment"> | number
    transactionId?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type DecorationWhereInput = {
    AND?: DecorationWhereInput | DecorationWhereInput[]
    OR?: DecorationWhereInput[]
    NOT?: DecorationWhereInput | DecorationWhereInput[]
    id?: StringFilter<"Decoration"> | string
    venueId?: StringFilter<"Decoration"> | string
    tableShapes?: EnumTableShapeNullableListFilter<"Decoration">
    seatingStyles?: EnumSeatingStyleNullableListFilter<"Decoration">
    lighting?: EnumLightingStyleNullableListFilter<"Decoration">
    flowerColors?: EnumFlowerColorNullableListFilter<"Decoration">
    flowerTypes?: EnumFlowerTypeNullableListFilter<"Decoration">
    fragrances?: EnumFragranceNullableListFilter<"Decoration">
    venue?: XOR<VenueNullableScalarRelationFilter, VenueWhereInput> | null
  }

  export type DecorationOrderByWithRelationInput = {
    id?: SortOrder
    venueId?: SortOrder
    tableShapes?: SortOrder
    seatingStyles?: SortOrder
    lighting?: SortOrder
    flowerColors?: SortOrder
    flowerTypes?: SortOrder
    fragrances?: SortOrder
    venue?: VenueOrderByWithRelationInput
  }

  export type DecorationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    venueId?: string
    AND?: DecorationWhereInput | DecorationWhereInput[]
    OR?: DecorationWhereInput[]
    NOT?: DecorationWhereInput | DecorationWhereInput[]
    tableShapes?: EnumTableShapeNullableListFilter<"Decoration">
    seatingStyles?: EnumSeatingStyleNullableListFilter<"Decoration">
    lighting?: EnumLightingStyleNullableListFilter<"Decoration">
    flowerColors?: EnumFlowerColorNullableListFilter<"Decoration">
    flowerTypes?: EnumFlowerTypeNullableListFilter<"Decoration">
    fragrances?: EnumFragranceNullableListFilter<"Decoration">
    venue?: XOR<VenueNullableScalarRelationFilter, VenueWhereInput> | null
  }, "id" | "venueId">

  export type DecorationOrderByWithAggregationInput = {
    id?: SortOrder
    venueId?: SortOrder
    tableShapes?: SortOrder
    seatingStyles?: SortOrder
    lighting?: SortOrder
    flowerColors?: SortOrder
    flowerTypes?: SortOrder
    fragrances?: SortOrder
    _count?: DecorationCountOrderByAggregateInput
    _max?: DecorationMaxOrderByAggregateInput
    _min?: DecorationMinOrderByAggregateInput
  }

  export type DecorationScalarWhereWithAggregatesInput = {
    AND?: DecorationScalarWhereWithAggregatesInput | DecorationScalarWhereWithAggregatesInput[]
    OR?: DecorationScalarWhereWithAggregatesInput[]
    NOT?: DecorationScalarWhereWithAggregatesInput | DecorationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Decoration"> | string
    venueId?: StringWithAggregatesFilter<"Decoration"> | string
    tableShapes?: EnumTableShapeNullableListFilter<"Decoration">
    seatingStyles?: EnumSeatingStyleNullableListFilter<"Decoration">
    lighting?: EnumLightingStyleNullableListFilter<"Decoration">
    flowerColors?: EnumFlowerColorNullableListFilter<"Decoration">
    flowerTypes?: EnumFlowerTypeNullableListFilter<"Decoration">
    fragrances?: EnumFragranceNullableListFilter<"Decoration">
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    venueId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    profileId?: StringNullableFilter<"Review"> | string | null
    Venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
    Profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    venueId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    profileId?: SortOrderInput | SortOrder
    Venue?: VenueOrderByWithRelationInput
    Profile?: ProfileOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    venueId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    profileId?: StringNullableFilter<"Review"> | string | null
    Venue?: XOR<VenueScalarRelationFilter, VenueWhereInput>
    Profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
  }, "id">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    venueId?: SortOrder
    rating?: SortOrder
    comment?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    profileId?: SortOrderInput | SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    venueId?: StringWithAggregatesFilter<"Review"> | string
    rating?: IntWithAggregatesFilter<"Review"> | number
    comment?: StringNullableWithAggregatesFilter<"Review"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    profileId?: StringNullableWithAggregatesFilter<"Review"> | string | null
  }

  export type AmenitiesWhereInput = {
    AND?: AmenitiesWhereInput | AmenitiesWhereInput[]
    OR?: AmenitiesWhereInput[]
    NOT?: AmenitiesWhereInput | AmenitiesWhereInput[]
    id?: StringFilter<"Amenities"> | string
    name?: StringFilter<"Amenities"> | string
    default?: BoolFilter<"Amenities"> | boolean
    Venue?: VenueListRelationFilter
  }

  export type AmenitiesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    default?: SortOrder
    Venue?: VenueOrderByRelationAggregateInput
  }

  export type AmenitiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: AmenitiesWhereInput | AmenitiesWhereInput[]
    OR?: AmenitiesWhereInput[]
    NOT?: AmenitiesWhereInput | AmenitiesWhereInput[]
    default?: BoolFilter<"Amenities"> | boolean
    Venue?: VenueListRelationFilter
  }, "id" | "name">

  export type AmenitiesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    default?: SortOrder
    _count?: AmenitiesCountOrderByAggregateInput
    _max?: AmenitiesMaxOrderByAggregateInput
    _min?: AmenitiesMinOrderByAggregateInput
  }

  export type AmenitiesScalarWhereWithAggregatesInput = {
    AND?: AmenitiesScalarWhereWithAggregatesInput | AmenitiesScalarWhereWithAggregatesInput[]
    OR?: AmenitiesScalarWhereWithAggregatesInput[]
    NOT?: AmenitiesScalarWhereWithAggregatesInput | AmenitiesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Amenities"> | string
    name?: StringWithAggregatesFilter<"Amenities"> | string
    default?: BoolWithAggregatesFilter<"Amenities"> | boolean
  }

  export type FileInstanceWhereInput = {
    AND?: FileInstanceWhereInput | FileInstanceWhereInput[]
    OR?: FileInstanceWhereInput[]
    NOT?: FileInstanceWhereInput | FileInstanceWhereInput[]
    id?: StringFilter<"FileInstance"> | string
    name?: StringFilter<"FileInstance"> | string
    fileId?: StringFilter<"FileInstance"> | string
    path?: StringFilter<"FileInstance"> | string
    createdAt?: DateTimeFilter<"FileInstance"> | Date | string
    expiresAt?: DateTimeFilter<"FileInstance"> | Date | string
    bucket?: StringFilter<"FileInstance"> | string
    type?: EnumFileTypeFilter<"FileInstance"> | $Enums.FileType
    venueId?: StringNullableFilter<"FileInstance"> | string | null
    eventPreferenceId?: StringNullableFilter<"FileInstance"> | string | null
    profileId?: StringNullableFilter<"FileInstance"> | string | null
    directMessageId?: StringNullableFilter<"FileInstance"> | string | null
    Venue?: XOR<VenueNullableScalarRelationFilter, VenueWhereInput> | null
    imageOfProfile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    coverPhotoOfProfile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    EventPreference?: XOR<EventTypeNullableScalarRelationFilter, EventTypeWhereInput> | null
    Profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    DirectMessage?: XOR<DirectMessageNullableScalarRelationFilter, DirectMessageWhereInput> | null
  }

  export type FileInstanceOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    fileId?: SortOrder
    path?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    bucket?: SortOrder
    type?: SortOrder
    venueId?: SortOrderInput | SortOrder
    eventPreferenceId?: SortOrderInput | SortOrder
    profileId?: SortOrderInput | SortOrder
    directMessageId?: SortOrderInput | SortOrder
    Venue?: VenueOrderByWithRelationInput
    imageOfProfile?: ProfileOrderByWithRelationInput
    coverPhotoOfProfile?: ProfileOrderByWithRelationInput
    EventPreference?: EventTypeOrderByWithRelationInput
    Profile?: ProfileOrderByWithRelationInput
    DirectMessage?: DirectMessageOrderByWithRelationInput
  }

  export type FileInstanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    fileId?: string
    venueId?: string
    eventPreferenceId?: string
    directMessageId?: string
    AND?: FileInstanceWhereInput | FileInstanceWhereInput[]
    OR?: FileInstanceWhereInput[]
    NOT?: FileInstanceWhereInput | FileInstanceWhereInput[]
    name?: StringFilter<"FileInstance"> | string
    path?: StringFilter<"FileInstance"> | string
    createdAt?: DateTimeFilter<"FileInstance"> | Date | string
    expiresAt?: DateTimeFilter<"FileInstance"> | Date | string
    bucket?: StringFilter<"FileInstance"> | string
    type?: EnumFileTypeFilter<"FileInstance"> | $Enums.FileType
    profileId?: StringNullableFilter<"FileInstance"> | string | null
    Venue?: XOR<VenueNullableScalarRelationFilter, VenueWhereInput> | null
    imageOfProfile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    coverPhotoOfProfile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    EventPreference?: XOR<EventTypeNullableScalarRelationFilter, EventTypeWhereInput> | null
    Profile?: XOR<ProfileNullableScalarRelationFilter, ProfileWhereInput> | null
    DirectMessage?: XOR<DirectMessageNullableScalarRelationFilter, DirectMessageWhereInput> | null
  }, "id" | "fileId" | "venueId" | "eventPreferenceId" | "directMessageId">

  export type FileInstanceOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    fileId?: SortOrder
    path?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    bucket?: SortOrder
    type?: SortOrder
    venueId?: SortOrderInput | SortOrder
    eventPreferenceId?: SortOrderInput | SortOrder
    profileId?: SortOrderInput | SortOrder
    directMessageId?: SortOrderInput | SortOrder
    _count?: FileInstanceCountOrderByAggregateInput
    _max?: FileInstanceMaxOrderByAggregateInput
    _min?: FileInstanceMinOrderByAggregateInput
  }

  export type FileInstanceScalarWhereWithAggregatesInput = {
    AND?: FileInstanceScalarWhereWithAggregatesInput | FileInstanceScalarWhereWithAggregatesInput[]
    OR?: FileInstanceScalarWhereWithAggregatesInput[]
    NOT?: FileInstanceScalarWhereWithAggregatesInput | FileInstanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"FileInstance"> | string
    name?: StringWithAggregatesFilter<"FileInstance"> | string
    fileId?: StringWithAggregatesFilter<"FileInstance"> | string
    path?: StringWithAggregatesFilter<"FileInstance"> | string
    createdAt?: DateTimeWithAggregatesFilter<"FileInstance"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"FileInstance"> | Date | string
    bucket?: StringWithAggregatesFilter<"FileInstance"> | string
    type?: EnumFileTypeWithAggregatesFilter<"FileInstance"> | $Enums.FileType
    venueId?: StringNullableWithAggregatesFilter<"FileInstance"> | string | null
    eventPreferenceId?: StringNullableWithAggregatesFilter<"FileInstance"> | string | null
    profileId?: StringNullableWithAggregatesFilter<"FileInstance"> | string | null
    directMessageId?: StringNullableWithAggregatesFilter<"FileInstance"> | string | null
  }

  export type ConversationWhereInput = {
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    id?: StringFilter<"Conversation"> | string
    memberOneId?: StringFilter<"Conversation"> | string
    memberTwoId?: StringFilter<"Conversation"> | string
    memberOne?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    memberTwo?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    directMessages?: DirectMessageListRelationFilter
  }

  export type ConversationOrderByWithRelationInput = {
    id?: SortOrder
    memberOneId?: SortOrder
    memberTwoId?: SortOrder
    memberOne?: ProfileOrderByWithRelationInput
    memberTwo?: ProfileOrderByWithRelationInput
    directMessages?: DirectMessageOrderByRelationAggregateInput
  }

  export type ConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    memberOneId_memberTwoId?: ConversationMemberOneIdMemberTwoIdCompoundUniqueInput
    AND?: ConversationWhereInput | ConversationWhereInput[]
    OR?: ConversationWhereInput[]
    NOT?: ConversationWhereInput | ConversationWhereInput[]
    memberOneId?: StringFilter<"Conversation"> | string
    memberTwoId?: StringFilter<"Conversation"> | string
    memberOne?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    memberTwo?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    directMessages?: DirectMessageListRelationFilter
  }, "id" | "memberOneId_memberTwoId">

  export type ConversationOrderByWithAggregationInput = {
    id?: SortOrder
    memberOneId?: SortOrder
    memberTwoId?: SortOrder
    _count?: ConversationCountOrderByAggregateInput
    _max?: ConversationMaxOrderByAggregateInput
    _min?: ConversationMinOrderByAggregateInput
  }

  export type ConversationScalarWhereWithAggregatesInput = {
    AND?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    OR?: ConversationScalarWhereWithAggregatesInput[]
    NOT?: ConversationScalarWhereWithAggregatesInput | ConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Conversation"> | string
    memberOneId?: StringWithAggregatesFilter<"Conversation"> | string
    memberTwoId?: StringWithAggregatesFilter<"Conversation"> | string
  }

  export type DirectMessageWhereInput = {
    AND?: DirectMessageWhereInput | DirectMessageWhereInput[]
    OR?: DirectMessageWhereInput[]
    NOT?: DirectMessageWhereInput | DirectMessageWhereInput[]
    id?: StringFilter<"DirectMessage"> | string
    content?: StringFilter<"DirectMessage"> | string
    memberId?: StringFilter<"DirectMessage"> | string
    conversationId?: StringFilter<"DirectMessage"> | string
    deleted?: BoolFilter<"DirectMessage"> | boolean
    createdAt?: DateTimeFilter<"DirectMessage"> | Date | string
    updatedAt?: DateTimeFilter<"DirectMessage"> | Date | string
    file?: XOR<FileInstanceNullableScalarRelationFilter, FileInstanceWhereInput> | null
    member?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }

  export type DirectMessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    memberId?: SortOrder
    conversationId?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    file?: FileInstanceOrderByWithRelationInput
    member?: ProfileOrderByWithRelationInput
    conversation?: ConversationOrderByWithRelationInput
  }

  export type DirectMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DirectMessageWhereInput | DirectMessageWhereInput[]
    OR?: DirectMessageWhereInput[]
    NOT?: DirectMessageWhereInput | DirectMessageWhereInput[]
    content?: StringFilter<"DirectMessage"> | string
    memberId?: StringFilter<"DirectMessage"> | string
    conversationId?: StringFilter<"DirectMessage"> | string
    deleted?: BoolFilter<"DirectMessage"> | boolean
    createdAt?: DateTimeFilter<"DirectMessage"> | Date | string
    updatedAt?: DateTimeFilter<"DirectMessage"> | Date | string
    file?: XOR<FileInstanceNullableScalarRelationFilter, FileInstanceWhereInput> | null
    member?: XOR<ProfileScalarRelationFilter, ProfileWhereInput>
    conversation?: XOR<ConversationScalarRelationFilter, ConversationWhereInput>
  }, "id">

  export type DirectMessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    memberId?: SortOrder
    conversationId?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DirectMessageCountOrderByAggregateInput
    _max?: DirectMessageMaxOrderByAggregateInput
    _min?: DirectMessageMinOrderByAggregateInput
  }

  export type DirectMessageScalarWhereWithAggregatesInput = {
    AND?: DirectMessageScalarWhereWithAggregatesInput | DirectMessageScalarWhereWithAggregatesInput[]
    OR?: DirectMessageScalarWhereWithAggregatesInput[]
    NOT?: DirectMessageScalarWhereWithAggregatesInput | DirectMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DirectMessage"> | string
    content?: StringWithAggregatesFilter<"DirectMessage"> | string
    memberId?: StringWithAggregatesFilter<"DirectMessage"> | string
    conversationId?: StringWithAggregatesFilter<"DirectMessage"> | string
    deleted?: BoolWithAggregatesFilter<"DirectMessage"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DirectMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DirectMessage"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    phone: string
    password: string
    name: string
    role?: $Enums.UserRole
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileCreateNestedOneWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    phone: string
    password: string
    name: string
    role?: $Enums.UserRole
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    profile?: ProfileUncheckedCreateNestedOneWithoutUserInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUpdateOneWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: ProfileUncheckedUpdateOneWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    phone: string
    password: string
    name: string
    role?: $Enums.UserRole
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateInput = {
    id?: string
    gender: $Enums.Gender
    location?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    image?: FileInstanceCreateNestedOneWithoutImageOfProfileInput
    eventPreference?: EventTypeCreateNestedManyWithoutProfileInput
    coverPhoto?: FileInstanceCreateNestedOneWithoutCoverPhotoOfProfileInput
    assets?: FileInstanceCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewCreateNestedManyWithoutProfileInput
    venues?: VenueCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateInput = {
    id?: string
    userId: string
    gender: $Enums.Gender
    imageId?: string | null
    location?: string | null
    coverPhotoId?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventPreference?: EventTypeUncheckedCreateNestedManyWithoutProfileInput
    assets?: FileInstanceUncheckedCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageUncheckedCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingUncheckedCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProfileInput
    venues?: VenueUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    image?: FileInstanceUpdateOneWithoutImageOfProfileNestedInput
    eventPreference?: EventTypeUpdateManyWithoutProfileNestedInput
    coverPhoto?: FileInstanceUpdateOneWithoutCoverPhotoOfProfileNestedInput
    assets?: FileInstanceUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProfileNestedInput
    venues?: VenueUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoId?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventPreference?: EventTypeUncheckedUpdateManyWithoutProfileNestedInput
    assets?: FileInstanceUncheckedUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUncheckedUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUncheckedUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProfileNestedInput
    venues?: VenueUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileCreateManyInput = {
    id?: string
    userId: string
    gender: $Enums.Gender
    imageId?: string | null
    location?: string | null
    coverPhotoId?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoId?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTypeCreateInput = {
    id?: string
    name: string
    avatar?: FileInstanceCreateNestedOneWithoutEventPreferenceInput
    profile?: ProfileCreateNestedManyWithoutEventPreferenceInput
    Booking?: BookingCreateNestedOneWithoutEventTypeInput
  }

  export type EventTypeUncheckedCreateInput = {
    id?: string
    name: string
    bookingId: string
    avatar?: FileInstanceUncheckedCreateNestedOneWithoutEventPreferenceInput
    profile?: ProfileUncheckedCreateNestedManyWithoutEventPreferenceInput
  }

  export type EventTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: FileInstanceUpdateOneWithoutEventPreferenceNestedInput
    profile?: ProfileUpdateManyWithoutEventPreferenceNestedInput
    Booking?: BookingUpdateOneWithoutEventTypeNestedInput
  }

  export type EventTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    avatar?: FileInstanceUncheckedUpdateOneWithoutEventPreferenceNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutEventPreferenceNestedInput
  }

  export type EventTypeCreateManyInput = {
    id?: string
    name: string
    bookingId: string
  }

  export type EventTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type EventTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
  }

  export type VenueCreateInput = {
    id?: string
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Profile?: ProfileCreateNestedOneWithoutVenuesInput
    amenities?: AmenitiesCreateNestedManyWithoutVenueInput
    arrangementsImage?: FileInstanceCreateNestedOneWithoutVenueInput
    shifts?: ShiftCreateNestedManyWithoutVenueInput
    reviews?: ReviewCreateNestedManyWithoutVenueInput
    decoration?: DecorationCreateNestedOneWithoutVenueInput
    employees?: EmployeeCreateNestedManyWithoutVenueInput
    bookings?: BookingCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateInput = {
    id?: string
    profileId?: string | null
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutVenueInput
    arrangementsImage?: FileInstanceUncheckedCreateNestedOneWithoutVenueInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutVenueInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutVenueInput
    decoration?: DecorationUncheckedCreateNestedOneWithoutVenueInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutVenueInput
    bookings?: BookingUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Profile?: ProfileUpdateOneWithoutVenuesNestedInput
    amenities?: AmenitiesUpdateManyWithoutVenueNestedInput
    arrangementsImage?: FileInstanceUpdateOneWithoutVenueNestedInput
    shifts?: ShiftUpdateManyWithoutVenueNestedInput
    reviews?: ReviewUpdateManyWithoutVenueNestedInput
    decoration?: DecorationUpdateOneWithoutVenueNestedInput
    employees?: EmployeeUpdateManyWithoutVenueNestedInput
    bookings?: BookingUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: AmenitiesUncheckedUpdateManyWithoutVenueNestedInput
    arrangementsImage?: FileInstanceUncheckedUpdateOneWithoutVenueNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutVenueNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutVenueNestedInput
    decoration?: DecorationUncheckedUpdateOneWithoutVenueNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutVenueNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueCreateManyInput = {
    id?: string
    profileId?: string | null
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VenueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    venue: VenueCreateNestedOneWithoutEmployeesInput
    shifts?: ShiftCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    venueId: string
    firstName: string
    lastName: string
    email: string
    phone: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutEmployeesNestedInput
    shifts?: ShiftUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    venueId: string
    firstName: string
    lastName: string
    email: string
    phone: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftCreateInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    shiftName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    venue: VenueCreateNestedOneWithoutShiftsInput
    employee: EmployeeCreateNestedOneWithoutShiftsInput
  }

  export type ShiftUncheckedCreateInput = {
    id?: string
    venueId: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    shiftName: string
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    shiftName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutShiftsNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutShiftsNestedInput
  }

  export type ShiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    shiftName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftCreateManyInput = {
    id?: string
    venueId: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    shiftName: string
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    shiftName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    shiftName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingCreateInput = {
    id?: string
    eventName: string
    location: string
    plannerName: string
    selectedDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    bookingType: $Enums.BookingType
    guestNumber: number
    decoration?: string | null
    services?: BookingCreateservicesInput | string[]
    totalCost: number
    bookingStatus?: $Enums.BookingStatus
    totalAmount?: number
    paid?: number
    due?: number
    accept: $Enums.AcceptanceStatus
    isEventFinished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookedBy: ProfileCreateNestedOneWithoutBookingToVenueInput
    venue?: VenueCreateNestedOneWithoutBookingsInput
    serviceProvider?: ProfileCreateNestedOneWithoutBookingToServiceProviderInput
    eventType?: EventTypeCreateNestedOneWithoutBookingInput
    payment?: PaymentCreateNestedManyWithoutBookingInfoInput
  }

  export type BookingUncheckedCreateInput = {
    id?: string
    bookedById: string
    venueId?: string | null
    serviceProviderId?: string | null
    eventName: string
    location: string
    plannerName: string
    selectedDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    bookingType: $Enums.BookingType
    guestNumber: number
    decoration?: string | null
    services?: BookingCreateservicesInput | string[]
    totalCost: number
    bookingStatus?: $Enums.BookingStatus
    totalAmount?: number
    paid?: number
    due?: number
    accept: $Enums.AcceptanceStatus
    isEventFinished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType?: EventTypeUncheckedCreateNestedOneWithoutBookingInput
    payment?: PaymentUncheckedCreateNestedManyWithoutBookingInfoInput
  }

  export type BookingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    plannerName?: StringFieldUpdateOperationsInput | string
    selectedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    guestNumber?: IntFieldUpdateOperationsInput | number
    decoration?: NullableStringFieldUpdateOperationsInput | string | null
    services?: BookingUpdateservicesInput | string[]
    totalCost?: IntFieldUpdateOperationsInput | number
    bookingStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    due?: IntFieldUpdateOperationsInput | number
    accept?: EnumAcceptanceStatusFieldUpdateOperationsInput | $Enums.AcceptanceStatus
    isEventFinished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedBy?: ProfileUpdateOneRequiredWithoutBookingToVenueNestedInput
    venue?: VenueUpdateOneWithoutBookingsNestedInput
    serviceProvider?: ProfileUpdateOneWithoutBookingToServiceProviderNestedInput
    eventType?: EventTypeUpdateOneWithoutBookingNestedInput
    payment?: PaymentUpdateManyWithoutBookingInfoNestedInput
  }

  export type BookingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookedById?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    plannerName?: StringFieldUpdateOperationsInput | string
    selectedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    guestNumber?: IntFieldUpdateOperationsInput | number
    decoration?: NullableStringFieldUpdateOperationsInput | string | null
    services?: BookingUpdateservicesInput | string[]
    totalCost?: IntFieldUpdateOperationsInput | number
    bookingStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    due?: IntFieldUpdateOperationsInput | number
    accept?: EnumAcceptanceStatusFieldUpdateOperationsInput | $Enums.AcceptanceStatus
    isEventFinished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EventTypeUncheckedUpdateOneWithoutBookingNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutBookingInfoNestedInput
  }

  export type BookingCreateManyInput = {
    id?: string
    bookedById: string
    venueId?: string | null
    serviceProviderId?: string | null
    eventName: string
    location: string
    plannerName: string
    selectedDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    bookingType: $Enums.BookingType
    guestNumber: number
    decoration?: string | null
    services?: BookingCreateservicesInput | string[]
    totalCost: number
    bookingStatus?: $Enums.BookingStatus
    totalAmount?: number
    paid?: number
    due?: number
    accept: $Enums.AcceptanceStatus
    isEventFinished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    plannerName?: StringFieldUpdateOperationsInput | string
    selectedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    guestNumber?: IntFieldUpdateOperationsInput | number
    decoration?: NullableStringFieldUpdateOperationsInput | string | null
    services?: BookingUpdateservicesInput | string[]
    totalCost?: IntFieldUpdateOperationsInput | number
    bookingStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    due?: IntFieldUpdateOperationsInput | number
    accept?: EnumAcceptanceStatusFieldUpdateOperationsInput | $Enums.AcceptanceStatus
    isEventFinished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookedById?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    plannerName?: StringFieldUpdateOperationsInput | string
    selectedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    guestNumber?: IntFieldUpdateOperationsInput | number
    decoration?: NullableStringFieldUpdateOperationsInput | string | null
    services?: BookingUpdateservicesInput | string[]
    totalCost?: IntFieldUpdateOperationsInput | number
    bookingStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    due?: IntFieldUpdateOperationsInput | number
    accept?: EnumAcceptanceStatusFieldUpdateOperationsInput | $Enums.AcceptanceStatus
    isEventFinished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    paymentStatus: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    amount: number
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bookingInfo?: BookingCreateNestedOneWithoutPaymentInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    bookingId: string
    paymentStatus: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    amount: number
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookingInfo?: BookingUpdateOneWithoutPaymentNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    bookingId: string
    paymentStatus: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    amount: number
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecorationCreateInput = {
    id?: string
    tableShapes?: DecorationCreatetableShapesInput | $Enums.TableShape[]
    seatingStyles?: DecorationCreateseatingStylesInput | $Enums.SeatingStyle[]
    lighting?: DecorationCreatelightingInput | $Enums.LightingStyle[]
    flowerColors?: DecorationCreateflowerColorsInput | $Enums.FlowerColor[]
    flowerTypes?: DecorationCreateflowerTypesInput | $Enums.FlowerType[]
    fragrances?: DecorationCreatefragrancesInput | $Enums.Fragrance[]
    venue?: VenueCreateNestedOneWithoutDecorationInput
  }

  export type DecorationUncheckedCreateInput = {
    id?: string
    venueId: string
    tableShapes?: DecorationCreatetableShapesInput | $Enums.TableShape[]
    seatingStyles?: DecorationCreateseatingStylesInput | $Enums.SeatingStyle[]
    lighting?: DecorationCreatelightingInput | $Enums.LightingStyle[]
    flowerColors?: DecorationCreateflowerColorsInput | $Enums.FlowerColor[]
    flowerTypes?: DecorationCreateflowerTypesInput | $Enums.FlowerType[]
    fragrances?: DecorationCreatefragrancesInput | $Enums.Fragrance[]
  }

  export type DecorationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableShapes?: DecorationUpdatetableShapesInput | $Enums.TableShape[]
    seatingStyles?: DecorationUpdateseatingStylesInput | $Enums.SeatingStyle[]
    lighting?: DecorationUpdatelightingInput | $Enums.LightingStyle[]
    flowerColors?: DecorationUpdateflowerColorsInput | $Enums.FlowerColor[]
    flowerTypes?: DecorationUpdateflowerTypesInput | $Enums.FlowerType[]
    fragrances?: DecorationUpdatefragrancesInput | $Enums.Fragrance[]
    venue?: VenueUpdateOneWithoutDecorationNestedInput
  }

  export type DecorationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    tableShapes?: DecorationUpdatetableShapesInput | $Enums.TableShape[]
    seatingStyles?: DecorationUpdateseatingStylesInput | $Enums.SeatingStyle[]
    lighting?: DecorationUpdatelightingInput | $Enums.LightingStyle[]
    flowerColors?: DecorationUpdateflowerColorsInput | $Enums.FlowerColor[]
    flowerTypes?: DecorationUpdateflowerTypesInput | $Enums.FlowerType[]
    fragrances?: DecorationUpdatefragrancesInput | $Enums.Fragrance[]
  }

  export type DecorationCreateManyInput = {
    id?: string
    venueId: string
    tableShapes?: DecorationCreatetableShapesInput | $Enums.TableShape[]
    seatingStyles?: DecorationCreateseatingStylesInput | $Enums.SeatingStyle[]
    lighting?: DecorationCreatelightingInput | $Enums.LightingStyle[]
    flowerColors?: DecorationCreateflowerColorsInput | $Enums.FlowerColor[]
    flowerTypes?: DecorationCreateflowerTypesInput | $Enums.FlowerType[]
    fragrances?: DecorationCreatefragrancesInput | $Enums.Fragrance[]
  }

  export type DecorationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableShapes?: DecorationUpdatetableShapesInput | $Enums.TableShape[]
    seatingStyles?: DecorationUpdateseatingStylesInput | $Enums.SeatingStyle[]
    lighting?: DecorationUpdatelightingInput | $Enums.LightingStyle[]
    flowerColors?: DecorationUpdateflowerColorsInput | $Enums.FlowerColor[]
    flowerTypes?: DecorationUpdateflowerTypesInput | $Enums.FlowerType[]
    fragrances?: DecorationUpdatefragrancesInput | $Enums.Fragrance[]
  }

  export type DecorationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    tableShapes?: DecorationUpdatetableShapesInput | $Enums.TableShape[]
    seatingStyles?: DecorationUpdateseatingStylesInput | $Enums.SeatingStyle[]
    lighting?: DecorationUpdatelightingInput | $Enums.LightingStyle[]
    flowerColors?: DecorationUpdateflowerColorsInput | $Enums.FlowerColor[]
    flowerTypes?: DecorationUpdateflowerTypesInput | $Enums.FlowerType[]
    fragrances?: DecorationUpdatefragrancesInput | $Enums.Fragrance[]
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    Venue: VenueCreateNestedOneWithoutReviewsInput
    Profile?: ProfileCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    venueId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    profileId?: string | null
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Venue?: VenueUpdateOneRequiredWithoutReviewsNestedInput
    Profile?: ProfileUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewCreateManyInput = {
    id?: string
    venueId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    profileId?: string | null
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AmenitiesCreateInput = {
    id?: string
    name: string
    default?: boolean
    Venue?: VenueCreateNestedManyWithoutAmenitiesInput
  }

  export type AmenitiesUncheckedCreateInput = {
    id?: string
    name: string
    default?: boolean
    Venue?: VenueUncheckedCreateNestedManyWithoutAmenitiesInput
  }

  export type AmenitiesUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    Venue?: VenueUpdateManyWithoutAmenitiesNestedInput
  }

  export type AmenitiesUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
    Venue?: VenueUncheckedUpdateManyWithoutAmenitiesNestedInput
  }

  export type AmenitiesCreateManyInput = {
    id?: string
    name: string
    default?: boolean
  }

  export type AmenitiesUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AmenitiesUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type FileInstanceCreateInput = {
    id?: string
    name: string
    fileId: string
    path: string
    createdAt?: Date | string
    expiresAt: Date | string
    bucket: string
    type: $Enums.FileType
    Venue?: VenueCreateNestedOneWithoutArrangementsImageInput
    imageOfProfile?: ProfileCreateNestedOneWithoutImageInput
    coverPhotoOfProfile?: ProfileCreateNestedOneWithoutCoverPhotoInput
    EventPreference?: EventTypeCreateNestedOneWithoutAvatarInput
    Profile?: ProfileCreateNestedOneWithoutAssetsInput
    DirectMessage?: DirectMessageCreateNestedOneWithoutFileInput
  }

  export type FileInstanceUncheckedCreateInput = {
    id?: string
    name: string
    fileId: string
    path: string
    createdAt?: Date | string
    expiresAt: Date | string
    bucket: string
    type: $Enums.FileType
    venueId?: string | null
    eventPreferenceId?: string | null
    profileId?: string | null
    directMessageId?: string | null
    imageOfProfile?: ProfileUncheckedCreateNestedOneWithoutImageInput
    coverPhotoOfProfile?: ProfileUncheckedCreateNestedOneWithoutCoverPhotoInput
  }

  export type FileInstanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    Venue?: VenueUpdateOneWithoutArrangementsImageNestedInput
    imageOfProfile?: ProfileUpdateOneWithoutImageNestedInput
    coverPhotoOfProfile?: ProfileUpdateOneWithoutCoverPhotoNestedInput
    EventPreference?: EventTypeUpdateOneWithoutAvatarNestedInput
    Profile?: ProfileUpdateOneWithoutAssetsNestedInput
    DirectMessage?: DirectMessageUpdateOneWithoutFileNestedInput
  }

  export type FileInstanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    eventPreferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    directMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    imageOfProfile?: ProfileUncheckedUpdateOneWithoutImageNestedInput
    coverPhotoOfProfile?: ProfileUncheckedUpdateOneWithoutCoverPhotoNestedInput
  }

  export type FileInstanceCreateManyInput = {
    id?: string
    name: string
    fileId: string
    path: string
    createdAt?: Date | string
    expiresAt: Date | string
    bucket: string
    type: $Enums.FileType
    venueId?: string | null
    eventPreferenceId?: string | null
    profileId?: string | null
    directMessageId?: string | null
  }

  export type FileInstanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
  }

  export type FileInstanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    eventPreferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    directMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ConversationCreateInput = {
    id?: string
    memberOne: ProfileCreateNestedOneWithoutConversationsInitiatedInput
    memberTwo: ProfileCreateNestedOneWithoutConversationsReceivedInput
    directMessages?: DirectMessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateInput = {
    id?: string
    memberOneId: string
    memberTwoId: string
    directMessages?: DirectMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberOne?: ProfileUpdateOneRequiredWithoutConversationsInitiatedNestedInput
    memberTwo?: ProfileUpdateOneRequiredWithoutConversationsReceivedNestedInput
    directMessages?: DirectMessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberOneId?: StringFieldUpdateOperationsInput | string
    memberTwoId?: StringFieldUpdateOperationsInput | string
    directMessages?: DirectMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationCreateManyInput = {
    id?: string
    memberOneId: string
    memberTwoId: string
  }

  export type ConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberOneId?: StringFieldUpdateOperationsInput | string
    memberTwoId?: StringFieldUpdateOperationsInput | string
  }

  export type DirectMessageCreateInput = {
    id?: string
    content: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    file?: FileInstanceCreateNestedOneWithoutDirectMessageInput
    member: ProfileCreateNestedOneWithoutDirectMessagesInput
    conversation: ConversationCreateNestedOneWithoutDirectMessagesInput
  }

  export type DirectMessageUncheckedCreateInput = {
    id?: string
    content: string
    memberId: string
    conversationId: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    file?: FileInstanceUncheckedCreateNestedOneWithoutDirectMessageInput
  }

  export type DirectMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FileInstanceUpdateOneWithoutDirectMessageNestedInput
    member?: ProfileUpdateOneRequiredWithoutDirectMessagesNestedInput
    conversation?: ConversationUpdateOneRequiredWithoutDirectMessagesNestedInput
  }

  export type DirectMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FileInstanceUncheckedUpdateOneWithoutDirectMessageNestedInput
  }

  export type DirectMessageCreateManyInput = {
    id?: string
    content: string
    memberId: string
    conversationId: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProfileNullableScalarRelationFilter = {
    is?: ProfileWhereInput | null
    isNot?: ProfileWhereInput | null
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    isVerified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type FileInstanceNullableScalarRelationFilter = {
    is?: FileInstanceWhereInput | null
    isNot?: FileInstanceWhereInput | null
  }

  export type EventTypeListRelationFilter = {
    every?: EventTypeWhereInput
    some?: EventTypeWhereInput
    none?: EventTypeWhereInput
  }

  export type FileInstanceListRelationFilter = {
    every?: FileInstanceWhereInput
    some?: FileInstanceWhereInput
    none?: FileInstanceWhereInput
  }

  export type DirectMessageListRelationFilter = {
    every?: DirectMessageWhereInput
    some?: DirectMessageWhereInput
    none?: DirectMessageWhereInput
  }

  export type ConversationListRelationFilter = {
    every?: ConversationWhereInput
    some?: ConversationWhereInput
    none?: ConversationWhereInput
  }

  export type BookingListRelationFilter = {
    every?: BookingWhereInput
    some?: BookingWhereInput
    none?: BookingWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type VenueListRelationFilter = {
    every?: VenueWhereInput
    some?: VenueWhereInput
    none?: VenueWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EventTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileInstanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DirectMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ConversationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VenueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gender?: SortOrder
    imageId?: SortOrder
    location?: SortOrder
    coverPhotoId?: SortOrder
    profession?: SortOrder
    description?: SortOrder
    experience?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileAvgOrderByAggregateInput = {
    experience?: SortOrder
  }

  export type ProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gender?: SortOrder
    imageId?: SortOrder
    location?: SortOrder
    coverPhotoId?: SortOrder
    profession?: SortOrder
    description?: SortOrder
    experience?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    gender?: SortOrder
    imageId?: SortOrder
    location?: SortOrder
    coverPhotoId?: SortOrder
    profession?: SortOrder
    description?: SortOrder
    experience?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileSumOrderByAggregateInput = {
    experience?: SortOrder
  }

  export type EnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ProfileListRelationFilter = {
    every?: ProfileWhereInput
    some?: ProfileWhereInput
    none?: ProfileWhereInput
  }

  export type BookingNullableScalarRelationFilter = {
    is?: BookingWhereInput | null
    isNot?: BookingWhereInput | null
  }

  export type ProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventTypeCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    bookingId?: SortOrder
  }

  export type EventTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    bookingId?: SortOrder
  }

  export type EventTypeMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    bookingId?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableListFilter<$PrismaModel = never> = {
    equals?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    has?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    hasEvery?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    hasSome?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumVenueTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VenueType | EnumVenueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VenueType[] | ListEnumVenueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VenueType[] | ListEnumVenueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVenueTypeFilter<$PrismaModel> | $Enums.VenueType
  }

  export type EnumBookingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeFilter<$PrismaModel> | $Enums.BookingType
  }

  export type AmenitiesListRelationFilter = {
    every?: AmenitiesWhereInput
    some?: AmenitiesWhereInput
    none?: AmenitiesWhereInput
  }

  export type ShiftListRelationFilter = {
    every?: ShiftWhereInput
    some?: ShiftWhereInput
    none?: ShiftWhereInput
  }

  export type DecorationNullableScalarRelationFilter = {
    is?: DecorationWhereInput | null
    isNot?: DecorationWhereInput | null
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type AmenitiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VenueCountOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    name?: SortOrder
    city?: SortOrder
    area?: SortOrder
    description?: SortOrder
    capacity?: SortOrder
    bookedDates?: SortOrder
    type?: SortOrder
    cateringDescription?: SortOrder
    parkingDescription?: SortOrder
    availabilityDescription?: SortOrder
    extraServiceDescription?: SortOrder
    price?: SortOrder
    bookingType?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueAvgOrderByAggregateInput = {
    capacity?: SortOrder
    price?: SortOrder
  }

  export type VenueMaxOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    name?: SortOrder
    city?: SortOrder
    area?: SortOrder
    description?: SortOrder
    capacity?: SortOrder
    type?: SortOrder
    cateringDescription?: SortOrder
    parkingDescription?: SortOrder
    availabilityDescription?: SortOrder
    extraServiceDescription?: SortOrder
    price?: SortOrder
    bookingType?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueMinOrderByAggregateInput = {
    id?: SortOrder
    profileId?: SortOrder
    name?: SortOrder
    city?: SortOrder
    area?: SortOrder
    description?: SortOrder
    capacity?: SortOrder
    type?: SortOrder
    cateringDescription?: SortOrder
    parkingDescription?: SortOrder
    availabilityDescription?: SortOrder
    extraServiceDescription?: SortOrder
    price?: SortOrder
    bookingType?: SortOrder
    verified?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VenueSumOrderByAggregateInput = {
    capacity?: SortOrder
    price?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumVenueTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VenueType | EnumVenueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VenueType[] | ListEnumVenueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VenueType[] | ListEnumVenueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVenueTypeWithAggregatesFilter<$PrismaModel> | $Enums.VenueType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVenueTypeFilter<$PrismaModel>
    _max?: NestedEnumVenueTypeFilter<$PrismaModel>
  }

  export type EnumBookingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeWithAggregatesFilter<$PrismaModel> | $Enums.BookingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingTypeFilter<$PrismaModel>
    _max?: NestedEnumBookingTypeFilter<$PrismaModel>
  }

  export type VenueScalarRelationFilter = {
    is?: VenueWhereInput
    isNot?: VenueWhereInput
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type ShiftCountOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    shiftName?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftAvgOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type ShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    shiftName?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftMinOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    shiftName?: SortOrder
    employeeId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftSumOrderByAggregateInput = {
    duration?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type EnumAcceptanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AcceptanceStatus | EnumAcceptanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AcceptanceStatus[] | ListEnumAcceptanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AcceptanceStatus[] | ListEnumAcceptanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAcceptanceStatusFilter<$PrismaModel> | $Enums.AcceptanceStatus
  }

  export type ProfileScalarRelationFilter = {
    is?: ProfileWhereInput
    isNot?: ProfileWhereInput
  }

  export type VenueNullableScalarRelationFilter = {
    is?: VenueWhereInput | null
    isNot?: VenueWhereInput | null
  }

  export type EventTypeNullableScalarRelationFilter = {
    is?: EventTypeWhereInput | null
    isNot?: EventTypeWhereInput | null
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BookingCountOrderByAggregateInput = {
    id?: SortOrder
    bookedById?: SortOrder
    venueId?: SortOrder
    serviceProviderId?: SortOrder
    eventName?: SortOrder
    location?: SortOrder
    plannerName?: SortOrder
    selectedDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    bookingType?: SortOrder
    guestNumber?: SortOrder
    decoration?: SortOrder
    services?: SortOrder
    totalCost?: SortOrder
    bookingStatus?: SortOrder
    totalAmount?: SortOrder
    paid?: SortOrder
    due?: SortOrder
    accept?: SortOrder
    isEventFinished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingAvgOrderByAggregateInput = {
    duration?: SortOrder
    guestNumber?: SortOrder
    totalCost?: SortOrder
    totalAmount?: SortOrder
    paid?: SortOrder
    due?: SortOrder
  }

  export type BookingMaxOrderByAggregateInput = {
    id?: SortOrder
    bookedById?: SortOrder
    venueId?: SortOrder
    serviceProviderId?: SortOrder
    eventName?: SortOrder
    location?: SortOrder
    plannerName?: SortOrder
    selectedDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    bookingType?: SortOrder
    guestNumber?: SortOrder
    decoration?: SortOrder
    totalCost?: SortOrder
    bookingStatus?: SortOrder
    totalAmount?: SortOrder
    paid?: SortOrder
    due?: SortOrder
    accept?: SortOrder
    isEventFinished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingMinOrderByAggregateInput = {
    id?: SortOrder
    bookedById?: SortOrder
    venueId?: SortOrder
    serviceProviderId?: SortOrder
    eventName?: SortOrder
    location?: SortOrder
    plannerName?: SortOrder
    selectedDate?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    duration?: SortOrder
    bookingType?: SortOrder
    guestNumber?: SortOrder
    decoration?: SortOrder
    totalCost?: SortOrder
    bookingStatus?: SortOrder
    totalAmount?: SortOrder
    paid?: SortOrder
    due?: SortOrder
    accept?: SortOrder
    isEventFinished?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BookingSumOrderByAggregateInput = {
    duration?: SortOrder
    guestNumber?: SortOrder
    totalCost?: SortOrder
    totalAmount?: SortOrder
    paid?: SortOrder
    due?: SortOrder
  }

  export type EnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type EnumAcceptanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AcceptanceStatus | EnumAcceptanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AcceptanceStatus[] | ListEnumAcceptanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AcceptanceStatus[] | ListEnumAcceptanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAcceptanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AcceptanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAcceptanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAcceptanceStatusFilter<$PrismaModel>
  }

  export type EnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type EnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    bookingId?: SortOrder
    paymentStatus?: SortOrder
    paymentMethod?: SortOrder
    amount?: SortOrder
    transactionId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type EnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type EnumTableShapeNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.TableShape[] | ListEnumTableShapeFieldRefInput<$PrismaModel> | null
    has?: $Enums.TableShape | EnumTableShapeFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.TableShape[] | ListEnumTableShapeFieldRefInput<$PrismaModel>
    hasSome?: $Enums.TableShape[] | ListEnumTableShapeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumSeatingStyleNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.SeatingStyle[] | ListEnumSeatingStyleFieldRefInput<$PrismaModel> | null
    has?: $Enums.SeatingStyle | EnumSeatingStyleFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.SeatingStyle[] | ListEnumSeatingStyleFieldRefInput<$PrismaModel>
    hasSome?: $Enums.SeatingStyle[] | ListEnumSeatingStyleFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumLightingStyleNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.LightingStyle[] | ListEnumLightingStyleFieldRefInput<$PrismaModel> | null
    has?: $Enums.LightingStyle | EnumLightingStyleFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.LightingStyle[] | ListEnumLightingStyleFieldRefInput<$PrismaModel>
    hasSome?: $Enums.LightingStyle[] | ListEnumLightingStyleFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumFlowerColorNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.FlowerColor[] | ListEnumFlowerColorFieldRefInput<$PrismaModel> | null
    has?: $Enums.FlowerColor | EnumFlowerColorFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.FlowerColor[] | ListEnumFlowerColorFieldRefInput<$PrismaModel>
    hasSome?: $Enums.FlowerColor[] | ListEnumFlowerColorFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumFlowerTypeNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.FlowerType[] | ListEnumFlowerTypeFieldRefInput<$PrismaModel> | null
    has?: $Enums.FlowerType | EnumFlowerTypeFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.FlowerType[] | ListEnumFlowerTypeFieldRefInput<$PrismaModel>
    hasSome?: $Enums.FlowerType[] | ListEnumFlowerTypeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumFragranceNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Fragrance[] | ListEnumFragranceFieldRefInput<$PrismaModel> | null
    has?: $Enums.Fragrance | EnumFragranceFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Fragrance[] | ListEnumFragranceFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Fragrance[] | ListEnumFragranceFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DecorationCountOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    tableShapes?: SortOrder
    seatingStyles?: SortOrder
    lighting?: SortOrder
    flowerColors?: SortOrder
    flowerTypes?: SortOrder
    fragrances?: SortOrder
  }

  export type DecorationMaxOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
  }

  export type DecorationMinOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    profileId?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    profileId?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    venueId?: SortOrder
    rating?: SortOrder
    comment?: SortOrder
    createdAt?: SortOrder
    profileId?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type AmenitiesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    default?: SortOrder
  }

  export type AmenitiesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    default?: SortOrder
  }

  export type AmenitiesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    default?: SortOrder
  }

  export type EnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type DirectMessageNullableScalarRelationFilter = {
    is?: DirectMessageWhereInput | null
    isNot?: DirectMessageWhereInput | null
  }

  export type FileInstanceCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileId?: SortOrder
    path?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    bucket?: SortOrder
    type?: SortOrder
    venueId?: SortOrder
    eventPreferenceId?: SortOrder
    profileId?: SortOrder
    directMessageId?: SortOrder
  }

  export type FileInstanceMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileId?: SortOrder
    path?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    bucket?: SortOrder
    type?: SortOrder
    venueId?: SortOrder
    eventPreferenceId?: SortOrder
    profileId?: SortOrder
    directMessageId?: SortOrder
  }

  export type FileInstanceMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    fileId?: SortOrder
    path?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    bucket?: SortOrder
    type?: SortOrder
    venueId?: SortOrder
    eventPreferenceId?: SortOrder
    profileId?: SortOrder
    directMessageId?: SortOrder
  }

  export type EnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type ConversationMemberOneIdMemberTwoIdCompoundUniqueInput = {
    memberOneId: string
    memberTwoId: string
  }

  export type ConversationCountOrderByAggregateInput = {
    id?: SortOrder
    memberOneId?: SortOrder
    memberTwoId?: SortOrder
  }

  export type ConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    memberOneId?: SortOrder
    memberTwoId?: SortOrder
  }

  export type ConversationMinOrderByAggregateInput = {
    id?: SortOrder
    memberOneId?: SortOrder
    memberTwoId?: SortOrder
  }

  export type ConversationScalarRelationFilter = {
    is?: ConversationWhereInput
    isNot?: ConversationWhereInput
  }

  export type DirectMessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    memberId?: SortOrder
    conversationId?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DirectMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    memberId?: SortOrder
    conversationId?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DirectMessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    memberId?: SortOrder
    conversationId?: SortOrder
    deleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    connect?: ProfileWhereUniqueInput
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutUserInput
    upsert?: ProfileUpsertWithoutUserInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutUserInput, ProfileUpdateWithoutUserInput>, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type UserCreateNestedOneWithoutProfileInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    connect?: UserWhereUniqueInput
  }

  export type FileInstanceCreateNestedOneWithoutImageOfProfileInput = {
    create?: XOR<FileInstanceCreateWithoutImageOfProfileInput, FileInstanceUncheckedCreateWithoutImageOfProfileInput>
    connectOrCreate?: FileInstanceCreateOrConnectWithoutImageOfProfileInput
    connect?: FileInstanceWhereUniqueInput
  }

  export type EventTypeCreateNestedManyWithoutProfileInput = {
    create?: XOR<EventTypeCreateWithoutProfileInput, EventTypeUncheckedCreateWithoutProfileInput> | EventTypeCreateWithoutProfileInput[] | EventTypeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: EventTypeCreateOrConnectWithoutProfileInput | EventTypeCreateOrConnectWithoutProfileInput[]
    connect?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
  }

  export type FileInstanceCreateNestedOneWithoutCoverPhotoOfProfileInput = {
    create?: XOR<FileInstanceCreateWithoutCoverPhotoOfProfileInput, FileInstanceUncheckedCreateWithoutCoverPhotoOfProfileInput>
    connectOrCreate?: FileInstanceCreateOrConnectWithoutCoverPhotoOfProfileInput
    connect?: FileInstanceWhereUniqueInput
  }

  export type FileInstanceCreateNestedManyWithoutProfileInput = {
    create?: XOR<FileInstanceCreateWithoutProfileInput, FileInstanceUncheckedCreateWithoutProfileInput> | FileInstanceCreateWithoutProfileInput[] | FileInstanceUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: FileInstanceCreateOrConnectWithoutProfileInput | FileInstanceCreateOrConnectWithoutProfileInput[]
    createMany?: FileInstanceCreateManyProfileInputEnvelope
    connect?: FileInstanceWhereUniqueInput | FileInstanceWhereUniqueInput[]
  }

  export type DirectMessageCreateNestedManyWithoutMemberInput = {
    create?: XOR<DirectMessageCreateWithoutMemberInput, DirectMessageUncheckedCreateWithoutMemberInput> | DirectMessageCreateWithoutMemberInput[] | DirectMessageUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutMemberInput | DirectMessageCreateOrConnectWithoutMemberInput[]
    createMany?: DirectMessageCreateManyMemberInputEnvelope
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutMemberOneInput = {
    create?: XOR<ConversationCreateWithoutMemberOneInput, ConversationUncheckedCreateWithoutMemberOneInput> | ConversationCreateWithoutMemberOneInput[] | ConversationUncheckedCreateWithoutMemberOneInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutMemberOneInput | ConversationCreateOrConnectWithoutMemberOneInput[]
    createMany?: ConversationCreateManyMemberOneInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationCreateNestedManyWithoutMemberTwoInput = {
    create?: XOR<ConversationCreateWithoutMemberTwoInput, ConversationUncheckedCreateWithoutMemberTwoInput> | ConversationCreateWithoutMemberTwoInput[] | ConversationUncheckedCreateWithoutMemberTwoInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutMemberTwoInput | ConversationCreateOrConnectWithoutMemberTwoInput[]
    createMany?: ConversationCreateManyMemberTwoInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutBookedByInput = {
    create?: XOR<BookingCreateWithoutBookedByInput, BookingUncheckedCreateWithoutBookedByInput> | BookingCreateWithoutBookedByInput[] | BookingUncheckedCreateWithoutBookedByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBookedByInput | BookingCreateOrConnectWithoutBookedByInput[]
    createMany?: BookingCreateManyBookedByInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<BookingCreateWithoutServiceProviderInput, BookingUncheckedCreateWithoutServiceProviderInput> | BookingCreateWithoutServiceProviderInput[] | BookingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceProviderInput | BookingCreateOrConnectWithoutServiceProviderInput[]
    createMany?: BookingCreateManyServiceProviderInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutProfileInput = {
    create?: XOR<ReviewCreateWithoutProfileInput, ReviewUncheckedCreateWithoutProfileInput> | ReviewCreateWithoutProfileInput[] | ReviewUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProfileInput | ReviewCreateOrConnectWithoutProfileInput[]
    createMany?: ReviewCreateManyProfileInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type VenueCreateNestedManyWithoutProfileInput = {
    create?: XOR<VenueCreateWithoutProfileInput, VenueUncheckedCreateWithoutProfileInput> | VenueCreateWithoutProfileInput[] | VenueUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutProfileInput | VenueCreateOrConnectWithoutProfileInput[]
    createMany?: VenueCreateManyProfileInputEnvelope
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
  }

  export type EventTypeUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<EventTypeCreateWithoutProfileInput, EventTypeUncheckedCreateWithoutProfileInput> | EventTypeCreateWithoutProfileInput[] | EventTypeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: EventTypeCreateOrConnectWithoutProfileInput | EventTypeCreateOrConnectWithoutProfileInput[]
    connect?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
  }

  export type FileInstanceUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<FileInstanceCreateWithoutProfileInput, FileInstanceUncheckedCreateWithoutProfileInput> | FileInstanceCreateWithoutProfileInput[] | FileInstanceUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: FileInstanceCreateOrConnectWithoutProfileInput | FileInstanceCreateOrConnectWithoutProfileInput[]
    createMany?: FileInstanceCreateManyProfileInputEnvelope
    connect?: FileInstanceWhereUniqueInput | FileInstanceWhereUniqueInput[]
  }

  export type DirectMessageUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<DirectMessageCreateWithoutMemberInput, DirectMessageUncheckedCreateWithoutMemberInput> | DirectMessageCreateWithoutMemberInput[] | DirectMessageUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutMemberInput | DirectMessageCreateOrConnectWithoutMemberInput[]
    createMany?: DirectMessageCreateManyMemberInputEnvelope
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutMemberOneInput = {
    create?: XOR<ConversationCreateWithoutMemberOneInput, ConversationUncheckedCreateWithoutMemberOneInput> | ConversationCreateWithoutMemberOneInput[] | ConversationUncheckedCreateWithoutMemberOneInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutMemberOneInput | ConversationCreateOrConnectWithoutMemberOneInput[]
    createMany?: ConversationCreateManyMemberOneInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type ConversationUncheckedCreateNestedManyWithoutMemberTwoInput = {
    create?: XOR<ConversationCreateWithoutMemberTwoInput, ConversationUncheckedCreateWithoutMemberTwoInput> | ConversationCreateWithoutMemberTwoInput[] | ConversationUncheckedCreateWithoutMemberTwoInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutMemberTwoInput | ConversationCreateOrConnectWithoutMemberTwoInput[]
    createMany?: ConversationCreateManyMemberTwoInputEnvelope
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutBookedByInput = {
    create?: XOR<BookingCreateWithoutBookedByInput, BookingUncheckedCreateWithoutBookedByInput> | BookingCreateWithoutBookedByInput[] | BookingUncheckedCreateWithoutBookedByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBookedByInput | BookingCreateOrConnectWithoutBookedByInput[]
    createMany?: BookingCreateManyBookedByInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutServiceProviderInput = {
    create?: XOR<BookingCreateWithoutServiceProviderInput, BookingUncheckedCreateWithoutServiceProviderInput> | BookingCreateWithoutServiceProviderInput[] | BookingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceProviderInput | BookingCreateOrConnectWithoutServiceProviderInput[]
    createMany?: BookingCreateManyServiceProviderInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<ReviewCreateWithoutProfileInput, ReviewUncheckedCreateWithoutProfileInput> | ReviewCreateWithoutProfileInput[] | ReviewUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProfileInput | ReviewCreateOrConnectWithoutProfileInput[]
    createMany?: ReviewCreateManyProfileInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type VenueUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<VenueCreateWithoutProfileInput, VenueUncheckedCreateWithoutProfileInput> | VenueCreateWithoutProfileInput[] | VenueUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutProfileInput | VenueCreateOrConnectWithoutProfileInput[]
    createMany?: VenueCreateManyProfileInputEnvelope
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
  }

  export type EnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutProfileInput
    upsert?: UserUpsertWithoutProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProfileInput, UserUpdateWithoutProfileInput>, UserUncheckedUpdateWithoutProfileInput>
  }

  export type FileInstanceUpdateOneWithoutImageOfProfileNestedInput = {
    create?: XOR<FileInstanceCreateWithoutImageOfProfileInput, FileInstanceUncheckedCreateWithoutImageOfProfileInput>
    connectOrCreate?: FileInstanceCreateOrConnectWithoutImageOfProfileInput
    upsert?: FileInstanceUpsertWithoutImageOfProfileInput
    disconnect?: FileInstanceWhereInput | boolean
    delete?: FileInstanceWhereInput | boolean
    connect?: FileInstanceWhereUniqueInput
    update?: XOR<XOR<FileInstanceUpdateToOneWithWhereWithoutImageOfProfileInput, FileInstanceUpdateWithoutImageOfProfileInput>, FileInstanceUncheckedUpdateWithoutImageOfProfileInput>
  }

  export type EventTypeUpdateManyWithoutProfileNestedInput = {
    create?: XOR<EventTypeCreateWithoutProfileInput, EventTypeUncheckedCreateWithoutProfileInput> | EventTypeCreateWithoutProfileInput[] | EventTypeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: EventTypeCreateOrConnectWithoutProfileInput | EventTypeCreateOrConnectWithoutProfileInput[]
    upsert?: EventTypeUpsertWithWhereUniqueWithoutProfileInput | EventTypeUpsertWithWhereUniqueWithoutProfileInput[]
    set?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
    disconnect?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
    delete?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
    connect?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
    update?: EventTypeUpdateWithWhereUniqueWithoutProfileInput | EventTypeUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: EventTypeUpdateManyWithWhereWithoutProfileInput | EventTypeUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: EventTypeScalarWhereInput | EventTypeScalarWhereInput[]
  }

  export type FileInstanceUpdateOneWithoutCoverPhotoOfProfileNestedInput = {
    create?: XOR<FileInstanceCreateWithoutCoverPhotoOfProfileInput, FileInstanceUncheckedCreateWithoutCoverPhotoOfProfileInput>
    connectOrCreate?: FileInstanceCreateOrConnectWithoutCoverPhotoOfProfileInput
    upsert?: FileInstanceUpsertWithoutCoverPhotoOfProfileInput
    disconnect?: FileInstanceWhereInput | boolean
    delete?: FileInstanceWhereInput | boolean
    connect?: FileInstanceWhereUniqueInput
    update?: XOR<XOR<FileInstanceUpdateToOneWithWhereWithoutCoverPhotoOfProfileInput, FileInstanceUpdateWithoutCoverPhotoOfProfileInput>, FileInstanceUncheckedUpdateWithoutCoverPhotoOfProfileInput>
  }

  export type FileInstanceUpdateManyWithoutProfileNestedInput = {
    create?: XOR<FileInstanceCreateWithoutProfileInput, FileInstanceUncheckedCreateWithoutProfileInput> | FileInstanceCreateWithoutProfileInput[] | FileInstanceUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: FileInstanceCreateOrConnectWithoutProfileInput | FileInstanceCreateOrConnectWithoutProfileInput[]
    upsert?: FileInstanceUpsertWithWhereUniqueWithoutProfileInput | FileInstanceUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: FileInstanceCreateManyProfileInputEnvelope
    set?: FileInstanceWhereUniqueInput | FileInstanceWhereUniqueInput[]
    disconnect?: FileInstanceWhereUniqueInput | FileInstanceWhereUniqueInput[]
    delete?: FileInstanceWhereUniqueInput | FileInstanceWhereUniqueInput[]
    connect?: FileInstanceWhereUniqueInput | FileInstanceWhereUniqueInput[]
    update?: FileInstanceUpdateWithWhereUniqueWithoutProfileInput | FileInstanceUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: FileInstanceUpdateManyWithWhereWithoutProfileInput | FileInstanceUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: FileInstanceScalarWhereInput | FileInstanceScalarWhereInput[]
  }

  export type DirectMessageUpdateManyWithoutMemberNestedInput = {
    create?: XOR<DirectMessageCreateWithoutMemberInput, DirectMessageUncheckedCreateWithoutMemberInput> | DirectMessageCreateWithoutMemberInput[] | DirectMessageUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutMemberInput | DirectMessageCreateOrConnectWithoutMemberInput[]
    upsert?: DirectMessageUpsertWithWhereUniqueWithoutMemberInput | DirectMessageUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: DirectMessageCreateManyMemberInputEnvelope
    set?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    disconnect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    delete?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    update?: DirectMessageUpdateWithWhereUniqueWithoutMemberInput | DirectMessageUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: DirectMessageUpdateManyWithWhereWithoutMemberInput | DirectMessageUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutMemberOneNestedInput = {
    create?: XOR<ConversationCreateWithoutMemberOneInput, ConversationUncheckedCreateWithoutMemberOneInput> | ConversationCreateWithoutMemberOneInput[] | ConversationUncheckedCreateWithoutMemberOneInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutMemberOneInput | ConversationCreateOrConnectWithoutMemberOneInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutMemberOneInput | ConversationUpsertWithWhereUniqueWithoutMemberOneInput[]
    createMany?: ConversationCreateManyMemberOneInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutMemberOneInput | ConversationUpdateWithWhereUniqueWithoutMemberOneInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutMemberOneInput | ConversationUpdateManyWithWhereWithoutMemberOneInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationUpdateManyWithoutMemberTwoNestedInput = {
    create?: XOR<ConversationCreateWithoutMemberTwoInput, ConversationUncheckedCreateWithoutMemberTwoInput> | ConversationCreateWithoutMemberTwoInput[] | ConversationUncheckedCreateWithoutMemberTwoInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutMemberTwoInput | ConversationCreateOrConnectWithoutMemberTwoInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutMemberTwoInput | ConversationUpsertWithWhereUniqueWithoutMemberTwoInput[]
    createMany?: ConversationCreateManyMemberTwoInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutMemberTwoInput | ConversationUpdateWithWhereUniqueWithoutMemberTwoInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutMemberTwoInput | ConversationUpdateManyWithWhereWithoutMemberTwoInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutBookedByNestedInput = {
    create?: XOR<BookingCreateWithoutBookedByInput, BookingUncheckedCreateWithoutBookedByInput> | BookingCreateWithoutBookedByInput[] | BookingUncheckedCreateWithoutBookedByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBookedByInput | BookingCreateOrConnectWithoutBookedByInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutBookedByInput | BookingUpsertWithWhereUniqueWithoutBookedByInput[]
    createMany?: BookingCreateManyBookedByInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutBookedByInput | BookingUpdateWithWhereUniqueWithoutBookedByInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutBookedByInput | BookingUpdateManyWithWhereWithoutBookedByInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<BookingCreateWithoutServiceProviderInput, BookingUncheckedCreateWithoutServiceProviderInput> | BookingCreateWithoutServiceProviderInput[] | BookingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceProviderInput | BookingCreateOrConnectWithoutServiceProviderInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutServiceProviderInput | BookingUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: BookingCreateManyServiceProviderInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutServiceProviderInput | BookingUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutServiceProviderInput | BookingUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ReviewCreateWithoutProfileInput, ReviewUncheckedCreateWithoutProfileInput> | ReviewCreateWithoutProfileInput[] | ReviewUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProfileInput | ReviewCreateOrConnectWithoutProfileInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProfileInput | ReviewUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ReviewCreateManyProfileInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProfileInput | ReviewUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProfileInput | ReviewUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type VenueUpdateManyWithoutProfileNestedInput = {
    create?: XOR<VenueCreateWithoutProfileInput, VenueUncheckedCreateWithoutProfileInput> | VenueCreateWithoutProfileInput[] | VenueUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutProfileInput | VenueCreateOrConnectWithoutProfileInput[]
    upsert?: VenueUpsertWithWhereUniqueWithoutProfileInput | VenueUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: VenueCreateManyProfileInputEnvelope
    set?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    disconnect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    delete?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    update?: VenueUpdateWithWhereUniqueWithoutProfileInput | VenueUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: VenueUpdateManyWithWhereWithoutProfileInput | VenueUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: VenueScalarWhereInput | VenueScalarWhereInput[]
  }

  export type EventTypeUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<EventTypeCreateWithoutProfileInput, EventTypeUncheckedCreateWithoutProfileInput> | EventTypeCreateWithoutProfileInput[] | EventTypeUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: EventTypeCreateOrConnectWithoutProfileInput | EventTypeCreateOrConnectWithoutProfileInput[]
    upsert?: EventTypeUpsertWithWhereUniqueWithoutProfileInput | EventTypeUpsertWithWhereUniqueWithoutProfileInput[]
    set?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
    disconnect?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
    delete?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
    connect?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
    update?: EventTypeUpdateWithWhereUniqueWithoutProfileInput | EventTypeUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: EventTypeUpdateManyWithWhereWithoutProfileInput | EventTypeUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: EventTypeScalarWhereInput | EventTypeScalarWhereInput[]
  }

  export type FileInstanceUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<FileInstanceCreateWithoutProfileInput, FileInstanceUncheckedCreateWithoutProfileInput> | FileInstanceCreateWithoutProfileInput[] | FileInstanceUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: FileInstanceCreateOrConnectWithoutProfileInput | FileInstanceCreateOrConnectWithoutProfileInput[]
    upsert?: FileInstanceUpsertWithWhereUniqueWithoutProfileInput | FileInstanceUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: FileInstanceCreateManyProfileInputEnvelope
    set?: FileInstanceWhereUniqueInput | FileInstanceWhereUniqueInput[]
    disconnect?: FileInstanceWhereUniqueInput | FileInstanceWhereUniqueInput[]
    delete?: FileInstanceWhereUniqueInput | FileInstanceWhereUniqueInput[]
    connect?: FileInstanceWhereUniqueInput | FileInstanceWhereUniqueInput[]
    update?: FileInstanceUpdateWithWhereUniqueWithoutProfileInput | FileInstanceUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: FileInstanceUpdateManyWithWhereWithoutProfileInput | FileInstanceUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: FileInstanceScalarWhereInput | FileInstanceScalarWhereInput[]
  }

  export type DirectMessageUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<DirectMessageCreateWithoutMemberInput, DirectMessageUncheckedCreateWithoutMemberInput> | DirectMessageCreateWithoutMemberInput[] | DirectMessageUncheckedCreateWithoutMemberInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutMemberInput | DirectMessageCreateOrConnectWithoutMemberInput[]
    upsert?: DirectMessageUpsertWithWhereUniqueWithoutMemberInput | DirectMessageUpsertWithWhereUniqueWithoutMemberInput[]
    createMany?: DirectMessageCreateManyMemberInputEnvelope
    set?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    disconnect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    delete?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    update?: DirectMessageUpdateWithWhereUniqueWithoutMemberInput | DirectMessageUpdateWithWhereUniqueWithoutMemberInput[]
    updateMany?: DirectMessageUpdateManyWithWhereWithoutMemberInput | DirectMessageUpdateManyWithWhereWithoutMemberInput[]
    deleteMany?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutMemberOneNestedInput = {
    create?: XOR<ConversationCreateWithoutMemberOneInput, ConversationUncheckedCreateWithoutMemberOneInput> | ConversationCreateWithoutMemberOneInput[] | ConversationUncheckedCreateWithoutMemberOneInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutMemberOneInput | ConversationCreateOrConnectWithoutMemberOneInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutMemberOneInput | ConversationUpsertWithWhereUniqueWithoutMemberOneInput[]
    createMany?: ConversationCreateManyMemberOneInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutMemberOneInput | ConversationUpdateWithWhereUniqueWithoutMemberOneInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutMemberOneInput | ConversationUpdateManyWithWhereWithoutMemberOneInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type ConversationUncheckedUpdateManyWithoutMemberTwoNestedInput = {
    create?: XOR<ConversationCreateWithoutMemberTwoInput, ConversationUncheckedCreateWithoutMemberTwoInput> | ConversationCreateWithoutMemberTwoInput[] | ConversationUncheckedCreateWithoutMemberTwoInput[]
    connectOrCreate?: ConversationCreateOrConnectWithoutMemberTwoInput | ConversationCreateOrConnectWithoutMemberTwoInput[]
    upsert?: ConversationUpsertWithWhereUniqueWithoutMemberTwoInput | ConversationUpsertWithWhereUniqueWithoutMemberTwoInput[]
    createMany?: ConversationCreateManyMemberTwoInputEnvelope
    set?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    disconnect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    delete?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    connect?: ConversationWhereUniqueInput | ConversationWhereUniqueInput[]
    update?: ConversationUpdateWithWhereUniqueWithoutMemberTwoInput | ConversationUpdateWithWhereUniqueWithoutMemberTwoInput[]
    updateMany?: ConversationUpdateManyWithWhereWithoutMemberTwoInput | ConversationUpdateManyWithWhereWithoutMemberTwoInput[]
    deleteMany?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutBookedByNestedInput = {
    create?: XOR<BookingCreateWithoutBookedByInput, BookingUncheckedCreateWithoutBookedByInput> | BookingCreateWithoutBookedByInput[] | BookingUncheckedCreateWithoutBookedByInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutBookedByInput | BookingCreateOrConnectWithoutBookedByInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutBookedByInput | BookingUpsertWithWhereUniqueWithoutBookedByInput[]
    createMany?: BookingCreateManyBookedByInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutBookedByInput | BookingUpdateWithWhereUniqueWithoutBookedByInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutBookedByInput | BookingUpdateManyWithWhereWithoutBookedByInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutServiceProviderNestedInput = {
    create?: XOR<BookingCreateWithoutServiceProviderInput, BookingUncheckedCreateWithoutServiceProviderInput> | BookingCreateWithoutServiceProviderInput[] | BookingUncheckedCreateWithoutServiceProviderInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutServiceProviderInput | BookingCreateOrConnectWithoutServiceProviderInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutServiceProviderInput | BookingUpsertWithWhereUniqueWithoutServiceProviderInput[]
    createMany?: BookingCreateManyServiceProviderInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutServiceProviderInput | BookingUpdateWithWhereUniqueWithoutServiceProviderInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutServiceProviderInput | BookingUpdateManyWithWhereWithoutServiceProviderInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<ReviewCreateWithoutProfileInput, ReviewUncheckedCreateWithoutProfileInput> | ReviewCreateWithoutProfileInput[] | ReviewUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProfileInput | ReviewCreateOrConnectWithoutProfileInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProfileInput | ReviewUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: ReviewCreateManyProfileInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProfileInput | ReviewUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProfileInput | ReviewUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type VenueUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<VenueCreateWithoutProfileInput, VenueUncheckedCreateWithoutProfileInput> | VenueCreateWithoutProfileInput[] | VenueUncheckedCreateWithoutProfileInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutProfileInput | VenueCreateOrConnectWithoutProfileInput[]
    upsert?: VenueUpsertWithWhereUniqueWithoutProfileInput | VenueUpsertWithWhereUniqueWithoutProfileInput[]
    createMany?: VenueCreateManyProfileInputEnvelope
    set?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    disconnect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    delete?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    update?: VenueUpdateWithWhereUniqueWithoutProfileInput | VenueUpdateWithWhereUniqueWithoutProfileInput[]
    updateMany?: VenueUpdateManyWithWhereWithoutProfileInput | VenueUpdateManyWithWhereWithoutProfileInput[]
    deleteMany?: VenueScalarWhereInput | VenueScalarWhereInput[]
  }

  export type FileInstanceCreateNestedOneWithoutEventPreferenceInput = {
    create?: XOR<FileInstanceCreateWithoutEventPreferenceInput, FileInstanceUncheckedCreateWithoutEventPreferenceInput>
    connectOrCreate?: FileInstanceCreateOrConnectWithoutEventPreferenceInput
    connect?: FileInstanceWhereUniqueInput
  }

  export type ProfileCreateNestedManyWithoutEventPreferenceInput = {
    create?: XOR<ProfileCreateWithoutEventPreferenceInput, ProfileUncheckedCreateWithoutEventPreferenceInput> | ProfileCreateWithoutEventPreferenceInput[] | ProfileUncheckedCreateWithoutEventPreferenceInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutEventPreferenceInput | ProfileCreateOrConnectWithoutEventPreferenceInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type BookingCreateNestedOneWithoutEventTypeInput = {
    create?: XOR<BookingCreateWithoutEventTypeInput, BookingUncheckedCreateWithoutEventTypeInput>
    connectOrCreate?: BookingCreateOrConnectWithoutEventTypeInput
    connect?: BookingWhereUniqueInput
  }

  export type FileInstanceUncheckedCreateNestedOneWithoutEventPreferenceInput = {
    create?: XOR<FileInstanceCreateWithoutEventPreferenceInput, FileInstanceUncheckedCreateWithoutEventPreferenceInput>
    connectOrCreate?: FileInstanceCreateOrConnectWithoutEventPreferenceInput
    connect?: FileInstanceWhereUniqueInput
  }

  export type ProfileUncheckedCreateNestedManyWithoutEventPreferenceInput = {
    create?: XOR<ProfileCreateWithoutEventPreferenceInput, ProfileUncheckedCreateWithoutEventPreferenceInput> | ProfileCreateWithoutEventPreferenceInput[] | ProfileUncheckedCreateWithoutEventPreferenceInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutEventPreferenceInput | ProfileCreateOrConnectWithoutEventPreferenceInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
  }

  export type FileInstanceUpdateOneWithoutEventPreferenceNestedInput = {
    create?: XOR<FileInstanceCreateWithoutEventPreferenceInput, FileInstanceUncheckedCreateWithoutEventPreferenceInput>
    connectOrCreate?: FileInstanceCreateOrConnectWithoutEventPreferenceInput
    upsert?: FileInstanceUpsertWithoutEventPreferenceInput
    disconnect?: FileInstanceWhereInput | boolean
    delete?: FileInstanceWhereInput | boolean
    connect?: FileInstanceWhereUniqueInput
    update?: XOR<XOR<FileInstanceUpdateToOneWithWhereWithoutEventPreferenceInput, FileInstanceUpdateWithoutEventPreferenceInput>, FileInstanceUncheckedUpdateWithoutEventPreferenceInput>
  }

  export type ProfileUpdateManyWithoutEventPreferenceNestedInput = {
    create?: XOR<ProfileCreateWithoutEventPreferenceInput, ProfileUncheckedCreateWithoutEventPreferenceInput> | ProfileCreateWithoutEventPreferenceInput[] | ProfileUncheckedCreateWithoutEventPreferenceInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutEventPreferenceInput | ProfileCreateOrConnectWithoutEventPreferenceInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutEventPreferenceInput | ProfileUpsertWithWhereUniqueWithoutEventPreferenceInput[]
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutEventPreferenceInput | ProfileUpdateWithWhereUniqueWithoutEventPreferenceInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutEventPreferenceInput | ProfileUpdateManyWithWhereWithoutEventPreferenceInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type BookingUpdateOneWithoutEventTypeNestedInput = {
    create?: XOR<BookingCreateWithoutEventTypeInput, BookingUncheckedCreateWithoutEventTypeInput>
    connectOrCreate?: BookingCreateOrConnectWithoutEventTypeInput
    upsert?: BookingUpsertWithoutEventTypeInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutEventTypeInput, BookingUpdateWithoutEventTypeInput>, BookingUncheckedUpdateWithoutEventTypeInput>
  }

  export type FileInstanceUncheckedUpdateOneWithoutEventPreferenceNestedInput = {
    create?: XOR<FileInstanceCreateWithoutEventPreferenceInput, FileInstanceUncheckedCreateWithoutEventPreferenceInput>
    connectOrCreate?: FileInstanceCreateOrConnectWithoutEventPreferenceInput
    upsert?: FileInstanceUpsertWithoutEventPreferenceInput
    disconnect?: FileInstanceWhereInput | boolean
    delete?: FileInstanceWhereInput | boolean
    connect?: FileInstanceWhereUniqueInput
    update?: XOR<XOR<FileInstanceUpdateToOneWithWhereWithoutEventPreferenceInput, FileInstanceUpdateWithoutEventPreferenceInput>, FileInstanceUncheckedUpdateWithoutEventPreferenceInput>
  }

  export type ProfileUncheckedUpdateManyWithoutEventPreferenceNestedInput = {
    create?: XOR<ProfileCreateWithoutEventPreferenceInput, ProfileUncheckedCreateWithoutEventPreferenceInput> | ProfileCreateWithoutEventPreferenceInput[] | ProfileUncheckedCreateWithoutEventPreferenceInput[]
    connectOrCreate?: ProfileCreateOrConnectWithoutEventPreferenceInput | ProfileCreateOrConnectWithoutEventPreferenceInput[]
    upsert?: ProfileUpsertWithWhereUniqueWithoutEventPreferenceInput | ProfileUpsertWithWhereUniqueWithoutEventPreferenceInput[]
    set?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    disconnect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    delete?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    connect?: ProfileWhereUniqueInput | ProfileWhereUniqueInput[]
    update?: ProfileUpdateWithWhereUniqueWithoutEventPreferenceInput | ProfileUpdateWithWhereUniqueWithoutEventPreferenceInput[]
    updateMany?: ProfileUpdateManyWithWhereWithoutEventPreferenceInput | ProfileUpdateManyWithWhereWithoutEventPreferenceInput[]
    deleteMany?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
  }

  export type VenueCreatebookedDatesInput = {
    set: Date[] | string[]
  }

  export type ProfileCreateNestedOneWithoutVenuesInput = {
    create?: XOR<ProfileCreateWithoutVenuesInput, ProfileUncheckedCreateWithoutVenuesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutVenuesInput
    connect?: ProfileWhereUniqueInput
  }

  export type AmenitiesCreateNestedManyWithoutVenueInput = {
    create?: XOR<AmenitiesCreateWithoutVenueInput, AmenitiesUncheckedCreateWithoutVenueInput> | AmenitiesCreateWithoutVenueInput[] | AmenitiesUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: AmenitiesCreateOrConnectWithoutVenueInput | AmenitiesCreateOrConnectWithoutVenueInput[]
    connect?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
  }

  export type FileInstanceCreateNestedOneWithoutVenueInput = {
    create?: XOR<FileInstanceCreateWithoutVenueInput, FileInstanceUncheckedCreateWithoutVenueInput>
    connectOrCreate?: FileInstanceCreateOrConnectWithoutVenueInput
    connect?: FileInstanceWhereUniqueInput
  }

  export type ShiftCreateNestedManyWithoutVenueInput = {
    create?: XOR<ShiftCreateWithoutVenueInput, ShiftUncheckedCreateWithoutVenueInput> | ShiftCreateWithoutVenueInput[] | ShiftUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutVenueInput | ShiftCreateOrConnectWithoutVenueInput[]
    createMany?: ShiftCreateManyVenueInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutVenueInput = {
    create?: XOR<ReviewCreateWithoutVenueInput, ReviewUncheckedCreateWithoutVenueInput> | ReviewCreateWithoutVenueInput[] | ReviewUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutVenueInput | ReviewCreateOrConnectWithoutVenueInput[]
    createMany?: ReviewCreateManyVenueInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type DecorationCreateNestedOneWithoutVenueInput = {
    create?: XOR<DecorationCreateWithoutVenueInput, DecorationUncheckedCreateWithoutVenueInput>
    connectOrCreate?: DecorationCreateOrConnectWithoutVenueInput
    connect?: DecorationWhereUniqueInput
  }

  export type EmployeeCreateNestedManyWithoutVenueInput = {
    create?: XOR<EmployeeCreateWithoutVenueInput, EmployeeUncheckedCreateWithoutVenueInput> | EmployeeCreateWithoutVenueInput[] | EmployeeUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutVenueInput | EmployeeCreateOrConnectWithoutVenueInput[]
    createMany?: EmployeeCreateManyVenueInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type BookingCreateNestedManyWithoutVenueInput = {
    create?: XOR<BookingCreateWithoutVenueInput, BookingUncheckedCreateWithoutVenueInput> | BookingCreateWithoutVenueInput[] | BookingUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVenueInput | BookingCreateOrConnectWithoutVenueInput[]
    createMany?: BookingCreateManyVenueInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type AmenitiesUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<AmenitiesCreateWithoutVenueInput, AmenitiesUncheckedCreateWithoutVenueInput> | AmenitiesCreateWithoutVenueInput[] | AmenitiesUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: AmenitiesCreateOrConnectWithoutVenueInput | AmenitiesCreateOrConnectWithoutVenueInput[]
    connect?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
  }

  export type FileInstanceUncheckedCreateNestedOneWithoutVenueInput = {
    create?: XOR<FileInstanceCreateWithoutVenueInput, FileInstanceUncheckedCreateWithoutVenueInput>
    connectOrCreate?: FileInstanceCreateOrConnectWithoutVenueInput
    connect?: FileInstanceWhereUniqueInput
  }

  export type ShiftUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<ShiftCreateWithoutVenueInput, ShiftUncheckedCreateWithoutVenueInput> | ShiftCreateWithoutVenueInput[] | ShiftUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutVenueInput | ShiftCreateOrConnectWithoutVenueInput[]
    createMany?: ShiftCreateManyVenueInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<ReviewCreateWithoutVenueInput, ReviewUncheckedCreateWithoutVenueInput> | ReviewCreateWithoutVenueInput[] | ReviewUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutVenueInput | ReviewCreateOrConnectWithoutVenueInput[]
    createMany?: ReviewCreateManyVenueInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type DecorationUncheckedCreateNestedOneWithoutVenueInput = {
    create?: XOR<DecorationCreateWithoutVenueInput, DecorationUncheckedCreateWithoutVenueInput>
    connectOrCreate?: DecorationCreateOrConnectWithoutVenueInput
    connect?: DecorationWhereUniqueInput
  }

  export type EmployeeUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<EmployeeCreateWithoutVenueInput, EmployeeUncheckedCreateWithoutVenueInput> | EmployeeCreateWithoutVenueInput[] | EmployeeUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutVenueInput | EmployeeCreateOrConnectWithoutVenueInput[]
    createMany?: EmployeeCreateManyVenueInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type BookingUncheckedCreateNestedManyWithoutVenueInput = {
    create?: XOR<BookingCreateWithoutVenueInput, BookingUncheckedCreateWithoutVenueInput> | BookingCreateWithoutVenueInput[] | BookingUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVenueInput | BookingCreateOrConnectWithoutVenueInput[]
    createMany?: BookingCreateManyVenueInputEnvelope
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type VenueUpdatebookedDatesInput = {
    set?: Date[] | string[]
    push?: Date | string | Date[] | string[]
  }

  export type EnumVenueTypeFieldUpdateOperationsInput = {
    set?: $Enums.VenueType
  }

  export type EnumBookingTypeFieldUpdateOperationsInput = {
    set?: $Enums.BookingType
  }

  export type ProfileUpdateOneWithoutVenuesNestedInput = {
    create?: XOR<ProfileCreateWithoutVenuesInput, ProfileUncheckedCreateWithoutVenuesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutVenuesInput
    upsert?: ProfileUpsertWithoutVenuesInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutVenuesInput, ProfileUpdateWithoutVenuesInput>, ProfileUncheckedUpdateWithoutVenuesInput>
  }

  export type AmenitiesUpdateManyWithoutVenueNestedInput = {
    create?: XOR<AmenitiesCreateWithoutVenueInput, AmenitiesUncheckedCreateWithoutVenueInput> | AmenitiesCreateWithoutVenueInput[] | AmenitiesUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: AmenitiesCreateOrConnectWithoutVenueInput | AmenitiesCreateOrConnectWithoutVenueInput[]
    upsert?: AmenitiesUpsertWithWhereUniqueWithoutVenueInput | AmenitiesUpsertWithWhereUniqueWithoutVenueInput[]
    set?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    disconnect?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    delete?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    connect?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    update?: AmenitiesUpdateWithWhereUniqueWithoutVenueInput | AmenitiesUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: AmenitiesUpdateManyWithWhereWithoutVenueInput | AmenitiesUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: AmenitiesScalarWhereInput | AmenitiesScalarWhereInput[]
  }

  export type FileInstanceUpdateOneWithoutVenueNestedInput = {
    create?: XOR<FileInstanceCreateWithoutVenueInput, FileInstanceUncheckedCreateWithoutVenueInput>
    connectOrCreate?: FileInstanceCreateOrConnectWithoutVenueInput
    upsert?: FileInstanceUpsertWithoutVenueInput
    disconnect?: FileInstanceWhereInput | boolean
    delete?: FileInstanceWhereInput | boolean
    connect?: FileInstanceWhereUniqueInput
    update?: XOR<XOR<FileInstanceUpdateToOneWithWhereWithoutVenueInput, FileInstanceUpdateWithoutVenueInput>, FileInstanceUncheckedUpdateWithoutVenueInput>
  }

  export type ShiftUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ShiftCreateWithoutVenueInput, ShiftUncheckedCreateWithoutVenueInput> | ShiftCreateWithoutVenueInput[] | ShiftUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutVenueInput | ShiftCreateOrConnectWithoutVenueInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutVenueInput | ShiftUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ShiftCreateManyVenueInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutVenueInput | ShiftUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutVenueInput | ShiftUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ReviewCreateWithoutVenueInput, ReviewUncheckedCreateWithoutVenueInput> | ReviewCreateWithoutVenueInput[] | ReviewUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutVenueInput | ReviewCreateOrConnectWithoutVenueInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutVenueInput | ReviewUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ReviewCreateManyVenueInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutVenueInput | ReviewUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutVenueInput | ReviewUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type DecorationUpdateOneWithoutVenueNestedInput = {
    create?: XOR<DecorationCreateWithoutVenueInput, DecorationUncheckedCreateWithoutVenueInput>
    connectOrCreate?: DecorationCreateOrConnectWithoutVenueInput
    upsert?: DecorationUpsertWithoutVenueInput
    disconnect?: DecorationWhereInput | boolean
    delete?: DecorationWhereInput | boolean
    connect?: DecorationWhereUniqueInput
    update?: XOR<XOR<DecorationUpdateToOneWithWhereWithoutVenueInput, DecorationUpdateWithoutVenueInput>, DecorationUncheckedUpdateWithoutVenueInput>
  }

  export type EmployeeUpdateManyWithoutVenueNestedInput = {
    create?: XOR<EmployeeCreateWithoutVenueInput, EmployeeUncheckedCreateWithoutVenueInput> | EmployeeCreateWithoutVenueInput[] | EmployeeUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutVenueInput | EmployeeCreateOrConnectWithoutVenueInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutVenueInput | EmployeeUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: EmployeeCreateManyVenueInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutVenueInput | EmployeeUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutVenueInput | EmployeeUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type BookingUpdateManyWithoutVenueNestedInput = {
    create?: XOR<BookingCreateWithoutVenueInput, BookingUncheckedCreateWithoutVenueInput> | BookingCreateWithoutVenueInput[] | BookingUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVenueInput | BookingCreateOrConnectWithoutVenueInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutVenueInput | BookingUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: BookingCreateManyVenueInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutVenueInput | BookingUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutVenueInput | BookingUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type AmenitiesUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<AmenitiesCreateWithoutVenueInput, AmenitiesUncheckedCreateWithoutVenueInput> | AmenitiesCreateWithoutVenueInput[] | AmenitiesUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: AmenitiesCreateOrConnectWithoutVenueInput | AmenitiesCreateOrConnectWithoutVenueInput[]
    upsert?: AmenitiesUpsertWithWhereUniqueWithoutVenueInput | AmenitiesUpsertWithWhereUniqueWithoutVenueInput[]
    set?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    disconnect?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    delete?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    connect?: AmenitiesWhereUniqueInput | AmenitiesWhereUniqueInput[]
    update?: AmenitiesUpdateWithWhereUniqueWithoutVenueInput | AmenitiesUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: AmenitiesUpdateManyWithWhereWithoutVenueInput | AmenitiesUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: AmenitiesScalarWhereInput | AmenitiesScalarWhereInput[]
  }

  export type FileInstanceUncheckedUpdateOneWithoutVenueNestedInput = {
    create?: XOR<FileInstanceCreateWithoutVenueInput, FileInstanceUncheckedCreateWithoutVenueInput>
    connectOrCreate?: FileInstanceCreateOrConnectWithoutVenueInput
    upsert?: FileInstanceUpsertWithoutVenueInput
    disconnect?: FileInstanceWhereInput | boolean
    delete?: FileInstanceWhereInput | boolean
    connect?: FileInstanceWhereUniqueInput
    update?: XOR<XOR<FileInstanceUpdateToOneWithWhereWithoutVenueInput, FileInstanceUpdateWithoutVenueInput>, FileInstanceUncheckedUpdateWithoutVenueInput>
  }

  export type ShiftUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ShiftCreateWithoutVenueInput, ShiftUncheckedCreateWithoutVenueInput> | ShiftCreateWithoutVenueInput[] | ShiftUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutVenueInput | ShiftCreateOrConnectWithoutVenueInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutVenueInput | ShiftUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ShiftCreateManyVenueInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutVenueInput | ShiftUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutVenueInput | ShiftUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<ReviewCreateWithoutVenueInput, ReviewUncheckedCreateWithoutVenueInput> | ReviewCreateWithoutVenueInput[] | ReviewUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutVenueInput | ReviewCreateOrConnectWithoutVenueInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutVenueInput | ReviewUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: ReviewCreateManyVenueInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutVenueInput | ReviewUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutVenueInput | ReviewUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type DecorationUncheckedUpdateOneWithoutVenueNestedInput = {
    create?: XOR<DecorationCreateWithoutVenueInput, DecorationUncheckedCreateWithoutVenueInput>
    connectOrCreate?: DecorationCreateOrConnectWithoutVenueInput
    upsert?: DecorationUpsertWithoutVenueInput
    disconnect?: DecorationWhereInput | boolean
    delete?: DecorationWhereInput | boolean
    connect?: DecorationWhereUniqueInput
    update?: XOR<XOR<DecorationUpdateToOneWithWhereWithoutVenueInput, DecorationUpdateWithoutVenueInput>, DecorationUncheckedUpdateWithoutVenueInput>
  }

  export type EmployeeUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<EmployeeCreateWithoutVenueInput, EmployeeUncheckedCreateWithoutVenueInput> | EmployeeCreateWithoutVenueInput[] | EmployeeUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutVenueInput | EmployeeCreateOrConnectWithoutVenueInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutVenueInput | EmployeeUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: EmployeeCreateManyVenueInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutVenueInput | EmployeeUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutVenueInput | EmployeeUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type BookingUncheckedUpdateManyWithoutVenueNestedInput = {
    create?: XOR<BookingCreateWithoutVenueInput, BookingUncheckedCreateWithoutVenueInput> | BookingCreateWithoutVenueInput[] | BookingUncheckedCreateWithoutVenueInput[]
    connectOrCreate?: BookingCreateOrConnectWithoutVenueInput | BookingCreateOrConnectWithoutVenueInput[]
    upsert?: BookingUpsertWithWhereUniqueWithoutVenueInput | BookingUpsertWithWhereUniqueWithoutVenueInput[]
    createMany?: BookingCreateManyVenueInputEnvelope
    set?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    disconnect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    delete?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    connect?: BookingWhereUniqueInput | BookingWhereUniqueInput[]
    update?: BookingUpdateWithWhereUniqueWithoutVenueInput | BookingUpdateWithWhereUniqueWithoutVenueInput[]
    updateMany?: BookingUpdateManyWithWhereWithoutVenueInput | BookingUpdateManyWithWhereWithoutVenueInput[]
    deleteMany?: BookingScalarWhereInput | BookingScalarWhereInput[]
  }

  export type VenueCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<VenueCreateWithoutEmployeesInput, VenueUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutEmployeesInput
    connect?: VenueWhereUniqueInput
  }

  export type ShiftCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ShiftCreateWithoutEmployeeInput, ShiftUncheckedCreateWithoutEmployeeInput> | ShiftCreateWithoutEmployeeInput[] | ShiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutEmployeeInput | ShiftCreateOrConnectWithoutEmployeeInput[]
    createMany?: ShiftCreateManyEmployeeInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type ShiftUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ShiftCreateWithoutEmployeeInput, ShiftUncheckedCreateWithoutEmployeeInput> | ShiftCreateWithoutEmployeeInput[] | ShiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutEmployeeInput | ShiftCreateOrConnectWithoutEmployeeInput[]
    createMany?: ShiftCreateManyEmployeeInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type VenueUpdateOneRequiredWithoutEmployeesNestedInput = {
    create?: XOR<VenueCreateWithoutEmployeesInput, VenueUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: VenueCreateOrConnectWithoutEmployeesInput
    upsert?: VenueUpsertWithoutEmployeesInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutEmployeesInput, VenueUpdateWithoutEmployeesInput>, VenueUncheckedUpdateWithoutEmployeesInput>
  }

  export type ShiftUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ShiftCreateWithoutEmployeeInput, ShiftUncheckedCreateWithoutEmployeeInput> | ShiftCreateWithoutEmployeeInput[] | ShiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutEmployeeInput | ShiftCreateOrConnectWithoutEmployeeInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutEmployeeInput | ShiftUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ShiftCreateManyEmployeeInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutEmployeeInput | ShiftUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutEmployeeInput | ShiftUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type ShiftUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ShiftCreateWithoutEmployeeInput, ShiftUncheckedCreateWithoutEmployeeInput> | ShiftCreateWithoutEmployeeInput[] | ShiftUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutEmployeeInput | ShiftCreateOrConnectWithoutEmployeeInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutEmployeeInput | ShiftUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ShiftCreateManyEmployeeInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutEmployeeInput | ShiftUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutEmployeeInput | ShiftUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type VenueCreateNestedOneWithoutShiftsInput = {
    create?: XOR<VenueCreateWithoutShiftsInput, VenueUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutShiftsInput
    connect?: VenueWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutShiftsInput = {
    create?: XOR<EmployeeCreateWithoutShiftsInput, EmployeeUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type VenueUpdateOneRequiredWithoutShiftsNestedInput = {
    create?: XOR<VenueCreateWithoutShiftsInput, VenueUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutShiftsInput
    upsert?: VenueUpsertWithoutShiftsInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutShiftsInput, VenueUpdateWithoutShiftsInput>, VenueUncheckedUpdateWithoutShiftsInput>
  }

  export type EmployeeUpdateOneRequiredWithoutShiftsNestedInput = {
    create?: XOR<EmployeeCreateWithoutShiftsInput, EmployeeUncheckedCreateWithoutShiftsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftsInput
    upsert?: EmployeeUpsertWithoutShiftsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutShiftsInput, EmployeeUpdateWithoutShiftsInput>, EmployeeUncheckedUpdateWithoutShiftsInput>
  }

  export type BookingCreateservicesInput = {
    set: string[]
  }

  export type ProfileCreateNestedOneWithoutBookingToVenueInput = {
    create?: XOR<ProfileCreateWithoutBookingToVenueInput, ProfileUncheckedCreateWithoutBookingToVenueInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutBookingToVenueInput
    connect?: ProfileWhereUniqueInput
  }

  export type VenueCreateNestedOneWithoutBookingsInput = {
    create?: XOR<VenueCreateWithoutBookingsInput, VenueUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutBookingsInput
    connect?: VenueWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutBookingToServiceProviderInput = {
    create?: XOR<ProfileCreateWithoutBookingToServiceProviderInput, ProfileUncheckedCreateWithoutBookingToServiceProviderInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutBookingToServiceProviderInput
    connect?: ProfileWhereUniqueInput
  }

  export type EventTypeCreateNestedOneWithoutBookingInput = {
    create?: XOR<EventTypeCreateWithoutBookingInput, EventTypeUncheckedCreateWithoutBookingInput>
    connectOrCreate?: EventTypeCreateOrConnectWithoutBookingInput
    connect?: EventTypeWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutBookingInfoInput = {
    create?: XOR<PaymentCreateWithoutBookingInfoInput, PaymentUncheckedCreateWithoutBookingInfoInput> | PaymentCreateWithoutBookingInfoInput[] | PaymentUncheckedCreateWithoutBookingInfoInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInfoInput | PaymentCreateOrConnectWithoutBookingInfoInput[]
    createMany?: PaymentCreateManyBookingInfoInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EventTypeUncheckedCreateNestedOneWithoutBookingInput = {
    create?: XOR<EventTypeCreateWithoutBookingInput, EventTypeUncheckedCreateWithoutBookingInput>
    connectOrCreate?: EventTypeCreateOrConnectWithoutBookingInput
    connect?: EventTypeWhereUniqueInput
  }

  export type PaymentUncheckedCreateNestedManyWithoutBookingInfoInput = {
    create?: XOR<PaymentCreateWithoutBookingInfoInput, PaymentUncheckedCreateWithoutBookingInfoInput> | PaymentCreateWithoutBookingInfoInput[] | PaymentUncheckedCreateWithoutBookingInfoInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInfoInput | PaymentCreateOrConnectWithoutBookingInfoInput[]
    createMany?: PaymentCreateManyBookingInfoInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type BookingUpdateservicesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumBookingStatusFieldUpdateOperationsInput = {
    set?: $Enums.BookingStatus
  }

  export type EnumAcceptanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AcceptanceStatus
  }

  export type ProfileUpdateOneRequiredWithoutBookingToVenueNestedInput = {
    create?: XOR<ProfileCreateWithoutBookingToVenueInput, ProfileUncheckedCreateWithoutBookingToVenueInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutBookingToVenueInput
    upsert?: ProfileUpsertWithoutBookingToVenueInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutBookingToVenueInput, ProfileUpdateWithoutBookingToVenueInput>, ProfileUncheckedUpdateWithoutBookingToVenueInput>
  }

  export type VenueUpdateOneWithoutBookingsNestedInput = {
    create?: XOR<VenueCreateWithoutBookingsInput, VenueUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutBookingsInput
    upsert?: VenueUpsertWithoutBookingsInput
    disconnect?: VenueWhereInput | boolean
    delete?: VenueWhereInput | boolean
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutBookingsInput, VenueUpdateWithoutBookingsInput>, VenueUncheckedUpdateWithoutBookingsInput>
  }

  export type ProfileUpdateOneWithoutBookingToServiceProviderNestedInput = {
    create?: XOR<ProfileCreateWithoutBookingToServiceProviderInput, ProfileUncheckedCreateWithoutBookingToServiceProviderInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutBookingToServiceProviderInput
    upsert?: ProfileUpsertWithoutBookingToServiceProviderInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutBookingToServiceProviderInput, ProfileUpdateWithoutBookingToServiceProviderInput>, ProfileUncheckedUpdateWithoutBookingToServiceProviderInput>
  }

  export type EventTypeUpdateOneWithoutBookingNestedInput = {
    create?: XOR<EventTypeCreateWithoutBookingInput, EventTypeUncheckedCreateWithoutBookingInput>
    connectOrCreate?: EventTypeCreateOrConnectWithoutBookingInput
    upsert?: EventTypeUpsertWithoutBookingInput
    disconnect?: EventTypeWhereInput | boolean
    delete?: EventTypeWhereInput | boolean
    connect?: EventTypeWhereUniqueInput
    update?: XOR<XOR<EventTypeUpdateToOneWithWhereWithoutBookingInput, EventTypeUpdateWithoutBookingInput>, EventTypeUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUpdateManyWithoutBookingInfoNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInfoInput, PaymentUncheckedCreateWithoutBookingInfoInput> | PaymentCreateWithoutBookingInfoInput[] | PaymentUncheckedCreateWithoutBookingInfoInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInfoInput | PaymentCreateOrConnectWithoutBookingInfoInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInfoInput | PaymentUpsertWithWhereUniqueWithoutBookingInfoInput[]
    createMany?: PaymentCreateManyBookingInfoInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInfoInput | PaymentUpdateWithWhereUniqueWithoutBookingInfoInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInfoInput | PaymentUpdateManyWithWhereWithoutBookingInfoInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type EventTypeUncheckedUpdateOneWithoutBookingNestedInput = {
    create?: XOR<EventTypeCreateWithoutBookingInput, EventTypeUncheckedCreateWithoutBookingInput>
    connectOrCreate?: EventTypeCreateOrConnectWithoutBookingInput
    upsert?: EventTypeUpsertWithoutBookingInput
    disconnect?: EventTypeWhereInput | boolean
    delete?: EventTypeWhereInput | boolean
    connect?: EventTypeWhereUniqueInput
    update?: XOR<XOR<EventTypeUpdateToOneWithWhereWithoutBookingInput, EventTypeUpdateWithoutBookingInput>, EventTypeUncheckedUpdateWithoutBookingInput>
  }

  export type PaymentUncheckedUpdateManyWithoutBookingInfoNestedInput = {
    create?: XOR<PaymentCreateWithoutBookingInfoInput, PaymentUncheckedCreateWithoutBookingInfoInput> | PaymentCreateWithoutBookingInfoInput[] | PaymentUncheckedCreateWithoutBookingInfoInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutBookingInfoInput | PaymentCreateOrConnectWithoutBookingInfoInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutBookingInfoInput | PaymentUpsertWithWhereUniqueWithoutBookingInfoInput[]
    createMany?: PaymentCreateManyBookingInfoInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutBookingInfoInput | PaymentUpdateWithWhereUniqueWithoutBookingInfoInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutBookingInfoInput | PaymentUpdateManyWithWhereWithoutBookingInfoInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type BookingCreateNestedOneWithoutPaymentInput = {
    create?: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentInput
    connect?: BookingWhereUniqueInput
  }

  export type EnumPaymentStatusFieldUpdateOperationsInput = {
    set?: $Enums.PaymentStatus
  }

  export type EnumPaymentMethodFieldUpdateOperationsInput = {
    set?: $Enums.PaymentMethod
  }

  export type BookingUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: BookingCreateOrConnectWithoutPaymentInput
    upsert?: BookingUpsertWithoutPaymentInput
    disconnect?: BookingWhereInput | boolean
    delete?: BookingWhereInput | boolean
    connect?: BookingWhereUniqueInput
    update?: XOR<XOR<BookingUpdateToOneWithWhereWithoutPaymentInput, BookingUpdateWithoutPaymentInput>, BookingUncheckedUpdateWithoutPaymentInput>
  }

  export type DecorationCreatetableShapesInput = {
    set: $Enums.TableShape[]
  }

  export type DecorationCreateseatingStylesInput = {
    set: $Enums.SeatingStyle[]
  }

  export type DecorationCreatelightingInput = {
    set: $Enums.LightingStyle[]
  }

  export type DecorationCreateflowerColorsInput = {
    set: $Enums.FlowerColor[]
  }

  export type DecorationCreateflowerTypesInput = {
    set: $Enums.FlowerType[]
  }

  export type DecorationCreatefragrancesInput = {
    set: $Enums.Fragrance[]
  }

  export type VenueCreateNestedOneWithoutDecorationInput = {
    create?: XOR<VenueCreateWithoutDecorationInput, VenueUncheckedCreateWithoutDecorationInput>
    connectOrCreate?: VenueCreateOrConnectWithoutDecorationInput
    connect?: VenueWhereUniqueInput
  }

  export type DecorationUpdatetableShapesInput = {
    set?: $Enums.TableShape[]
    push?: $Enums.TableShape | $Enums.TableShape[]
  }

  export type DecorationUpdateseatingStylesInput = {
    set?: $Enums.SeatingStyle[]
    push?: $Enums.SeatingStyle | $Enums.SeatingStyle[]
  }

  export type DecorationUpdatelightingInput = {
    set?: $Enums.LightingStyle[]
    push?: $Enums.LightingStyle | $Enums.LightingStyle[]
  }

  export type DecorationUpdateflowerColorsInput = {
    set?: $Enums.FlowerColor[]
    push?: $Enums.FlowerColor | $Enums.FlowerColor[]
  }

  export type DecorationUpdateflowerTypesInput = {
    set?: $Enums.FlowerType[]
    push?: $Enums.FlowerType | $Enums.FlowerType[]
  }

  export type DecorationUpdatefragrancesInput = {
    set?: $Enums.Fragrance[]
    push?: $Enums.Fragrance | $Enums.Fragrance[]
  }

  export type VenueUpdateOneWithoutDecorationNestedInput = {
    create?: XOR<VenueCreateWithoutDecorationInput, VenueUncheckedCreateWithoutDecorationInput>
    connectOrCreate?: VenueCreateOrConnectWithoutDecorationInput
    upsert?: VenueUpsertWithoutDecorationInput
    disconnect?: VenueWhereInput | boolean
    delete?: VenueWhereInput | boolean
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutDecorationInput, VenueUpdateWithoutDecorationInput>, VenueUncheckedUpdateWithoutDecorationInput>
  }

  export type VenueCreateNestedOneWithoutReviewsInput = {
    create?: XOR<VenueCreateWithoutReviewsInput, VenueUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutReviewsInput
    connect?: VenueWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ProfileCreateWithoutReviewsInput, ProfileUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutReviewsInput
    connect?: ProfileWhereUniqueInput
  }

  export type VenueUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<VenueCreateWithoutReviewsInput, VenueUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: VenueCreateOrConnectWithoutReviewsInput
    upsert?: VenueUpsertWithoutReviewsInput
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutReviewsInput, VenueUpdateWithoutReviewsInput>, VenueUncheckedUpdateWithoutReviewsInput>
  }

  export type ProfileUpdateOneWithoutReviewsNestedInput = {
    create?: XOR<ProfileCreateWithoutReviewsInput, ProfileUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutReviewsInput
    upsert?: ProfileUpsertWithoutReviewsInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutReviewsInput, ProfileUpdateWithoutReviewsInput>, ProfileUncheckedUpdateWithoutReviewsInput>
  }

  export type VenueCreateNestedManyWithoutAmenitiesInput = {
    create?: XOR<VenueCreateWithoutAmenitiesInput, VenueUncheckedCreateWithoutAmenitiesInput> | VenueCreateWithoutAmenitiesInput[] | VenueUncheckedCreateWithoutAmenitiesInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutAmenitiesInput | VenueCreateOrConnectWithoutAmenitiesInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
  }

  export type VenueUncheckedCreateNestedManyWithoutAmenitiesInput = {
    create?: XOR<VenueCreateWithoutAmenitiesInput, VenueUncheckedCreateWithoutAmenitiesInput> | VenueCreateWithoutAmenitiesInput[] | VenueUncheckedCreateWithoutAmenitiesInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutAmenitiesInput | VenueCreateOrConnectWithoutAmenitiesInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
  }

  export type VenueUpdateManyWithoutAmenitiesNestedInput = {
    create?: XOR<VenueCreateWithoutAmenitiesInput, VenueUncheckedCreateWithoutAmenitiesInput> | VenueCreateWithoutAmenitiesInput[] | VenueUncheckedCreateWithoutAmenitiesInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutAmenitiesInput | VenueCreateOrConnectWithoutAmenitiesInput[]
    upsert?: VenueUpsertWithWhereUniqueWithoutAmenitiesInput | VenueUpsertWithWhereUniqueWithoutAmenitiesInput[]
    set?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    disconnect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    delete?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    update?: VenueUpdateWithWhereUniqueWithoutAmenitiesInput | VenueUpdateWithWhereUniqueWithoutAmenitiesInput[]
    updateMany?: VenueUpdateManyWithWhereWithoutAmenitiesInput | VenueUpdateManyWithWhereWithoutAmenitiesInput[]
    deleteMany?: VenueScalarWhereInput | VenueScalarWhereInput[]
  }

  export type VenueUncheckedUpdateManyWithoutAmenitiesNestedInput = {
    create?: XOR<VenueCreateWithoutAmenitiesInput, VenueUncheckedCreateWithoutAmenitiesInput> | VenueCreateWithoutAmenitiesInput[] | VenueUncheckedCreateWithoutAmenitiesInput[]
    connectOrCreate?: VenueCreateOrConnectWithoutAmenitiesInput | VenueCreateOrConnectWithoutAmenitiesInput[]
    upsert?: VenueUpsertWithWhereUniqueWithoutAmenitiesInput | VenueUpsertWithWhereUniqueWithoutAmenitiesInput[]
    set?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    disconnect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    delete?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    connect?: VenueWhereUniqueInput | VenueWhereUniqueInput[]
    update?: VenueUpdateWithWhereUniqueWithoutAmenitiesInput | VenueUpdateWithWhereUniqueWithoutAmenitiesInput[]
    updateMany?: VenueUpdateManyWithWhereWithoutAmenitiesInput | VenueUpdateManyWithWhereWithoutAmenitiesInput[]
    deleteMany?: VenueScalarWhereInput | VenueScalarWhereInput[]
  }

  export type VenueCreateNestedOneWithoutArrangementsImageInput = {
    create?: XOR<VenueCreateWithoutArrangementsImageInput, VenueUncheckedCreateWithoutArrangementsImageInput>
    connectOrCreate?: VenueCreateOrConnectWithoutArrangementsImageInput
    connect?: VenueWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutImageInput = {
    create?: XOR<ProfileCreateWithoutImageInput, ProfileUncheckedCreateWithoutImageInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutImageInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutCoverPhotoInput = {
    create?: XOR<ProfileCreateWithoutCoverPhotoInput, ProfileUncheckedCreateWithoutCoverPhotoInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutCoverPhotoInput
    connect?: ProfileWhereUniqueInput
  }

  export type EventTypeCreateNestedOneWithoutAvatarInput = {
    create?: XOR<EventTypeCreateWithoutAvatarInput, EventTypeUncheckedCreateWithoutAvatarInput>
    connectOrCreate?: EventTypeCreateOrConnectWithoutAvatarInput
    connect?: EventTypeWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutAssetsInput = {
    create?: XOR<ProfileCreateWithoutAssetsInput, ProfileUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutAssetsInput
    connect?: ProfileWhereUniqueInput
  }

  export type DirectMessageCreateNestedOneWithoutFileInput = {
    create?: XOR<DirectMessageCreateWithoutFileInput, DirectMessageUncheckedCreateWithoutFileInput>
    connectOrCreate?: DirectMessageCreateOrConnectWithoutFileInput
    connect?: DirectMessageWhereUniqueInput
  }

  export type ProfileUncheckedCreateNestedOneWithoutImageInput = {
    create?: XOR<ProfileCreateWithoutImageInput, ProfileUncheckedCreateWithoutImageInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutImageInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileUncheckedCreateNestedOneWithoutCoverPhotoInput = {
    create?: XOR<ProfileCreateWithoutCoverPhotoInput, ProfileUncheckedCreateWithoutCoverPhotoInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutCoverPhotoInput
    connect?: ProfileWhereUniqueInput
  }

  export type EnumFileTypeFieldUpdateOperationsInput = {
    set?: $Enums.FileType
  }

  export type VenueUpdateOneWithoutArrangementsImageNestedInput = {
    create?: XOR<VenueCreateWithoutArrangementsImageInput, VenueUncheckedCreateWithoutArrangementsImageInput>
    connectOrCreate?: VenueCreateOrConnectWithoutArrangementsImageInput
    upsert?: VenueUpsertWithoutArrangementsImageInput
    disconnect?: VenueWhereInput | boolean
    delete?: VenueWhereInput | boolean
    connect?: VenueWhereUniqueInput
    update?: XOR<XOR<VenueUpdateToOneWithWhereWithoutArrangementsImageInput, VenueUpdateWithoutArrangementsImageInput>, VenueUncheckedUpdateWithoutArrangementsImageInput>
  }

  export type ProfileUpdateOneWithoutImageNestedInput = {
    create?: XOR<ProfileCreateWithoutImageInput, ProfileUncheckedCreateWithoutImageInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutImageInput
    upsert?: ProfileUpsertWithoutImageInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutImageInput, ProfileUpdateWithoutImageInput>, ProfileUncheckedUpdateWithoutImageInput>
  }

  export type ProfileUpdateOneWithoutCoverPhotoNestedInput = {
    create?: XOR<ProfileCreateWithoutCoverPhotoInput, ProfileUncheckedCreateWithoutCoverPhotoInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutCoverPhotoInput
    upsert?: ProfileUpsertWithoutCoverPhotoInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutCoverPhotoInput, ProfileUpdateWithoutCoverPhotoInput>, ProfileUncheckedUpdateWithoutCoverPhotoInput>
  }

  export type EventTypeUpdateOneWithoutAvatarNestedInput = {
    create?: XOR<EventTypeCreateWithoutAvatarInput, EventTypeUncheckedCreateWithoutAvatarInput>
    connectOrCreate?: EventTypeCreateOrConnectWithoutAvatarInput
    upsert?: EventTypeUpsertWithoutAvatarInput
    disconnect?: EventTypeWhereInput | boolean
    delete?: EventTypeWhereInput | boolean
    connect?: EventTypeWhereUniqueInput
    update?: XOR<XOR<EventTypeUpdateToOneWithWhereWithoutAvatarInput, EventTypeUpdateWithoutAvatarInput>, EventTypeUncheckedUpdateWithoutAvatarInput>
  }

  export type ProfileUpdateOneWithoutAssetsNestedInput = {
    create?: XOR<ProfileCreateWithoutAssetsInput, ProfileUncheckedCreateWithoutAssetsInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutAssetsInput
    upsert?: ProfileUpsertWithoutAssetsInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutAssetsInput, ProfileUpdateWithoutAssetsInput>, ProfileUncheckedUpdateWithoutAssetsInput>
  }

  export type DirectMessageUpdateOneWithoutFileNestedInput = {
    create?: XOR<DirectMessageCreateWithoutFileInput, DirectMessageUncheckedCreateWithoutFileInput>
    connectOrCreate?: DirectMessageCreateOrConnectWithoutFileInput
    upsert?: DirectMessageUpsertWithoutFileInput
    disconnect?: DirectMessageWhereInput | boolean
    delete?: DirectMessageWhereInput | boolean
    connect?: DirectMessageWhereUniqueInput
    update?: XOR<XOR<DirectMessageUpdateToOneWithWhereWithoutFileInput, DirectMessageUpdateWithoutFileInput>, DirectMessageUncheckedUpdateWithoutFileInput>
  }

  export type ProfileUncheckedUpdateOneWithoutImageNestedInput = {
    create?: XOR<ProfileCreateWithoutImageInput, ProfileUncheckedCreateWithoutImageInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutImageInput
    upsert?: ProfileUpsertWithoutImageInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutImageInput, ProfileUpdateWithoutImageInput>, ProfileUncheckedUpdateWithoutImageInput>
  }

  export type ProfileUncheckedUpdateOneWithoutCoverPhotoNestedInput = {
    create?: XOR<ProfileCreateWithoutCoverPhotoInput, ProfileUncheckedCreateWithoutCoverPhotoInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutCoverPhotoInput
    upsert?: ProfileUpsertWithoutCoverPhotoInput
    disconnect?: ProfileWhereInput | boolean
    delete?: ProfileWhereInput | boolean
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutCoverPhotoInput, ProfileUpdateWithoutCoverPhotoInput>, ProfileUncheckedUpdateWithoutCoverPhotoInput>
  }

  export type ProfileCreateNestedOneWithoutConversationsInitiatedInput = {
    create?: XOR<ProfileCreateWithoutConversationsInitiatedInput, ProfileUncheckedCreateWithoutConversationsInitiatedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutConversationsInitiatedInput
    connect?: ProfileWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutConversationsReceivedInput = {
    create?: XOR<ProfileCreateWithoutConversationsReceivedInput, ProfileUncheckedCreateWithoutConversationsReceivedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutConversationsReceivedInput
    connect?: ProfileWhereUniqueInput
  }

  export type DirectMessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<DirectMessageCreateWithoutConversationInput, DirectMessageUncheckedCreateWithoutConversationInput> | DirectMessageCreateWithoutConversationInput[] | DirectMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutConversationInput | DirectMessageCreateOrConnectWithoutConversationInput[]
    createMany?: DirectMessageCreateManyConversationInputEnvelope
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
  }

  export type DirectMessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<DirectMessageCreateWithoutConversationInput, DirectMessageUncheckedCreateWithoutConversationInput> | DirectMessageCreateWithoutConversationInput[] | DirectMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutConversationInput | DirectMessageCreateOrConnectWithoutConversationInput[]
    createMany?: DirectMessageCreateManyConversationInputEnvelope
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
  }

  export type ProfileUpdateOneRequiredWithoutConversationsInitiatedNestedInput = {
    create?: XOR<ProfileCreateWithoutConversationsInitiatedInput, ProfileUncheckedCreateWithoutConversationsInitiatedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutConversationsInitiatedInput
    upsert?: ProfileUpsertWithoutConversationsInitiatedInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutConversationsInitiatedInput, ProfileUpdateWithoutConversationsInitiatedInput>, ProfileUncheckedUpdateWithoutConversationsInitiatedInput>
  }

  export type ProfileUpdateOneRequiredWithoutConversationsReceivedNestedInput = {
    create?: XOR<ProfileCreateWithoutConversationsReceivedInput, ProfileUncheckedCreateWithoutConversationsReceivedInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutConversationsReceivedInput
    upsert?: ProfileUpsertWithoutConversationsReceivedInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutConversationsReceivedInput, ProfileUpdateWithoutConversationsReceivedInput>, ProfileUncheckedUpdateWithoutConversationsReceivedInput>
  }

  export type DirectMessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<DirectMessageCreateWithoutConversationInput, DirectMessageUncheckedCreateWithoutConversationInput> | DirectMessageCreateWithoutConversationInput[] | DirectMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutConversationInput | DirectMessageCreateOrConnectWithoutConversationInput[]
    upsert?: DirectMessageUpsertWithWhereUniqueWithoutConversationInput | DirectMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: DirectMessageCreateManyConversationInputEnvelope
    set?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    disconnect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    delete?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    update?: DirectMessageUpdateWithWhereUniqueWithoutConversationInput | DirectMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: DirectMessageUpdateManyWithWhereWithoutConversationInput | DirectMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
  }

  export type DirectMessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<DirectMessageCreateWithoutConversationInput, DirectMessageUncheckedCreateWithoutConversationInput> | DirectMessageCreateWithoutConversationInput[] | DirectMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: DirectMessageCreateOrConnectWithoutConversationInput | DirectMessageCreateOrConnectWithoutConversationInput[]
    upsert?: DirectMessageUpsertWithWhereUniqueWithoutConversationInput | DirectMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: DirectMessageCreateManyConversationInputEnvelope
    set?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    disconnect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    delete?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    connect?: DirectMessageWhereUniqueInput | DirectMessageWhereUniqueInput[]
    update?: DirectMessageUpdateWithWhereUniqueWithoutConversationInput | DirectMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: DirectMessageUpdateManyWithWhereWithoutConversationInput | DirectMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
  }

  export type FileInstanceCreateNestedOneWithoutDirectMessageInput = {
    create?: XOR<FileInstanceCreateWithoutDirectMessageInput, FileInstanceUncheckedCreateWithoutDirectMessageInput>
    connectOrCreate?: FileInstanceCreateOrConnectWithoutDirectMessageInput
    connect?: FileInstanceWhereUniqueInput
  }

  export type ProfileCreateNestedOneWithoutDirectMessagesInput = {
    create?: XOR<ProfileCreateWithoutDirectMessagesInput, ProfileUncheckedCreateWithoutDirectMessagesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutDirectMessagesInput
    connect?: ProfileWhereUniqueInput
  }

  export type ConversationCreateNestedOneWithoutDirectMessagesInput = {
    create?: XOR<ConversationCreateWithoutDirectMessagesInput, ConversationUncheckedCreateWithoutDirectMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutDirectMessagesInput
    connect?: ConversationWhereUniqueInput
  }

  export type FileInstanceUncheckedCreateNestedOneWithoutDirectMessageInput = {
    create?: XOR<FileInstanceCreateWithoutDirectMessageInput, FileInstanceUncheckedCreateWithoutDirectMessageInput>
    connectOrCreate?: FileInstanceCreateOrConnectWithoutDirectMessageInput
    connect?: FileInstanceWhereUniqueInput
  }

  export type FileInstanceUpdateOneWithoutDirectMessageNestedInput = {
    create?: XOR<FileInstanceCreateWithoutDirectMessageInput, FileInstanceUncheckedCreateWithoutDirectMessageInput>
    connectOrCreate?: FileInstanceCreateOrConnectWithoutDirectMessageInput
    upsert?: FileInstanceUpsertWithoutDirectMessageInput
    disconnect?: FileInstanceWhereInput | boolean
    delete?: FileInstanceWhereInput | boolean
    connect?: FileInstanceWhereUniqueInput
    update?: XOR<XOR<FileInstanceUpdateToOneWithWhereWithoutDirectMessageInput, FileInstanceUpdateWithoutDirectMessageInput>, FileInstanceUncheckedUpdateWithoutDirectMessageInput>
  }

  export type ProfileUpdateOneRequiredWithoutDirectMessagesNestedInput = {
    create?: XOR<ProfileCreateWithoutDirectMessagesInput, ProfileUncheckedCreateWithoutDirectMessagesInput>
    connectOrCreate?: ProfileCreateOrConnectWithoutDirectMessagesInput
    upsert?: ProfileUpsertWithoutDirectMessagesInput
    connect?: ProfileWhereUniqueInput
    update?: XOR<XOR<ProfileUpdateToOneWithWhereWithoutDirectMessagesInput, ProfileUpdateWithoutDirectMessagesInput>, ProfileUncheckedUpdateWithoutDirectMessagesInput>
  }

  export type ConversationUpdateOneRequiredWithoutDirectMessagesNestedInput = {
    create?: XOR<ConversationCreateWithoutDirectMessagesInput, ConversationUncheckedCreateWithoutDirectMessagesInput>
    connectOrCreate?: ConversationCreateOrConnectWithoutDirectMessagesInput
    upsert?: ConversationUpsertWithoutDirectMessagesInput
    connect?: ConversationWhereUniqueInput
    update?: XOR<XOR<ConversationUpdateToOneWithWhereWithoutDirectMessagesInput, ConversationUpdateWithoutDirectMessagesInput>, ConversationUncheckedUpdateWithoutDirectMessagesInput>
  }

  export type FileInstanceUncheckedUpdateOneWithoutDirectMessageNestedInput = {
    create?: XOR<FileInstanceCreateWithoutDirectMessageInput, FileInstanceUncheckedCreateWithoutDirectMessageInput>
    connectOrCreate?: FileInstanceCreateOrConnectWithoutDirectMessageInput
    upsert?: FileInstanceUpsertWithoutDirectMessageInput
    disconnect?: FileInstanceWhereInput | boolean
    delete?: FileInstanceWhereInput | boolean
    connect?: FileInstanceWhereUniqueInput
    update?: XOR<XOR<FileInstanceUpdateToOneWithWhereWithoutDirectMessageInput, FileInstanceUpdateWithoutDirectMessageInput>, FileInstanceUncheckedUpdateWithoutDirectMessageInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumGenderFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderFilter<$PrismaModel> | $Enums.Gender
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumGenderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel>
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel>
    not?: NestedEnumGenderWithAggregatesFilter<$PrismaModel> | $Enums.Gender
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumGenderFilter<$PrismaModel>
    _max?: NestedEnumGenderFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumVenueTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VenueType | EnumVenueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VenueType[] | ListEnumVenueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VenueType[] | ListEnumVenueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVenueTypeFilter<$PrismaModel> | $Enums.VenueType
  }

  export type NestedEnumBookingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeFilter<$PrismaModel> | $Enums.BookingType
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumVenueTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VenueType | EnumVenueTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VenueType[] | ListEnumVenueTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VenueType[] | ListEnumVenueTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVenueTypeWithAggregatesFilter<$PrismaModel> | $Enums.VenueType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVenueTypeFilter<$PrismaModel>
    _max?: NestedEnumVenueTypeFilter<$PrismaModel>
  }

  export type NestedEnumBookingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingType | EnumBookingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingType[] | ListEnumBookingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingTypeWithAggregatesFilter<$PrismaModel> | $Enums.BookingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingTypeFilter<$PrismaModel>
    _max?: NestedEnumBookingTypeFilter<$PrismaModel>
  }

  export type NestedEnumBookingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusFilter<$PrismaModel> | $Enums.BookingStatus
  }

  export type NestedEnumAcceptanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AcceptanceStatus | EnumAcceptanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AcceptanceStatus[] | ListEnumAcceptanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AcceptanceStatus[] | ListEnumAcceptanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAcceptanceStatusFilter<$PrismaModel> | $Enums.AcceptanceStatus
  }

  export type NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BookingStatus | EnumBookingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BookingStatus[] | ListEnumBookingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBookingStatusWithAggregatesFilter<$PrismaModel> | $Enums.BookingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBookingStatusFilter<$PrismaModel>
    _max?: NestedEnumBookingStatusFilter<$PrismaModel>
  }

  export type NestedEnumAcceptanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AcceptanceStatus | EnumAcceptanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AcceptanceStatus[] | ListEnumAcceptanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AcceptanceStatus[] | ListEnumAcceptanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAcceptanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AcceptanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAcceptanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAcceptanceStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusFilter<$PrismaModel> | $Enums.PaymentStatus
  }

  export type NestedEnumPaymentMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodFilter<$PrismaModel> | $Enums.PaymentMethod
  }

  export type NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentStatus | EnumPaymentStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentStatus[] | ListEnumPaymentStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentStatusWithAggregatesFilter<$PrismaModel> | $Enums.PaymentStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentStatusFilter<$PrismaModel>
    _max?: NestedEnumPaymentStatusFilter<$PrismaModel>
  }

  export type NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentMethodWithAggregatesFilter<$PrismaModel> | $Enums.PaymentMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentMethodFilter<$PrismaModel>
    _max?: NestedEnumPaymentMethodFilter<$PrismaModel>
  }

  export type NestedEnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type NestedEnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type ProfileCreateWithoutUserInput = {
    id?: string
    gender: $Enums.Gender
    location?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    image?: FileInstanceCreateNestedOneWithoutImageOfProfileInput
    eventPreference?: EventTypeCreateNestedManyWithoutProfileInput
    coverPhoto?: FileInstanceCreateNestedOneWithoutCoverPhotoOfProfileInput
    assets?: FileInstanceCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewCreateNestedManyWithoutProfileInput
    venues?: VenueCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutUserInput = {
    id?: string
    gender: $Enums.Gender
    imageId?: string | null
    location?: string | null
    coverPhotoId?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventPreference?: EventTypeUncheckedCreateNestedManyWithoutProfileInput
    assets?: FileInstanceUncheckedCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageUncheckedCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingUncheckedCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProfileInput
    venues?: VenueUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutUserInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
  }

  export type ProfileUpsertWithoutUserInput = {
    update: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
    create: XOR<ProfileCreateWithoutUserInput, ProfileUncheckedCreateWithoutUserInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutUserInput, ProfileUncheckedUpdateWithoutUserInput>
  }

  export type ProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: FileInstanceUpdateOneWithoutImageOfProfileNestedInput
    eventPreference?: EventTypeUpdateManyWithoutProfileNestedInput
    coverPhoto?: FileInstanceUpdateOneWithoutCoverPhotoOfProfileNestedInput
    assets?: FileInstanceUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProfileNestedInput
    venues?: VenueUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoId?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventPreference?: EventTypeUncheckedUpdateManyWithoutProfileNestedInput
    assets?: FileInstanceUncheckedUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUncheckedUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUncheckedUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProfileNestedInput
    venues?: VenueUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type UserCreateWithoutProfileInput = {
    id?: string
    email: string
    phone: string
    password: string
    name: string
    role?: $Enums.UserRole
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateWithoutProfileInput = {
    id?: string
    email: string
    phone: string
    password: string
    name: string
    role?: $Enums.UserRole
    isVerified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserCreateOrConnectWithoutProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
  }

  export type FileInstanceCreateWithoutImageOfProfileInput = {
    id?: string
    name: string
    fileId: string
    path: string
    createdAt?: Date | string
    expiresAt: Date | string
    bucket: string
    type: $Enums.FileType
    Venue?: VenueCreateNestedOneWithoutArrangementsImageInput
    coverPhotoOfProfile?: ProfileCreateNestedOneWithoutCoverPhotoInput
    EventPreference?: EventTypeCreateNestedOneWithoutAvatarInput
    Profile?: ProfileCreateNestedOneWithoutAssetsInput
    DirectMessage?: DirectMessageCreateNestedOneWithoutFileInput
  }

  export type FileInstanceUncheckedCreateWithoutImageOfProfileInput = {
    id?: string
    name: string
    fileId: string
    path: string
    createdAt?: Date | string
    expiresAt: Date | string
    bucket: string
    type: $Enums.FileType
    venueId?: string | null
    eventPreferenceId?: string | null
    profileId?: string | null
    directMessageId?: string | null
    coverPhotoOfProfile?: ProfileUncheckedCreateNestedOneWithoutCoverPhotoInput
  }

  export type FileInstanceCreateOrConnectWithoutImageOfProfileInput = {
    where: FileInstanceWhereUniqueInput
    create: XOR<FileInstanceCreateWithoutImageOfProfileInput, FileInstanceUncheckedCreateWithoutImageOfProfileInput>
  }

  export type EventTypeCreateWithoutProfileInput = {
    id?: string
    name: string
    avatar?: FileInstanceCreateNestedOneWithoutEventPreferenceInput
    Booking?: BookingCreateNestedOneWithoutEventTypeInput
  }

  export type EventTypeUncheckedCreateWithoutProfileInput = {
    id?: string
    name: string
    bookingId: string
    avatar?: FileInstanceUncheckedCreateNestedOneWithoutEventPreferenceInput
  }

  export type EventTypeCreateOrConnectWithoutProfileInput = {
    where: EventTypeWhereUniqueInput
    create: XOR<EventTypeCreateWithoutProfileInput, EventTypeUncheckedCreateWithoutProfileInput>
  }

  export type FileInstanceCreateWithoutCoverPhotoOfProfileInput = {
    id?: string
    name: string
    fileId: string
    path: string
    createdAt?: Date | string
    expiresAt: Date | string
    bucket: string
    type: $Enums.FileType
    Venue?: VenueCreateNestedOneWithoutArrangementsImageInput
    imageOfProfile?: ProfileCreateNestedOneWithoutImageInput
    EventPreference?: EventTypeCreateNestedOneWithoutAvatarInput
    Profile?: ProfileCreateNestedOneWithoutAssetsInput
    DirectMessage?: DirectMessageCreateNestedOneWithoutFileInput
  }

  export type FileInstanceUncheckedCreateWithoutCoverPhotoOfProfileInput = {
    id?: string
    name: string
    fileId: string
    path: string
    createdAt?: Date | string
    expiresAt: Date | string
    bucket: string
    type: $Enums.FileType
    venueId?: string | null
    eventPreferenceId?: string | null
    profileId?: string | null
    directMessageId?: string | null
    imageOfProfile?: ProfileUncheckedCreateNestedOneWithoutImageInput
  }

  export type FileInstanceCreateOrConnectWithoutCoverPhotoOfProfileInput = {
    where: FileInstanceWhereUniqueInput
    create: XOR<FileInstanceCreateWithoutCoverPhotoOfProfileInput, FileInstanceUncheckedCreateWithoutCoverPhotoOfProfileInput>
  }

  export type FileInstanceCreateWithoutProfileInput = {
    id?: string
    name: string
    fileId: string
    path: string
    createdAt?: Date | string
    expiresAt: Date | string
    bucket: string
    type: $Enums.FileType
    Venue?: VenueCreateNestedOneWithoutArrangementsImageInput
    imageOfProfile?: ProfileCreateNestedOneWithoutImageInput
    coverPhotoOfProfile?: ProfileCreateNestedOneWithoutCoverPhotoInput
    EventPreference?: EventTypeCreateNestedOneWithoutAvatarInput
    DirectMessage?: DirectMessageCreateNestedOneWithoutFileInput
  }

  export type FileInstanceUncheckedCreateWithoutProfileInput = {
    id?: string
    name: string
    fileId: string
    path: string
    createdAt?: Date | string
    expiresAt: Date | string
    bucket: string
    type: $Enums.FileType
    venueId?: string | null
    eventPreferenceId?: string | null
    directMessageId?: string | null
    imageOfProfile?: ProfileUncheckedCreateNestedOneWithoutImageInput
    coverPhotoOfProfile?: ProfileUncheckedCreateNestedOneWithoutCoverPhotoInput
  }

  export type FileInstanceCreateOrConnectWithoutProfileInput = {
    where: FileInstanceWhereUniqueInput
    create: XOR<FileInstanceCreateWithoutProfileInput, FileInstanceUncheckedCreateWithoutProfileInput>
  }

  export type FileInstanceCreateManyProfileInputEnvelope = {
    data: FileInstanceCreateManyProfileInput | FileInstanceCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type DirectMessageCreateWithoutMemberInput = {
    id?: string
    content: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    file?: FileInstanceCreateNestedOneWithoutDirectMessageInput
    conversation: ConversationCreateNestedOneWithoutDirectMessagesInput
  }

  export type DirectMessageUncheckedCreateWithoutMemberInput = {
    id?: string
    content: string
    conversationId: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    file?: FileInstanceUncheckedCreateNestedOneWithoutDirectMessageInput
  }

  export type DirectMessageCreateOrConnectWithoutMemberInput = {
    where: DirectMessageWhereUniqueInput
    create: XOR<DirectMessageCreateWithoutMemberInput, DirectMessageUncheckedCreateWithoutMemberInput>
  }

  export type DirectMessageCreateManyMemberInputEnvelope = {
    data: DirectMessageCreateManyMemberInput | DirectMessageCreateManyMemberInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutMemberOneInput = {
    id?: string
    memberTwo: ProfileCreateNestedOneWithoutConversationsReceivedInput
    directMessages?: DirectMessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMemberOneInput = {
    id?: string
    memberTwoId: string
    directMessages?: DirectMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMemberOneInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMemberOneInput, ConversationUncheckedCreateWithoutMemberOneInput>
  }

  export type ConversationCreateManyMemberOneInputEnvelope = {
    data: ConversationCreateManyMemberOneInput | ConversationCreateManyMemberOneInput[]
    skipDuplicates?: boolean
  }

  export type ConversationCreateWithoutMemberTwoInput = {
    id?: string
    memberOne: ProfileCreateNestedOneWithoutConversationsInitiatedInput
    directMessages?: DirectMessageCreateNestedManyWithoutConversationInput
  }

  export type ConversationUncheckedCreateWithoutMemberTwoInput = {
    id?: string
    memberOneId: string
    directMessages?: DirectMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type ConversationCreateOrConnectWithoutMemberTwoInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutMemberTwoInput, ConversationUncheckedCreateWithoutMemberTwoInput>
  }

  export type ConversationCreateManyMemberTwoInputEnvelope = {
    data: ConversationCreateManyMemberTwoInput | ConversationCreateManyMemberTwoInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutBookedByInput = {
    id?: string
    eventName: string
    location: string
    plannerName: string
    selectedDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    bookingType: $Enums.BookingType
    guestNumber: number
    decoration?: string | null
    services?: BookingCreateservicesInput | string[]
    totalCost: number
    bookingStatus?: $Enums.BookingStatus
    totalAmount?: number
    paid?: number
    due?: number
    accept: $Enums.AcceptanceStatus
    isEventFinished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    venue?: VenueCreateNestedOneWithoutBookingsInput
    serviceProvider?: ProfileCreateNestedOneWithoutBookingToServiceProviderInput
    eventType?: EventTypeCreateNestedOneWithoutBookingInput
    payment?: PaymentCreateNestedManyWithoutBookingInfoInput
  }

  export type BookingUncheckedCreateWithoutBookedByInput = {
    id?: string
    venueId?: string | null
    serviceProviderId?: string | null
    eventName: string
    location: string
    plannerName: string
    selectedDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    bookingType: $Enums.BookingType
    guestNumber: number
    decoration?: string | null
    services?: BookingCreateservicesInput | string[]
    totalCost: number
    bookingStatus?: $Enums.BookingStatus
    totalAmount?: number
    paid?: number
    due?: number
    accept: $Enums.AcceptanceStatus
    isEventFinished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType?: EventTypeUncheckedCreateNestedOneWithoutBookingInput
    payment?: PaymentUncheckedCreateNestedManyWithoutBookingInfoInput
  }

  export type BookingCreateOrConnectWithoutBookedByInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutBookedByInput, BookingUncheckedCreateWithoutBookedByInput>
  }

  export type BookingCreateManyBookedByInputEnvelope = {
    data: BookingCreateManyBookedByInput | BookingCreateManyBookedByInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutServiceProviderInput = {
    id?: string
    eventName: string
    location: string
    plannerName: string
    selectedDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    bookingType: $Enums.BookingType
    guestNumber: number
    decoration?: string | null
    services?: BookingCreateservicesInput | string[]
    totalCost: number
    bookingStatus?: $Enums.BookingStatus
    totalAmount?: number
    paid?: number
    due?: number
    accept: $Enums.AcceptanceStatus
    isEventFinished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookedBy: ProfileCreateNestedOneWithoutBookingToVenueInput
    venue?: VenueCreateNestedOneWithoutBookingsInput
    eventType?: EventTypeCreateNestedOneWithoutBookingInput
    payment?: PaymentCreateNestedManyWithoutBookingInfoInput
  }

  export type BookingUncheckedCreateWithoutServiceProviderInput = {
    id?: string
    bookedById: string
    venueId?: string | null
    eventName: string
    location: string
    plannerName: string
    selectedDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    bookingType: $Enums.BookingType
    guestNumber: number
    decoration?: string | null
    services?: BookingCreateservicesInput | string[]
    totalCost: number
    bookingStatus?: $Enums.BookingStatus
    totalAmount?: number
    paid?: number
    due?: number
    accept: $Enums.AcceptanceStatus
    isEventFinished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType?: EventTypeUncheckedCreateNestedOneWithoutBookingInput
    payment?: PaymentUncheckedCreateNestedManyWithoutBookingInfoInput
  }

  export type BookingCreateOrConnectWithoutServiceProviderInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutServiceProviderInput, BookingUncheckedCreateWithoutServiceProviderInput>
  }

  export type BookingCreateManyServiceProviderInputEnvelope = {
    data: BookingCreateManyServiceProviderInput | BookingCreateManyServiceProviderInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutProfileInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    Venue: VenueCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutProfileInput = {
    id?: string
    venueId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type ReviewCreateOrConnectWithoutProfileInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutProfileInput, ReviewUncheckedCreateWithoutProfileInput>
  }

  export type ReviewCreateManyProfileInputEnvelope = {
    data: ReviewCreateManyProfileInput | ReviewCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type VenueCreateWithoutProfileInput = {
    id?: string
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    amenities?: AmenitiesCreateNestedManyWithoutVenueInput
    arrangementsImage?: FileInstanceCreateNestedOneWithoutVenueInput
    shifts?: ShiftCreateNestedManyWithoutVenueInput
    reviews?: ReviewCreateNestedManyWithoutVenueInput
    decoration?: DecorationCreateNestedOneWithoutVenueInput
    employees?: EmployeeCreateNestedManyWithoutVenueInput
    bookings?: BookingCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutProfileInput = {
    id?: string
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutVenueInput
    arrangementsImage?: FileInstanceUncheckedCreateNestedOneWithoutVenueInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutVenueInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutVenueInput
    decoration?: DecorationUncheckedCreateNestedOneWithoutVenueInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutVenueInput
    bookings?: BookingUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutProfileInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutProfileInput, VenueUncheckedCreateWithoutProfileInput>
  }

  export type VenueCreateManyProfileInputEnvelope = {
    data: VenueCreateManyProfileInput | VenueCreateManyProfileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProfileInput = {
    update: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
    create: XOR<UserCreateWithoutProfileInput, UserUncheckedCreateWithoutProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProfileInput, UserUncheckedUpdateWithoutProfileInput>
  }

  export type UserUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileInstanceUpsertWithoutImageOfProfileInput = {
    update: XOR<FileInstanceUpdateWithoutImageOfProfileInput, FileInstanceUncheckedUpdateWithoutImageOfProfileInput>
    create: XOR<FileInstanceCreateWithoutImageOfProfileInput, FileInstanceUncheckedCreateWithoutImageOfProfileInput>
    where?: FileInstanceWhereInput
  }

  export type FileInstanceUpdateToOneWithWhereWithoutImageOfProfileInput = {
    where?: FileInstanceWhereInput
    data: XOR<FileInstanceUpdateWithoutImageOfProfileInput, FileInstanceUncheckedUpdateWithoutImageOfProfileInput>
  }

  export type FileInstanceUpdateWithoutImageOfProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    Venue?: VenueUpdateOneWithoutArrangementsImageNestedInput
    coverPhotoOfProfile?: ProfileUpdateOneWithoutCoverPhotoNestedInput
    EventPreference?: EventTypeUpdateOneWithoutAvatarNestedInput
    Profile?: ProfileUpdateOneWithoutAssetsNestedInput
    DirectMessage?: DirectMessageUpdateOneWithoutFileNestedInput
  }

  export type FileInstanceUncheckedUpdateWithoutImageOfProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    eventPreferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    directMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoOfProfile?: ProfileUncheckedUpdateOneWithoutCoverPhotoNestedInput
  }

  export type EventTypeUpsertWithWhereUniqueWithoutProfileInput = {
    where: EventTypeWhereUniqueInput
    update: XOR<EventTypeUpdateWithoutProfileInput, EventTypeUncheckedUpdateWithoutProfileInput>
    create: XOR<EventTypeCreateWithoutProfileInput, EventTypeUncheckedCreateWithoutProfileInput>
  }

  export type EventTypeUpdateWithWhereUniqueWithoutProfileInput = {
    where: EventTypeWhereUniqueInput
    data: XOR<EventTypeUpdateWithoutProfileInput, EventTypeUncheckedUpdateWithoutProfileInput>
  }

  export type EventTypeUpdateManyWithWhereWithoutProfileInput = {
    where: EventTypeScalarWhereInput
    data: XOR<EventTypeUpdateManyMutationInput, EventTypeUncheckedUpdateManyWithoutProfileInput>
  }

  export type EventTypeScalarWhereInput = {
    AND?: EventTypeScalarWhereInput | EventTypeScalarWhereInput[]
    OR?: EventTypeScalarWhereInput[]
    NOT?: EventTypeScalarWhereInput | EventTypeScalarWhereInput[]
    id?: StringFilter<"EventType"> | string
    name?: StringFilter<"EventType"> | string
    bookingId?: StringFilter<"EventType"> | string
  }

  export type FileInstanceUpsertWithoutCoverPhotoOfProfileInput = {
    update: XOR<FileInstanceUpdateWithoutCoverPhotoOfProfileInput, FileInstanceUncheckedUpdateWithoutCoverPhotoOfProfileInput>
    create: XOR<FileInstanceCreateWithoutCoverPhotoOfProfileInput, FileInstanceUncheckedCreateWithoutCoverPhotoOfProfileInput>
    where?: FileInstanceWhereInput
  }

  export type FileInstanceUpdateToOneWithWhereWithoutCoverPhotoOfProfileInput = {
    where?: FileInstanceWhereInput
    data: XOR<FileInstanceUpdateWithoutCoverPhotoOfProfileInput, FileInstanceUncheckedUpdateWithoutCoverPhotoOfProfileInput>
  }

  export type FileInstanceUpdateWithoutCoverPhotoOfProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    Venue?: VenueUpdateOneWithoutArrangementsImageNestedInput
    imageOfProfile?: ProfileUpdateOneWithoutImageNestedInput
    EventPreference?: EventTypeUpdateOneWithoutAvatarNestedInput
    Profile?: ProfileUpdateOneWithoutAssetsNestedInput
    DirectMessage?: DirectMessageUpdateOneWithoutFileNestedInput
  }

  export type FileInstanceUncheckedUpdateWithoutCoverPhotoOfProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    eventPreferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    directMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    imageOfProfile?: ProfileUncheckedUpdateOneWithoutImageNestedInput
  }

  export type FileInstanceUpsertWithWhereUniqueWithoutProfileInput = {
    where: FileInstanceWhereUniqueInput
    update: XOR<FileInstanceUpdateWithoutProfileInput, FileInstanceUncheckedUpdateWithoutProfileInput>
    create: XOR<FileInstanceCreateWithoutProfileInput, FileInstanceUncheckedCreateWithoutProfileInput>
  }

  export type FileInstanceUpdateWithWhereUniqueWithoutProfileInput = {
    where: FileInstanceWhereUniqueInput
    data: XOR<FileInstanceUpdateWithoutProfileInput, FileInstanceUncheckedUpdateWithoutProfileInput>
  }

  export type FileInstanceUpdateManyWithWhereWithoutProfileInput = {
    where: FileInstanceScalarWhereInput
    data: XOR<FileInstanceUpdateManyMutationInput, FileInstanceUncheckedUpdateManyWithoutProfileInput>
  }

  export type FileInstanceScalarWhereInput = {
    AND?: FileInstanceScalarWhereInput | FileInstanceScalarWhereInput[]
    OR?: FileInstanceScalarWhereInput[]
    NOT?: FileInstanceScalarWhereInput | FileInstanceScalarWhereInput[]
    id?: StringFilter<"FileInstance"> | string
    name?: StringFilter<"FileInstance"> | string
    fileId?: StringFilter<"FileInstance"> | string
    path?: StringFilter<"FileInstance"> | string
    createdAt?: DateTimeFilter<"FileInstance"> | Date | string
    expiresAt?: DateTimeFilter<"FileInstance"> | Date | string
    bucket?: StringFilter<"FileInstance"> | string
    type?: EnumFileTypeFilter<"FileInstance"> | $Enums.FileType
    venueId?: StringNullableFilter<"FileInstance"> | string | null
    eventPreferenceId?: StringNullableFilter<"FileInstance"> | string | null
    profileId?: StringNullableFilter<"FileInstance"> | string | null
    directMessageId?: StringNullableFilter<"FileInstance"> | string | null
  }

  export type DirectMessageUpsertWithWhereUniqueWithoutMemberInput = {
    where: DirectMessageWhereUniqueInput
    update: XOR<DirectMessageUpdateWithoutMemberInput, DirectMessageUncheckedUpdateWithoutMemberInput>
    create: XOR<DirectMessageCreateWithoutMemberInput, DirectMessageUncheckedCreateWithoutMemberInput>
  }

  export type DirectMessageUpdateWithWhereUniqueWithoutMemberInput = {
    where: DirectMessageWhereUniqueInput
    data: XOR<DirectMessageUpdateWithoutMemberInput, DirectMessageUncheckedUpdateWithoutMemberInput>
  }

  export type DirectMessageUpdateManyWithWhereWithoutMemberInput = {
    where: DirectMessageScalarWhereInput
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyWithoutMemberInput>
  }

  export type DirectMessageScalarWhereInput = {
    AND?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
    OR?: DirectMessageScalarWhereInput[]
    NOT?: DirectMessageScalarWhereInput | DirectMessageScalarWhereInput[]
    id?: StringFilter<"DirectMessage"> | string
    content?: StringFilter<"DirectMessage"> | string
    memberId?: StringFilter<"DirectMessage"> | string
    conversationId?: StringFilter<"DirectMessage"> | string
    deleted?: BoolFilter<"DirectMessage"> | boolean
    createdAt?: DateTimeFilter<"DirectMessage"> | Date | string
    updatedAt?: DateTimeFilter<"DirectMessage"> | Date | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutMemberOneInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutMemberOneInput, ConversationUncheckedUpdateWithoutMemberOneInput>
    create: XOR<ConversationCreateWithoutMemberOneInput, ConversationUncheckedCreateWithoutMemberOneInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutMemberOneInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutMemberOneInput, ConversationUncheckedUpdateWithoutMemberOneInput>
  }

  export type ConversationUpdateManyWithWhereWithoutMemberOneInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutMemberOneInput>
  }

  export type ConversationScalarWhereInput = {
    AND?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    OR?: ConversationScalarWhereInput[]
    NOT?: ConversationScalarWhereInput | ConversationScalarWhereInput[]
    id?: StringFilter<"Conversation"> | string
    memberOneId?: StringFilter<"Conversation"> | string
    memberTwoId?: StringFilter<"Conversation"> | string
  }

  export type ConversationUpsertWithWhereUniqueWithoutMemberTwoInput = {
    where: ConversationWhereUniqueInput
    update: XOR<ConversationUpdateWithoutMemberTwoInput, ConversationUncheckedUpdateWithoutMemberTwoInput>
    create: XOR<ConversationCreateWithoutMemberTwoInput, ConversationUncheckedCreateWithoutMemberTwoInput>
  }

  export type ConversationUpdateWithWhereUniqueWithoutMemberTwoInput = {
    where: ConversationWhereUniqueInput
    data: XOR<ConversationUpdateWithoutMemberTwoInput, ConversationUncheckedUpdateWithoutMemberTwoInput>
  }

  export type ConversationUpdateManyWithWhereWithoutMemberTwoInput = {
    where: ConversationScalarWhereInput
    data: XOR<ConversationUpdateManyMutationInput, ConversationUncheckedUpdateManyWithoutMemberTwoInput>
  }

  export type BookingUpsertWithWhereUniqueWithoutBookedByInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutBookedByInput, BookingUncheckedUpdateWithoutBookedByInput>
    create: XOR<BookingCreateWithoutBookedByInput, BookingUncheckedCreateWithoutBookedByInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutBookedByInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutBookedByInput, BookingUncheckedUpdateWithoutBookedByInput>
  }

  export type BookingUpdateManyWithWhereWithoutBookedByInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutBookedByInput>
  }

  export type BookingScalarWhereInput = {
    AND?: BookingScalarWhereInput | BookingScalarWhereInput[]
    OR?: BookingScalarWhereInput[]
    NOT?: BookingScalarWhereInput | BookingScalarWhereInput[]
    id?: StringFilter<"Booking"> | string
    bookedById?: StringFilter<"Booking"> | string
    venueId?: StringNullableFilter<"Booking"> | string | null
    serviceProviderId?: StringNullableFilter<"Booking"> | string | null
    eventName?: StringFilter<"Booking"> | string
    location?: StringFilter<"Booking"> | string
    plannerName?: StringFilter<"Booking"> | string
    selectedDate?: DateTimeFilter<"Booking"> | Date | string
    startTime?: DateTimeFilter<"Booking"> | Date | string
    endTime?: DateTimeFilter<"Booking"> | Date | string
    duration?: IntFilter<"Booking"> | number
    bookingType?: EnumBookingTypeFilter<"Booking"> | $Enums.BookingType
    guestNumber?: IntFilter<"Booking"> | number
    decoration?: StringNullableFilter<"Booking"> | string | null
    services?: StringNullableListFilter<"Booking">
    totalCost?: IntFilter<"Booking"> | number
    bookingStatus?: EnumBookingStatusFilter<"Booking"> | $Enums.BookingStatus
    totalAmount?: IntFilter<"Booking"> | number
    paid?: IntFilter<"Booking"> | number
    due?: IntFilter<"Booking"> | number
    accept?: EnumAcceptanceStatusFilter<"Booking"> | $Enums.AcceptanceStatus
    isEventFinished?: BoolFilter<"Booking"> | boolean
    createdAt?: DateTimeFilter<"Booking"> | Date | string
    updatedAt?: DateTimeFilter<"Booking"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutServiceProviderInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutServiceProviderInput, BookingUncheckedUpdateWithoutServiceProviderInput>
    create: XOR<BookingCreateWithoutServiceProviderInput, BookingUncheckedCreateWithoutServiceProviderInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutServiceProviderInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutServiceProviderInput, BookingUncheckedUpdateWithoutServiceProviderInput>
  }

  export type BookingUpdateManyWithWhereWithoutServiceProviderInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutServiceProviderInput>
  }

  export type ReviewUpsertWithWhereUniqueWithoutProfileInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutProfileInput, ReviewUncheckedUpdateWithoutProfileInput>
    create: XOR<ReviewCreateWithoutProfileInput, ReviewUncheckedCreateWithoutProfileInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutProfileInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutProfileInput, ReviewUncheckedUpdateWithoutProfileInput>
  }

  export type ReviewUpdateManyWithWhereWithoutProfileInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutProfileInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    venueId?: StringFilter<"Review"> | string
    rating?: IntFilter<"Review"> | number
    comment?: StringNullableFilter<"Review"> | string | null
    createdAt?: DateTimeFilter<"Review"> | Date | string
    profileId?: StringNullableFilter<"Review"> | string | null
  }

  export type VenueUpsertWithWhereUniqueWithoutProfileInput = {
    where: VenueWhereUniqueInput
    update: XOR<VenueUpdateWithoutProfileInput, VenueUncheckedUpdateWithoutProfileInput>
    create: XOR<VenueCreateWithoutProfileInput, VenueUncheckedCreateWithoutProfileInput>
  }

  export type VenueUpdateWithWhereUniqueWithoutProfileInput = {
    where: VenueWhereUniqueInput
    data: XOR<VenueUpdateWithoutProfileInput, VenueUncheckedUpdateWithoutProfileInput>
  }

  export type VenueUpdateManyWithWhereWithoutProfileInput = {
    where: VenueScalarWhereInput
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyWithoutProfileInput>
  }

  export type VenueScalarWhereInput = {
    AND?: VenueScalarWhereInput | VenueScalarWhereInput[]
    OR?: VenueScalarWhereInput[]
    NOT?: VenueScalarWhereInput | VenueScalarWhereInput[]
    id?: StringFilter<"Venue"> | string
    profileId?: StringNullableFilter<"Venue"> | string | null
    name?: StringFilter<"Venue"> | string
    city?: StringFilter<"Venue"> | string
    area?: StringFilter<"Venue"> | string
    description?: StringNullableFilter<"Venue"> | string | null
    capacity?: IntFilter<"Venue"> | number
    bookedDates?: DateTimeNullableListFilter<"Venue">
    type?: EnumVenueTypeFilter<"Venue"> | $Enums.VenueType
    cateringDescription?: StringNullableFilter<"Venue"> | string | null
    parkingDescription?: StringNullableFilter<"Venue"> | string | null
    availabilityDescription?: StringNullableFilter<"Venue"> | string | null
    extraServiceDescription?: StringNullableFilter<"Venue"> | string | null
    price?: IntFilter<"Venue"> | number
    bookingType?: EnumBookingTypeFilter<"Venue"> | $Enums.BookingType
    verified?: BoolFilter<"Venue"> | boolean
    createdAt?: DateTimeFilter<"Venue"> | Date | string
    updatedAt?: DateTimeFilter<"Venue"> | Date | string
  }

  export type FileInstanceCreateWithoutEventPreferenceInput = {
    id?: string
    name: string
    fileId: string
    path: string
    createdAt?: Date | string
    expiresAt: Date | string
    bucket: string
    type: $Enums.FileType
    Venue?: VenueCreateNestedOneWithoutArrangementsImageInput
    imageOfProfile?: ProfileCreateNestedOneWithoutImageInput
    coverPhotoOfProfile?: ProfileCreateNestedOneWithoutCoverPhotoInput
    Profile?: ProfileCreateNestedOneWithoutAssetsInput
    DirectMessage?: DirectMessageCreateNestedOneWithoutFileInput
  }

  export type FileInstanceUncheckedCreateWithoutEventPreferenceInput = {
    id?: string
    name: string
    fileId: string
    path: string
    createdAt?: Date | string
    expiresAt: Date | string
    bucket: string
    type: $Enums.FileType
    venueId?: string | null
    profileId?: string | null
    directMessageId?: string | null
    imageOfProfile?: ProfileUncheckedCreateNestedOneWithoutImageInput
    coverPhotoOfProfile?: ProfileUncheckedCreateNestedOneWithoutCoverPhotoInput
  }

  export type FileInstanceCreateOrConnectWithoutEventPreferenceInput = {
    where: FileInstanceWhereUniqueInput
    create: XOR<FileInstanceCreateWithoutEventPreferenceInput, FileInstanceUncheckedCreateWithoutEventPreferenceInput>
  }

  export type ProfileCreateWithoutEventPreferenceInput = {
    id?: string
    gender: $Enums.Gender
    location?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    image?: FileInstanceCreateNestedOneWithoutImageOfProfileInput
    coverPhoto?: FileInstanceCreateNestedOneWithoutCoverPhotoOfProfileInput
    assets?: FileInstanceCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewCreateNestedManyWithoutProfileInput
    venues?: VenueCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutEventPreferenceInput = {
    id?: string
    userId: string
    gender: $Enums.Gender
    imageId?: string | null
    location?: string | null
    coverPhotoId?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    assets?: FileInstanceUncheckedCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageUncheckedCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingUncheckedCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProfileInput
    venues?: VenueUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutEventPreferenceInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutEventPreferenceInput, ProfileUncheckedCreateWithoutEventPreferenceInput>
  }

  export type BookingCreateWithoutEventTypeInput = {
    id?: string
    eventName: string
    location: string
    plannerName: string
    selectedDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    bookingType: $Enums.BookingType
    guestNumber: number
    decoration?: string | null
    services?: BookingCreateservicesInput | string[]
    totalCost: number
    bookingStatus?: $Enums.BookingStatus
    totalAmount?: number
    paid?: number
    due?: number
    accept: $Enums.AcceptanceStatus
    isEventFinished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookedBy: ProfileCreateNestedOneWithoutBookingToVenueInput
    venue?: VenueCreateNestedOneWithoutBookingsInput
    serviceProvider?: ProfileCreateNestedOneWithoutBookingToServiceProviderInput
    payment?: PaymentCreateNestedManyWithoutBookingInfoInput
  }

  export type BookingUncheckedCreateWithoutEventTypeInput = {
    id?: string
    bookedById: string
    venueId?: string | null
    serviceProviderId?: string | null
    eventName: string
    location: string
    plannerName: string
    selectedDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    bookingType: $Enums.BookingType
    guestNumber: number
    decoration?: string | null
    services?: BookingCreateservicesInput | string[]
    totalCost: number
    bookingStatus?: $Enums.BookingStatus
    totalAmount?: number
    paid?: number
    due?: number
    accept: $Enums.AcceptanceStatus
    isEventFinished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    payment?: PaymentUncheckedCreateNestedManyWithoutBookingInfoInput
  }

  export type BookingCreateOrConnectWithoutEventTypeInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutEventTypeInput, BookingUncheckedCreateWithoutEventTypeInput>
  }

  export type FileInstanceUpsertWithoutEventPreferenceInput = {
    update: XOR<FileInstanceUpdateWithoutEventPreferenceInput, FileInstanceUncheckedUpdateWithoutEventPreferenceInput>
    create: XOR<FileInstanceCreateWithoutEventPreferenceInput, FileInstanceUncheckedCreateWithoutEventPreferenceInput>
    where?: FileInstanceWhereInput
  }

  export type FileInstanceUpdateToOneWithWhereWithoutEventPreferenceInput = {
    where?: FileInstanceWhereInput
    data: XOR<FileInstanceUpdateWithoutEventPreferenceInput, FileInstanceUncheckedUpdateWithoutEventPreferenceInput>
  }

  export type FileInstanceUpdateWithoutEventPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    Venue?: VenueUpdateOneWithoutArrangementsImageNestedInput
    imageOfProfile?: ProfileUpdateOneWithoutImageNestedInput
    coverPhotoOfProfile?: ProfileUpdateOneWithoutCoverPhotoNestedInput
    Profile?: ProfileUpdateOneWithoutAssetsNestedInput
    DirectMessage?: DirectMessageUpdateOneWithoutFileNestedInput
  }

  export type FileInstanceUncheckedUpdateWithoutEventPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    directMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    imageOfProfile?: ProfileUncheckedUpdateOneWithoutImageNestedInput
    coverPhotoOfProfile?: ProfileUncheckedUpdateOneWithoutCoverPhotoNestedInput
  }

  export type ProfileUpsertWithWhereUniqueWithoutEventPreferenceInput = {
    where: ProfileWhereUniqueInput
    update: XOR<ProfileUpdateWithoutEventPreferenceInput, ProfileUncheckedUpdateWithoutEventPreferenceInput>
    create: XOR<ProfileCreateWithoutEventPreferenceInput, ProfileUncheckedCreateWithoutEventPreferenceInput>
  }

  export type ProfileUpdateWithWhereUniqueWithoutEventPreferenceInput = {
    where: ProfileWhereUniqueInput
    data: XOR<ProfileUpdateWithoutEventPreferenceInput, ProfileUncheckedUpdateWithoutEventPreferenceInput>
  }

  export type ProfileUpdateManyWithWhereWithoutEventPreferenceInput = {
    where: ProfileScalarWhereInput
    data: XOR<ProfileUpdateManyMutationInput, ProfileUncheckedUpdateManyWithoutEventPreferenceInput>
  }

  export type ProfileScalarWhereInput = {
    AND?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    OR?: ProfileScalarWhereInput[]
    NOT?: ProfileScalarWhereInput | ProfileScalarWhereInput[]
    id?: StringFilter<"Profile"> | string
    userId?: StringFilter<"Profile"> | string
    gender?: EnumGenderFilter<"Profile"> | $Enums.Gender
    imageId?: StringNullableFilter<"Profile"> | string | null
    location?: StringNullableFilter<"Profile"> | string | null
    coverPhotoId?: StringNullableFilter<"Profile"> | string | null
    profession?: StringNullableFilter<"Profile"> | string | null
    description?: StringNullableFilter<"Profile"> | string | null
    experience?: IntNullableFilter<"Profile"> | number | null
    createdAt?: DateTimeFilter<"Profile"> | Date | string
    updatedAt?: DateTimeFilter<"Profile"> | Date | string
  }

  export type BookingUpsertWithoutEventTypeInput = {
    update: XOR<BookingUpdateWithoutEventTypeInput, BookingUncheckedUpdateWithoutEventTypeInput>
    create: XOR<BookingCreateWithoutEventTypeInput, BookingUncheckedCreateWithoutEventTypeInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutEventTypeInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutEventTypeInput, BookingUncheckedUpdateWithoutEventTypeInput>
  }

  export type BookingUpdateWithoutEventTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    plannerName?: StringFieldUpdateOperationsInput | string
    selectedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    guestNumber?: IntFieldUpdateOperationsInput | number
    decoration?: NullableStringFieldUpdateOperationsInput | string | null
    services?: BookingUpdateservicesInput | string[]
    totalCost?: IntFieldUpdateOperationsInput | number
    bookingStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    due?: IntFieldUpdateOperationsInput | number
    accept?: EnumAcceptanceStatusFieldUpdateOperationsInput | $Enums.AcceptanceStatus
    isEventFinished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedBy?: ProfileUpdateOneRequiredWithoutBookingToVenueNestedInput
    venue?: VenueUpdateOneWithoutBookingsNestedInput
    serviceProvider?: ProfileUpdateOneWithoutBookingToServiceProviderNestedInput
    payment?: PaymentUpdateManyWithoutBookingInfoNestedInput
  }

  export type BookingUncheckedUpdateWithoutEventTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookedById?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    plannerName?: StringFieldUpdateOperationsInput | string
    selectedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    guestNumber?: IntFieldUpdateOperationsInput | number
    decoration?: NullableStringFieldUpdateOperationsInput | string | null
    services?: BookingUpdateservicesInput | string[]
    totalCost?: IntFieldUpdateOperationsInput | number
    bookingStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    due?: IntFieldUpdateOperationsInput | number
    accept?: EnumAcceptanceStatusFieldUpdateOperationsInput | $Enums.AcceptanceStatus
    isEventFinished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateManyWithoutBookingInfoNestedInput
  }

  export type ProfileCreateWithoutVenuesInput = {
    id?: string
    gender: $Enums.Gender
    location?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    image?: FileInstanceCreateNestedOneWithoutImageOfProfileInput
    eventPreference?: EventTypeCreateNestedManyWithoutProfileInput
    coverPhoto?: FileInstanceCreateNestedOneWithoutCoverPhotoOfProfileInput
    assets?: FileInstanceCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutVenuesInput = {
    id?: string
    userId: string
    gender: $Enums.Gender
    imageId?: string | null
    location?: string | null
    coverPhotoId?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventPreference?: EventTypeUncheckedCreateNestedManyWithoutProfileInput
    assets?: FileInstanceUncheckedCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageUncheckedCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingUncheckedCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutVenuesInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutVenuesInput, ProfileUncheckedCreateWithoutVenuesInput>
  }

  export type AmenitiesCreateWithoutVenueInput = {
    id?: string
    name: string
    default?: boolean
  }

  export type AmenitiesUncheckedCreateWithoutVenueInput = {
    id?: string
    name: string
    default?: boolean
  }

  export type AmenitiesCreateOrConnectWithoutVenueInput = {
    where: AmenitiesWhereUniqueInput
    create: XOR<AmenitiesCreateWithoutVenueInput, AmenitiesUncheckedCreateWithoutVenueInput>
  }

  export type FileInstanceCreateWithoutVenueInput = {
    id?: string
    name: string
    fileId: string
    path: string
    createdAt?: Date | string
    expiresAt: Date | string
    bucket: string
    type: $Enums.FileType
    imageOfProfile?: ProfileCreateNestedOneWithoutImageInput
    coverPhotoOfProfile?: ProfileCreateNestedOneWithoutCoverPhotoInput
    EventPreference?: EventTypeCreateNestedOneWithoutAvatarInput
    Profile?: ProfileCreateNestedOneWithoutAssetsInput
    DirectMessage?: DirectMessageCreateNestedOneWithoutFileInput
  }

  export type FileInstanceUncheckedCreateWithoutVenueInput = {
    id?: string
    name: string
    fileId: string
    path: string
    createdAt?: Date | string
    expiresAt: Date | string
    bucket: string
    type: $Enums.FileType
    eventPreferenceId?: string | null
    profileId?: string | null
    directMessageId?: string | null
    imageOfProfile?: ProfileUncheckedCreateNestedOneWithoutImageInput
    coverPhotoOfProfile?: ProfileUncheckedCreateNestedOneWithoutCoverPhotoInput
  }

  export type FileInstanceCreateOrConnectWithoutVenueInput = {
    where: FileInstanceWhereUniqueInput
    create: XOR<FileInstanceCreateWithoutVenueInput, FileInstanceUncheckedCreateWithoutVenueInput>
  }

  export type ShiftCreateWithoutVenueInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    shiftName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    employee: EmployeeCreateNestedOneWithoutShiftsInput
  }

  export type ShiftUncheckedCreateWithoutVenueInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    shiftName: string
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftCreateOrConnectWithoutVenueInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutVenueInput, ShiftUncheckedCreateWithoutVenueInput>
  }

  export type ShiftCreateManyVenueInputEnvelope = {
    data: ShiftCreateManyVenueInput | ShiftCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutVenueInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    Profile?: ProfileCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutVenueInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    profileId?: string | null
  }

  export type ReviewCreateOrConnectWithoutVenueInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutVenueInput, ReviewUncheckedCreateWithoutVenueInput>
  }

  export type ReviewCreateManyVenueInputEnvelope = {
    data: ReviewCreateManyVenueInput | ReviewCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type DecorationCreateWithoutVenueInput = {
    id?: string
    tableShapes?: DecorationCreatetableShapesInput | $Enums.TableShape[]
    seatingStyles?: DecorationCreateseatingStylesInput | $Enums.SeatingStyle[]
    lighting?: DecorationCreatelightingInput | $Enums.LightingStyle[]
    flowerColors?: DecorationCreateflowerColorsInput | $Enums.FlowerColor[]
    flowerTypes?: DecorationCreateflowerTypesInput | $Enums.FlowerType[]
    fragrances?: DecorationCreatefragrancesInput | $Enums.Fragrance[]
  }

  export type DecorationUncheckedCreateWithoutVenueInput = {
    id?: string
    tableShapes?: DecorationCreatetableShapesInput | $Enums.TableShape[]
    seatingStyles?: DecorationCreateseatingStylesInput | $Enums.SeatingStyle[]
    lighting?: DecorationCreatelightingInput | $Enums.LightingStyle[]
    flowerColors?: DecorationCreateflowerColorsInput | $Enums.FlowerColor[]
    flowerTypes?: DecorationCreateflowerTypesInput | $Enums.FlowerType[]
    fragrances?: DecorationCreatefragrancesInput | $Enums.Fragrance[]
  }

  export type DecorationCreateOrConnectWithoutVenueInput = {
    where: DecorationWhereUniqueInput
    create: XOR<DecorationCreateWithoutVenueInput, DecorationUncheckedCreateWithoutVenueInput>
  }

  export type EmployeeCreateWithoutVenueInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutVenueInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    shifts?: ShiftUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutVenueInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutVenueInput, EmployeeUncheckedCreateWithoutVenueInput>
  }

  export type EmployeeCreateManyVenueInputEnvelope = {
    data: EmployeeCreateManyVenueInput | EmployeeCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type BookingCreateWithoutVenueInput = {
    id?: string
    eventName: string
    location: string
    plannerName: string
    selectedDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    bookingType: $Enums.BookingType
    guestNumber: number
    decoration?: string | null
    services?: BookingCreateservicesInput | string[]
    totalCost: number
    bookingStatus?: $Enums.BookingStatus
    totalAmount?: number
    paid?: number
    due?: number
    accept: $Enums.AcceptanceStatus
    isEventFinished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookedBy: ProfileCreateNestedOneWithoutBookingToVenueInput
    serviceProvider?: ProfileCreateNestedOneWithoutBookingToServiceProviderInput
    eventType?: EventTypeCreateNestedOneWithoutBookingInput
    payment?: PaymentCreateNestedManyWithoutBookingInfoInput
  }

  export type BookingUncheckedCreateWithoutVenueInput = {
    id?: string
    bookedById: string
    serviceProviderId?: string | null
    eventName: string
    location: string
    plannerName: string
    selectedDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    bookingType: $Enums.BookingType
    guestNumber: number
    decoration?: string | null
    services?: BookingCreateservicesInput | string[]
    totalCost: number
    bookingStatus?: $Enums.BookingStatus
    totalAmount?: number
    paid?: number
    due?: number
    accept: $Enums.AcceptanceStatus
    isEventFinished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType?: EventTypeUncheckedCreateNestedOneWithoutBookingInput
    payment?: PaymentUncheckedCreateNestedManyWithoutBookingInfoInput
  }

  export type BookingCreateOrConnectWithoutVenueInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutVenueInput, BookingUncheckedCreateWithoutVenueInput>
  }

  export type BookingCreateManyVenueInputEnvelope = {
    data: BookingCreateManyVenueInput | BookingCreateManyVenueInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutVenuesInput = {
    update: XOR<ProfileUpdateWithoutVenuesInput, ProfileUncheckedUpdateWithoutVenuesInput>
    create: XOR<ProfileCreateWithoutVenuesInput, ProfileUncheckedCreateWithoutVenuesInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutVenuesInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutVenuesInput, ProfileUncheckedUpdateWithoutVenuesInput>
  }

  export type ProfileUpdateWithoutVenuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    image?: FileInstanceUpdateOneWithoutImageOfProfileNestedInput
    eventPreference?: EventTypeUpdateManyWithoutProfileNestedInput
    coverPhoto?: FileInstanceUpdateOneWithoutCoverPhotoOfProfileNestedInput
    assets?: FileInstanceUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutVenuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoId?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventPreference?: EventTypeUncheckedUpdateManyWithoutProfileNestedInput
    assets?: FileInstanceUncheckedUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUncheckedUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUncheckedUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type AmenitiesUpsertWithWhereUniqueWithoutVenueInput = {
    where: AmenitiesWhereUniqueInput
    update: XOR<AmenitiesUpdateWithoutVenueInput, AmenitiesUncheckedUpdateWithoutVenueInput>
    create: XOR<AmenitiesCreateWithoutVenueInput, AmenitiesUncheckedCreateWithoutVenueInput>
  }

  export type AmenitiesUpdateWithWhereUniqueWithoutVenueInput = {
    where: AmenitiesWhereUniqueInput
    data: XOR<AmenitiesUpdateWithoutVenueInput, AmenitiesUncheckedUpdateWithoutVenueInput>
  }

  export type AmenitiesUpdateManyWithWhereWithoutVenueInput = {
    where: AmenitiesScalarWhereInput
    data: XOR<AmenitiesUpdateManyMutationInput, AmenitiesUncheckedUpdateManyWithoutVenueInput>
  }

  export type AmenitiesScalarWhereInput = {
    AND?: AmenitiesScalarWhereInput | AmenitiesScalarWhereInput[]
    OR?: AmenitiesScalarWhereInput[]
    NOT?: AmenitiesScalarWhereInput | AmenitiesScalarWhereInput[]
    id?: StringFilter<"Amenities"> | string
    name?: StringFilter<"Amenities"> | string
    default?: BoolFilter<"Amenities"> | boolean
  }

  export type FileInstanceUpsertWithoutVenueInput = {
    update: XOR<FileInstanceUpdateWithoutVenueInput, FileInstanceUncheckedUpdateWithoutVenueInput>
    create: XOR<FileInstanceCreateWithoutVenueInput, FileInstanceUncheckedCreateWithoutVenueInput>
    where?: FileInstanceWhereInput
  }

  export type FileInstanceUpdateToOneWithWhereWithoutVenueInput = {
    where?: FileInstanceWhereInput
    data: XOR<FileInstanceUpdateWithoutVenueInput, FileInstanceUncheckedUpdateWithoutVenueInput>
  }

  export type FileInstanceUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    imageOfProfile?: ProfileUpdateOneWithoutImageNestedInput
    coverPhotoOfProfile?: ProfileUpdateOneWithoutCoverPhotoNestedInput
    EventPreference?: EventTypeUpdateOneWithoutAvatarNestedInput
    Profile?: ProfileUpdateOneWithoutAssetsNestedInput
    DirectMessage?: DirectMessageUpdateOneWithoutFileNestedInput
  }

  export type FileInstanceUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    eventPreferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    directMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    imageOfProfile?: ProfileUncheckedUpdateOneWithoutImageNestedInput
    coverPhotoOfProfile?: ProfileUncheckedUpdateOneWithoutCoverPhotoNestedInput
  }

  export type ShiftUpsertWithWhereUniqueWithoutVenueInput = {
    where: ShiftWhereUniqueInput
    update: XOR<ShiftUpdateWithoutVenueInput, ShiftUncheckedUpdateWithoutVenueInput>
    create: XOR<ShiftCreateWithoutVenueInput, ShiftUncheckedCreateWithoutVenueInput>
  }

  export type ShiftUpdateWithWhereUniqueWithoutVenueInput = {
    where: ShiftWhereUniqueInput
    data: XOR<ShiftUpdateWithoutVenueInput, ShiftUncheckedUpdateWithoutVenueInput>
  }

  export type ShiftUpdateManyWithWhereWithoutVenueInput = {
    where: ShiftScalarWhereInput
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyWithoutVenueInput>
  }

  export type ShiftScalarWhereInput = {
    AND?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
    OR?: ShiftScalarWhereInput[]
    NOT?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
    id?: StringFilter<"Shift"> | string
    venueId?: StringFilter<"Shift"> | string
    startTime?: DateTimeFilter<"Shift"> | Date | string
    endTime?: DateTimeFilter<"Shift"> | Date | string
    duration?: IntFilter<"Shift"> | number
    shiftName?: StringFilter<"Shift"> | string
    employeeId?: StringFilter<"Shift"> | string
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutVenueInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutVenueInput, ReviewUncheckedUpdateWithoutVenueInput>
    create: XOR<ReviewCreateWithoutVenueInput, ReviewUncheckedCreateWithoutVenueInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutVenueInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutVenueInput, ReviewUncheckedUpdateWithoutVenueInput>
  }

  export type ReviewUpdateManyWithWhereWithoutVenueInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutVenueInput>
  }

  export type DecorationUpsertWithoutVenueInput = {
    update: XOR<DecorationUpdateWithoutVenueInput, DecorationUncheckedUpdateWithoutVenueInput>
    create: XOR<DecorationCreateWithoutVenueInput, DecorationUncheckedCreateWithoutVenueInput>
    where?: DecorationWhereInput
  }

  export type DecorationUpdateToOneWithWhereWithoutVenueInput = {
    where?: DecorationWhereInput
    data: XOR<DecorationUpdateWithoutVenueInput, DecorationUncheckedUpdateWithoutVenueInput>
  }

  export type DecorationUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableShapes?: DecorationUpdatetableShapesInput | $Enums.TableShape[]
    seatingStyles?: DecorationUpdateseatingStylesInput | $Enums.SeatingStyle[]
    lighting?: DecorationUpdatelightingInput | $Enums.LightingStyle[]
    flowerColors?: DecorationUpdateflowerColorsInput | $Enums.FlowerColor[]
    flowerTypes?: DecorationUpdateflowerTypesInput | $Enums.FlowerType[]
    fragrances?: DecorationUpdatefragrancesInput | $Enums.Fragrance[]
  }

  export type DecorationUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    tableShapes?: DecorationUpdatetableShapesInput | $Enums.TableShape[]
    seatingStyles?: DecorationUpdateseatingStylesInput | $Enums.SeatingStyle[]
    lighting?: DecorationUpdatelightingInput | $Enums.LightingStyle[]
    flowerColors?: DecorationUpdateflowerColorsInput | $Enums.FlowerColor[]
    flowerTypes?: DecorationUpdateflowerTypesInput | $Enums.FlowerType[]
    fragrances?: DecorationUpdatefragrancesInput | $Enums.Fragrance[]
  }

  export type EmployeeUpsertWithWhereUniqueWithoutVenueInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutVenueInput, EmployeeUncheckedUpdateWithoutVenueInput>
    create: XOR<EmployeeCreateWithoutVenueInput, EmployeeUncheckedCreateWithoutVenueInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutVenueInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutVenueInput, EmployeeUncheckedUpdateWithoutVenueInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutVenueInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutVenueInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: StringFilter<"Employee"> | string
    venueId?: StringFilter<"Employee"> | string
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    email?: StringFilter<"Employee"> | string
    phone?: StringFilter<"Employee"> | string
    role?: StringFilter<"Employee"> | string
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
  }

  export type BookingUpsertWithWhereUniqueWithoutVenueInput = {
    where: BookingWhereUniqueInput
    update: XOR<BookingUpdateWithoutVenueInput, BookingUncheckedUpdateWithoutVenueInput>
    create: XOR<BookingCreateWithoutVenueInput, BookingUncheckedCreateWithoutVenueInput>
  }

  export type BookingUpdateWithWhereUniqueWithoutVenueInput = {
    where: BookingWhereUniqueInput
    data: XOR<BookingUpdateWithoutVenueInput, BookingUncheckedUpdateWithoutVenueInput>
  }

  export type BookingUpdateManyWithWhereWithoutVenueInput = {
    where: BookingScalarWhereInput
    data: XOR<BookingUpdateManyMutationInput, BookingUncheckedUpdateManyWithoutVenueInput>
  }

  export type VenueCreateWithoutEmployeesInput = {
    id?: string
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Profile?: ProfileCreateNestedOneWithoutVenuesInput
    amenities?: AmenitiesCreateNestedManyWithoutVenueInput
    arrangementsImage?: FileInstanceCreateNestedOneWithoutVenueInput
    shifts?: ShiftCreateNestedManyWithoutVenueInput
    reviews?: ReviewCreateNestedManyWithoutVenueInput
    decoration?: DecorationCreateNestedOneWithoutVenueInput
    bookings?: BookingCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutEmployeesInput = {
    id?: string
    profileId?: string | null
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutVenueInput
    arrangementsImage?: FileInstanceUncheckedCreateNestedOneWithoutVenueInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutVenueInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutVenueInput
    decoration?: DecorationUncheckedCreateNestedOneWithoutVenueInput
    bookings?: BookingUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutEmployeesInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutEmployeesInput, VenueUncheckedCreateWithoutEmployeesInput>
  }

  export type ShiftCreateWithoutEmployeeInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    shiftName: string
    createdAt?: Date | string
    updatedAt?: Date | string
    venue: VenueCreateNestedOneWithoutShiftsInput
  }

  export type ShiftUncheckedCreateWithoutEmployeeInput = {
    id?: string
    venueId: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    shiftName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftCreateOrConnectWithoutEmployeeInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutEmployeeInput, ShiftUncheckedCreateWithoutEmployeeInput>
  }

  export type ShiftCreateManyEmployeeInputEnvelope = {
    data: ShiftCreateManyEmployeeInput | ShiftCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type VenueUpsertWithoutEmployeesInput = {
    update: XOR<VenueUpdateWithoutEmployeesInput, VenueUncheckedUpdateWithoutEmployeesInput>
    create: XOR<VenueCreateWithoutEmployeesInput, VenueUncheckedCreateWithoutEmployeesInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutEmployeesInput, VenueUncheckedUpdateWithoutEmployeesInput>
  }

  export type VenueUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Profile?: ProfileUpdateOneWithoutVenuesNestedInput
    amenities?: AmenitiesUpdateManyWithoutVenueNestedInput
    arrangementsImage?: FileInstanceUpdateOneWithoutVenueNestedInput
    shifts?: ShiftUpdateManyWithoutVenueNestedInput
    reviews?: ReviewUpdateManyWithoutVenueNestedInput
    decoration?: DecorationUpdateOneWithoutVenueNestedInput
    bookings?: BookingUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: AmenitiesUncheckedUpdateManyWithoutVenueNestedInput
    arrangementsImage?: FileInstanceUncheckedUpdateOneWithoutVenueNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutVenueNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutVenueNestedInput
    decoration?: DecorationUncheckedUpdateOneWithoutVenueNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type ShiftUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: ShiftWhereUniqueInput
    update: XOR<ShiftUpdateWithoutEmployeeInput, ShiftUncheckedUpdateWithoutEmployeeInput>
    create: XOR<ShiftCreateWithoutEmployeeInput, ShiftUncheckedCreateWithoutEmployeeInput>
  }

  export type ShiftUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: ShiftWhereUniqueInput
    data: XOR<ShiftUpdateWithoutEmployeeInput, ShiftUncheckedUpdateWithoutEmployeeInput>
  }

  export type ShiftUpdateManyWithWhereWithoutEmployeeInput = {
    where: ShiftScalarWhereInput
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type VenueCreateWithoutShiftsInput = {
    id?: string
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Profile?: ProfileCreateNestedOneWithoutVenuesInput
    amenities?: AmenitiesCreateNestedManyWithoutVenueInput
    arrangementsImage?: FileInstanceCreateNestedOneWithoutVenueInput
    reviews?: ReviewCreateNestedManyWithoutVenueInput
    decoration?: DecorationCreateNestedOneWithoutVenueInput
    employees?: EmployeeCreateNestedManyWithoutVenueInput
    bookings?: BookingCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutShiftsInput = {
    id?: string
    profileId?: string | null
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutVenueInput
    arrangementsImage?: FileInstanceUncheckedCreateNestedOneWithoutVenueInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutVenueInput
    decoration?: DecorationUncheckedCreateNestedOneWithoutVenueInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutVenueInput
    bookings?: BookingUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutShiftsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutShiftsInput, VenueUncheckedCreateWithoutShiftsInput>
  }

  export type EmployeeCreateWithoutShiftsInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
    venue: VenueCreateNestedOneWithoutEmployeesInput
  }

  export type EmployeeUncheckedCreateWithoutShiftsInput = {
    id?: string
    venueId: string
    firstName: string
    lastName: string
    email: string
    phone: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeCreateOrConnectWithoutShiftsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutShiftsInput, EmployeeUncheckedCreateWithoutShiftsInput>
  }

  export type VenueUpsertWithoutShiftsInput = {
    update: XOR<VenueUpdateWithoutShiftsInput, VenueUncheckedUpdateWithoutShiftsInput>
    create: XOR<VenueCreateWithoutShiftsInput, VenueUncheckedCreateWithoutShiftsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutShiftsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutShiftsInput, VenueUncheckedUpdateWithoutShiftsInput>
  }

  export type VenueUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Profile?: ProfileUpdateOneWithoutVenuesNestedInput
    amenities?: AmenitiesUpdateManyWithoutVenueNestedInput
    arrangementsImage?: FileInstanceUpdateOneWithoutVenueNestedInput
    reviews?: ReviewUpdateManyWithoutVenueNestedInput
    decoration?: DecorationUpdateOneWithoutVenueNestedInput
    employees?: EmployeeUpdateManyWithoutVenueNestedInput
    bookings?: BookingUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: AmenitiesUncheckedUpdateManyWithoutVenueNestedInput
    arrangementsImage?: FileInstanceUncheckedUpdateOneWithoutVenueNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutVenueNestedInput
    decoration?: DecorationUncheckedUpdateOneWithoutVenueNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutVenueNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type EmployeeUpsertWithoutShiftsInput = {
    update: XOR<EmployeeUpdateWithoutShiftsInput, EmployeeUncheckedUpdateWithoutShiftsInput>
    create: XOR<EmployeeCreateWithoutShiftsInput, EmployeeUncheckedCreateWithoutShiftsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutShiftsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutShiftsInput, EmployeeUncheckedUpdateWithoutShiftsInput>
  }

  export type EmployeeUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutEmployeesNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutShiftsInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateWithoutBookingToVenueInput = {
    id?: string
    gender: $Enums.Gender
    location?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    image?: FileInstanceCreateNestedOneWithoutImageOfProfileInput
    eventPreference?: EventTypeCreateNestedManyWithoutProfileInput
    coverPhoto?: FileInstanceCreateNestedOneWithoutCoverPhotoOfProfileInput
    assets?: FileInstanceCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationCreateNestedManyWithoutMemberTwoInput
    bookingToServiceProvider?: BookingCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewCreateNestedManyWithoutProfileInput
    venues?: VenueCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutBookingToVenueInput = {
    id?: string
    userId: string
    gender: $Enums.Gender
    imageId?: string | null
    location?: string | null
    coverPhotoId?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventPreference?: EventTypeUncheckedCreateNestedManyWithoutProfileInput
    assets?: FileInstanceUncheckedCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageUncheckedCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutMemberTwoInput
    bookingToServiceProvider?: BookingUncheckedCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProfileInput
    venues?: VenueUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutBookingToVenueInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutBookingToVenueInput, ProfileUncheckedCreateWithoutBookingToVenueInput>
  }

  export type VenueCreateWithoutBookingsInput = {
    id?: string
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Profile?: ProfileCreateNestedOneWithoutVenuesInput
    amenities?: AmenitiesCreateNestedManyWithoutVenueInput
    arrangementsImage?: FileInstanceCreateNestedOneWithoutVenueInput
    shifts?: ShiftCreateNestedManyWithoutVenueInput
    reviews?: ReviewCreateNestedManyWithoutVenueInput
    decoration?: DecorationCreateNestedOneWithoutVenueInput
    employees?: EmployeeCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutBookingsInput = {
    id?: string
    profileId?: string | null
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutVenueInput
    arrangementsImage?: FileInstanceUncheckedCreateNestedOneWithoutVenueInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutVenueInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutVenueInput
    decoration?: DecorationUncheckedCreateNestedOneWithoutVenueInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutBookingsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutBookingsInput, VenueUncheckedCreateWithoutBookingsInput>
  }

  export type ProfileCreateWithoutBookingToServiceProviderInput = {
    id?: string
    gender: $Enums.Gender
    location?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    image?: FileInstanceCreateNestedOneWithoutImageOfProfileInput
    eventPreference?: EventTypeCreateNestedManyWithoutProfileInput
    coverPhoto?: FileInstanceCreateNestedOneWithoutCoverPhotoOfProfileInput
    assets?: FileInstanceCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingCreateNestedManyWithoutBookedByInput
    reviews?: ReviewCreateNestedManyWithoutProfileInput
    venues?: VenueCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutBookingToServiceProviderInput = {
    id?: string
    userId: string
    gender: $Enums.Gender
    imageId?: string | null
    location?: string | null
    coverPhotoId?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventPreference?: EventTypeUncheckedCreateNestedManyWithoutProfileInput
    assets?: FileInstanceUncheckedCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageUncheckedCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProfileInput
    venues?: VenueUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutBookingToServiceProviderInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutBookingToServiceProviderInput, ProfileUncheckedCreateWithoutBookingToServiceProviderInput>
  }

  export type EventTypeCreateWithoutBookingInput = {
    id?: string
    name: string
    avatar?: FileInstanceCreateNestedOneWithoutEventPreferenceInput
    profile?: ProfileCreateNestedManyWithoutEventPreferenceInput
  }

  export type EventTypeUncheckedCreateWithoutBookingInput = {
    id?: string
    name: string
    avatar?: FileInstanceUncheckedCreateNestedOneWithoutEventPreferenceInput
    profile?: ProfileUncheckedCreateNestedManyWithoutEventPreferenceInput
  }

  export type EventTypeCreateOrConnectWithoutBookingInput = {
    where: EventTypeWhereUniqueInput
    create: XOR<EventTypeCreateWithoutBookingInput, EventTypeUncheckedCreateWithoutBookingInput>
  }

  export type PaymentCreateWithoutBookingInfoInput = {
    id?: string
    paymentStatus: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    amount: number
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUncheckedCreateWithoutBookingInfoInput = {
    id?: string
    paymentStatus: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    amount: number
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateOrConnectWithoutBookingInfoInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutBookingInfoInput, PaymentUncheckedCreateWithoutBookingInfoInput>
  }

  export type PaymentCreateManyBookingInfoInputEnvelope = {
    data: PaymentCreateManyBookingInfoInput | PaymentCreateManyBookingInfoInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutBookingToVenueInput = {
    update: XOR<ProfileUpdateWithoutBookingToVenueInput, ProfileUncheckedUpdateWithoutBookingToVenueInput>
    create: XOR<ProfileCreateWithoutBookingToVenueInput, ProfileUncheckedCreateWithoutBookingToVenueInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutBookingToVenueInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutBookingToVenueInput, ProfileUncheckedUpdateWithoutBookingToVenueInput>
  }

  export type ProfileUpdateWithoutBookingToVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    image?: FileInstanceUpdateOneWithoutImageOfProfileNestedInput
    eventPreference?: EventTypeUpdateManyWithoutProfileNestedInput
    coverPhoto?: FileInstanceUpdateOneWithoutCoverPhotoOfProfileNestedInput
    assets?: FileInstanceUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUpdateManyWithoutMemberTwoNestedInput
    bookingToServiceProvider?: BookingUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProfileNestedInput
    venues?: VenueUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutBookingToVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoId?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventPreference?: EventTypeUncheckedUpdateManyWithoutProfileNestedInput
    assets?: FileInstanceUncheckedUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUncheckedUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutMemberTwoNestedInput
    bookingToServiceProvider?: BookingUncheckedUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProfileNestedInput
    venues?: VenueUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type VenueUpsertWithoutBookingsInput = {
    update: XOR<VenueUpdateWithoutBookingsInput, VenueUncheckedUpdateWithoutBookingsInput>
    create: XOR<VenueCreateWithoutBookingsInput, VenueUncheckedCreateWithoutBookingsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutBookingsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutBookingsInput, VenueUncheckedUpdateWithoutBookingsInput>
  }

  export type VenueUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Profile?: ProfileUpdateOneWithoutVenuesNestedInput
    amenities?: AmenitiesUpdateManyWithoutVenueNestedInput
    arrangementsImage?: FileInstanceUpdateOneWithoutVenueNestedInput
    shifts?: ShiftUpdateManyWithoutVenueNestedInput
    reviews?: ReviewUpdateManyWithoutVenueNestedInput
    decoration?: DecorationUpdateOneWithoutVenueNestedInput
    employees?: EmployeeUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutBookingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: AmenitiesUncheckedUpdateManyWithoutVenueNestedInput
    arrangementsImage?: FileInstanceUncheckedUpdateOneWithoutVenueNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutVenueNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutVenueNestedInput
    decoration?: DecorationUncheckedUpdateOneWithoutVenueNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type ProfileUpsertWithoutBookingToServiceProviderInput = {
    update: XOR<ProfileUpdateWithoutBookingToServiceProviderInput, ProfileUncheckedUpdateWithoutBookingToServiceProviderInput>
    create: XOR<ProfileCreateWithoutBookingToServiceProviderInput, ProfileUncheckedCreateWithoutBookingToServiceProviderInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutBookingToServiceProviderInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutBookingToServiceProviderInput, ProfileUncheckedUpdateWithoutBookingToServiceProviderInput>
  }

  export type ProfileUpdateWithoutBookingToServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    image?: FileInstanceUpdateOneWithoutImageOfProfileNestedInput
    eventPreference?: EventTypeUpdateManyWithoutProfileNestedInput
    coverPhoto?: FileInstanceUpdateOneWithoutCoverPhotoOfProfileNestedInput
    assets?: FileInstanceUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUpdateManyWithoutBookedByNestedInput
    reviews?: ReviewUpdateManyWithoutProfileNestedInput
    venues?: VenueUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutBookingToServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoId?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventPreference?: EventTypeUncheckedUpdateManyWithoutProfileNestedInput
    assets?: FileInstanceUncheckedUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUncheckedUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProfileNestedInput
    venues?: VenueUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type EventTypeUpsertWithoutBookingInput = {
    update: XOR<EventTypeUpdateWithoutBookingInput, EventTypeUncheckedUpdateWithoutBookingInput>
    create: XOR<EventTypeCreateWithoutBookingInput, EventTypeUncheckedCreateWithoutBookingInput>
    where?: EventTypeWhereInput
  }

  export type EventTypeUpdateToOneWithWhereWithoutBookingInput = {
    where?: EventTypeWhereInput
    data: XOR<EventTypeUpdateWithoutBookingInput, EventTypeUncheckedUpdateWithoutBookingInput>
  }

  export type EventTypeUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: FileInstanceUpdateOneWithoutEventPreferenceNestedInput
    profile?: ProfileUpdateManyWithoutEventPreferenceNestedInput
  }

  export type EventTypeUncheckedUpdateWithoutBookingInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: FileInstanceUncheckedUpdateOneWithoutEventPreferenceNestedInput
    profile?: ProfileUncheckedUpdateManyWithoutEventPreferenceNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutBookingInfoInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutBookingInfoInput, PaymentUncheckedUpdateWithoutBookingInfoInput>
    create: XOR<PaymentCreateWithoutBookingInfoInput, PaymentUncheckedCreateWithoutBookingInfoInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutBookingInfoInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutBookingInfoInput, PaymentUncheckedUpdateWithoutBookingInfoInput>
  }

  export type PaymentUpdateManyWithWhereWithoutBookingInfoInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutBookingInfoInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    bookingId?: StringFilter<"Payment"> | string
    paymentStatus?: EnumPaymentStatusFilter<"Payment"> | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFilter<"Payment"> | $Enums.PaymentMethod
    amount?: IntFilter<"Payment"> | number
    transactionId?: StringNullableFilter<"Payment"> | string | null
    createdAt?: DateTimeFilter<"Payment"> | Date | string
    updatedAt?: DateTimeFilter<"Payment"> | Date | string
  }

  export type BookingCreateWithoutPaymentInput = {
    id?: string
    eventName: string
    location: string
    plannerName: string
    selectedDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    bookingType: $Enums.BookingType
    guestNumber: number
    decoration?: string | null
    services?: BookingCreateservicesInput | string[]
    totalCost: number
    bookingStatus?: $Enums.BookingStatus
    totalAmount?: number
    paid?: number
    due?: number
    accept: $Enums.AcceptanceStatus
    isEventFinished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bookedBy: ProfileCreateNestedOneWithoutBookingToVenueInput
    venue?: VenueCreateNestedOneWithoutBookingsInput
    serviceProvider?: ProfileCreateNestedOneWithoutBookingToServiceProviderInput
    eventType?: EventTypeCreateNestedOneWithoutBookingInput
  }

  export type BookingUncheckedCreateWithoutPaymentInput = {
    id?: string
    bookedById: string
    venueId?: string | null
    serviceProviderId?: string | null
    eventName: string
    location: string
    plannerName: string
    selectedDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    bookingType: $Enums.BookingType
    guestNumber: number
    decoration?: string | null
    services?: BookingCreateservicesInput | string[]
    totalCost: number
    bookingStatus?: $Enums.BookingStatus
    totalAmount?: number
    paid?: number
    due?: number
    accept: $Enums.AcceptanceStatus
    isEventFinished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    eventType?: EventTypeUncheckedCreateNestedOneWithoutBookingInput
  }

  export type BookingCreateOrConnectWithoutPaymentInput = {
    where: BookingWhereUniqueInput
    create: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
  }

  export type BookingUpsertWithoutPaymentInput = {
    update: XOR<BookingUpdateWithoutPaymentInput, BookingUncheckedUpdateWithoutPaymentInput>
    create: XOR<BookingCreateWithoutPaymentInput, BookingUncheckedCreateWithoutPaymentInput>
    where?: BookingWhereInput
  }

  export type BookingUpdateToOneWithWhereWithoutPaymentInput = {
    where?: BookingWhereInput
    data: XOR<BookingUpdateWithoutPaymentInput, BookingUncheckedUpdateWithoutPaymentInput>
  }

  export type BookingUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    plannerName?: StringFieldUpdateOperationsInput | string
    selectedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    guestNumber?: IntFieldUpdateOperationsInput | number
    decoration?: NullableStringFieldUpdateOperationsInput | string | null
    services?: BookingUpdateservicesInput | string[]
    totalCost?: IntFieldUpdateOperationsInput | number
    bookingStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    due?: IntFieldUpdateOperationsInput | number
    accept?: EnumAcceptanceStatusFieldUpdateOperationsInput | $Enums.AcceptanceStatus
    isEventFinished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedBy?: ProfileUpdateOneRequiredWithoutBookingToVenueNestedInput
    venue?: VenueUpdateOneWithoutBookingsNestedInput
    serviceProvider?: ProfileUpdateOneWithoutBookingToServiceProviderNestedInput
    eventType?: EventTypeUpdateOneWithoutBookingNestedInput
  }

  export type BookingUncheckedUpdateWithoutPaymentInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookedById?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    plannerName?: StringFieldUpdateOperationsInput | string
    selectedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    guestNumber?: IntFieldUpdateOperationsInput | number
    decoration?: NullableStringFieldUpdateOperationsInput | string | null
    services?: BookingUpdateservicesInput | string[]
    totalCost?: IntFieldUpdateOperationsInput | number
    bookingStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    due?: IntFieldUpdateOperationsInput | number
    accept?: EnumAcceptanceStatusFieldUpdateOperationsInput | $Enums.AcceptanceStatus
    isEventFinished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EventTypeUncheckedUpdateOneWithoutBookingNestedInput
  }

  export type VenueCreateWithoutDecorationInput = {
    id?: string
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Profile?: ProfileCreateNestedOneWithoutVenuesInput
    amenities?: AmenitiesCreateNestedManyWithoutVenueInput
    arrangementsImage?: FileInstanceCreateNestedOneWithoutVenueInput
    shifts?: ShiftCreateNestedManyWithoutVenueInput
    reviews?: ReviewCreateNestedManyWithoutVenueInput
    employees?: EmployeeCreateNestedManyWithoutVenueInput
    bookings?: BookingCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutDecorationInput = {
    id?: string
    profileId?: string | null
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutVenueInput
    arrangementsImage?: FileInstanceUncheckedCreateNestedOneWithoutVenueInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutVenueInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutVenueInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutVenueInput
    bookings?: BookingUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutDecorationInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutDecorationInput, VenueUncheckedCreateWithoutDecorationInput>
  }

  export type VenueUpsertWithoutDecorationInput = {
    update: XOR<VenueUpdateWithoutDecorationInput, VenueUncheckedUpdateWithoutDecorationInput>
    create: XOR<VenueCreateWithoutDecorationInput, VenueUncheckedCreateWithoutDecorationInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutDecorationInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutDecorationInput, VenueUncheckedUpdateWithoutDecorationInput>
  }

  export type VenueUpdateWithoutDecorationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Profile?: ProfileUpdateOneWithoutVenuesNestedInput
    amenities?: AmenitiesUpdateManyWithoutVenueNestedInput
    arrangementsImage?: FileInstanceUpdateOneWithoutVenueNestedInput
    shifts?: ShiftUpdateManyWithoutVenueNestedInput
    reviews?: ReviewUpdateManyWithoutVenueNestedInput
    employees?: EmployeeUpdateManyWithoutVenueNestedInput
    bookings?: BookingUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutDecorationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: AmenitiesUncheckedUpdateManyWithoutVenueNestedInput
    arrangementsImage?: FileInstanceUncheckedUpdateOneWithoutVenueNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutVenueNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutVenueNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutVenueNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueCreateWithoutReviewsInput = {
    id?: string
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Profile?: ProfileCreateNestedOneWithoutVenuesInput
    amenities?: AmenitiesCreateNestedManyWithoutVenueInput
    arrangementsImage?: FileInstanceCreateNestedOneWithoutVenueInput
    shifts?: ShiftCreateNestedManyWithoutVenueInput
    decoration?: DecorationCreateNestedOneWithoutVenueInput
    employees?: EmployeeCreateNestedManyWithoutVenueInput
    bookings?: BookingCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutReviewsInput = {
    id?: string
    profileId?: string | null
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutVenueInput
    arrangementsImage?: FileInstanceUncheckedCreateNestedOneWithoutVenueInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutVenueInput
    decoration?: DecorationUncheckedCreateNestedOneWithoutVenueInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutVenueInput
    bookings?: BookingUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutReviewsInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutReviewsInput, VenueUncheckedCreateWithoutReviewsInput>
  }

  export type ProfileCreateWithoutReviewsInput = {
    id?: string
    gender: $Enums.Gender
    location?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    image?: FileInstanceCreateNestedOneWithoutImageOfProfileInput
    eventPreference?: EventTypeCreateNestedManyWithoutProfileInput
    coverPhoto?: FileInstanceCreateNestedOneWithoutCoverPhotoOfProfileInput
    assets?: FileInstanceCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingCreateNestedManyWithoutServiceProviderInput
    venues?: VenueCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutReviewsInput = {
    id?: string
    userId: string
    gender: $Enums.Gender
    imageId?: string | null
    location?: string | null
    coverPhotoId?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventPreference?: EventTypeUncheckedCreateNestedManyWithoutProfileInput
    assets?: FileInstanceUncheckedCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageUncheckedCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingUncheckedCreateNestedManyWithoutServiceProviderInput
    venues?: VenueUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutReviewsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutReviewsInput, ProfileUncheckedCreateWithoutReviewsInput>
  }

  export type VenueUpsertWithoutReviewsInput = {
    update: XOR<VenueUpdateWithoutReviewsInput, VenueUncheckedUpdateWithoutReviewsInput>
    create: XOR<VenueCreateWithoutReviewsInput, VenueUncheckedCreateWithoutReviewsInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutReviewsInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutReviewsInput, VenueUncheckedUpdateWithoutReviewsInput>
  }

  export type VenueUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Profile?: ProfileUpdateOneWithoutVenuesNestedInput
    amenities?: AmenitiesUpdateManyWithoutVenueNestedInput
    arrangementsImage?: FileInstanceUpdateOneWithoutVenueNestedInput
    shifts?: ShiftUpdateManyWithoutVenueNestedInput
    decoration?: DecorationUpdateOneWithoutVenueNestedInput
    employees?: EmployeeUpdateManyWithoutVenueNestedInput
    bookings?: BookingUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: AmenitiesUncheckedUpdateManyWithoutVenueNestedInput
    arrangementsImage?: FileInstanceUncheckedUpdateOneWithoutVenueNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutVenueNestedInput
    decoration?: DecorationUncheckedUpdateOneWithoutVenueNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutVenueNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type ProfileUpsertWithoutReviewsInput = {
    update: XOR<ProfileUpdateWithoutReviewsInput, ProfileUncheckedUpdateWithoutReviewsInput>
    create: XOR<ProfileCreateWithoutReviewsInput, ProfileUncheckedCreateWithoutReviewsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutReviewsInput, ProfileUncheckedUpdateWithoutReviewsInput>
  }

  export type ProfileUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    image?: FileInstanceUpdateOneWithoutImageOfProfileNestedInput
    eventPreference?: EventTypeUpdateManyWithoutProfileNestedInput
    coverPhoto?: FileInstanceUpdateOneWithoutCoverPhotoOfProfileNestedInput
    assets?: FileInstanceUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUpdateManyWithoutServiceProviderNestedInput
    venues?: VenueUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoId?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventPreference?: EventTypeUncheckedUpdateManyWithoutProfileNestedInput
    assets?: FileInstanceUncheckedUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUncheckedUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUncheckedUpdateManyWithoutServiceProviderNestedInput
    venues?: VenueUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type VenueCreateWithoutAmenitiesInput = {
    id?: string
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Profile?: ProfileCreateNestedOneWithoutVenuesInput
    arrangementsImage?: FileInstanceCreateNestedOneWithoutVenueInput
    shifts?: ShiftCreateNestedManyWithoutVenueInput
    reviews?: ReviewCreateNestedManyWithoutVenueInput
    decoration?: DecorationCreateNestedOneWithoutVenueInput
    employees?: EmployeeCreateNestedManyWithoutVenueInput
    bookings?: BookingCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutAmenitiesInput = {
    id?: string
    profileId?: string | null
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    arrangementsImage?: FileInstanceUncheckedCreateNestedOneWithoutVenueInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutVenueInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutVenueInput
    decoration?: DecorationUncheckedCreateNestedOneWithoutVenueInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutVenueInput
    bookings?: BookingUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutAmenitiesInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutAmenitiesInput, VenueUncheckedCreateWithoutAmenitiesInput>
  }

  export type VenueUpsertWithWhereUniqueWithoutAmenitiesInput = {
    where: VenueWhereUniqueInput
    update: XOR<VenueUpdateWithoutAmenitiesInput, VenueUncheckedUpdateWithoutAmenitiesInput>
    create: XOR<VenueCreateWithoutAmenitiesInput, VenueUncheckedCreateWithoutAmenitiesInput>
  }

  export type VenueUpdateWithWhereUniqueWithoutAmenitiesInput = {
    where: VenueWhereUniqueInput
    data: XOR<VenueUpdateWithoutAmenitiesInput, VenueUncheckedUpdateWithoutAmenitiesInput>
  }

  export type VenueUpdateManyWithWhereWithoutAmenitiesInput = {
    where: VenueScalarWhereInput
    data: XOR<VenueUpdateManyMutationInput, VenueUncheckedUpdateManyWithoutAmenitiesInput>
  }

  export type VenueCreateWithoutArrangementsImageInput = {
    id?: string
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Profile?: ProfileCreateNestedOneWithoutVenuesInput
    amenities?: AmenitiesCreateNestedManyWithoutVenueInput
    shifts?: ShiftCreateNestedManyWithoutVenueInput
    reviews?: ReviewCreateNestedManyWithoutVenueInput
    decoration?: DecorationCreateNestedOneWithoutVenueInput
    employees?: EmployeeCreateNestedManyWithoutVenueInput
    bookings?: BookingCreateNestedManyWithoutVenueInput
  }

  export type VenueUncheckedCreateWithoutArrangementsImageInput = {
    id?: string
    profileId?: string | null
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    amenities?: AmenitiesUncheckedCreateNestedManyWithoutVenueInput
    shifts?: ShiftUncheckedCreateNestedManyWithoutVenueInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutVenueInput
    decoration?: DecorationUncheckedCreateNestedOneWithoutVenueInput
    employees?: EmployeeUncheckedCreateNestedManyWithoutVenueInput
    bookings?: BookingUncheckedCreateNestedManyWithoutVenueInput
  }

  export type VenueCreateOrConnectWithoutArrangementsImageInput = {
    where: VenueWhereUniqueInput
    create: XOR<VenueCreateWithoutArrangementsImageInput, VenueUncheckedCreateWithoutArrangementsImageInput>
  }

  export type ProfileCreateWithoutImageInput = {
    id?: string
    gender: $Enums.Gender
    location?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    eventPreference?: EventTypeCreateNestedManyWithoutProfileInput
    coverPhoto?: FileInstanceCreateNestedOneWithoutCoverPhotoOfProfileInput
    assets?: FileInstanceCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewCreateNestedManyWithoutProfileInput
    venues?: VenueCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutImageInput = {
    id?: string
    userId: string
    gender: $Enums.Gender
    location?: string | null
    coverPhotoId?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventPreference?: EventTypeUncheckedCreateNestedManyWithoutProfileInput
    assets?: FileInstanceUncheckedCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageUncheckedCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingUncheckedCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProfileInput
    venues?: VenueUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutImageInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutImageInput, ProfileUncheckedCreateWithoutImageInput>
  }

  export type ProfileCreateWithoutCoverPhotoInput = {
    id?: string
    gender: $Enums.Gender
    location?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    image?: FileInstanceCreateNestedOneWithoutImageOfProfileInput
    eventPreference?: EventTypeCreateNestedManyWithoutProfileInput
    assets?: FileInstanceCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewCreateNestedManyWithoutProfileInput
    venues?: VenueCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutCoverPhotoInput = {
    id?: string
    userId: string
    gender: $Enums.Gender
    imageId?: string | null
    location?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventPreference?: EventTypeUncheckedCreateNestedManyWithoutProfileInput
    assets?: FileInstanceUncheckedCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageUncheckedCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingUncheckedCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProfileInput
    venues?: VenueUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutCoverPhotoInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutCoverPhotoInput, ProfileUncheckedCreateWithoutCoverPhotoInput>
  }

  export type EventTypeCreateWithoutAvatarInput = {
    id?: string
    name: string
    profile?: ProfileCreateNestedManyWithoutEventPreferenceInput
    Booking?: BookingCreateNestedOneWithoutEventTypeInput
  }

  export type EventTypeUncheckedCreateWithoutAvatarInput = {
    id?: string
    name: string
    bookingId: string
    profile?: ProfileUncheckedCreateNestedManyWithoutEventPreferenceInput
  }

  export type EventTypeCreateOrConnectWithoutAvatarInput = {
    where: EventTypeWhereUniqueInput
    create: XOR<EventTypeCreateWithoutAvatarInput, EventTypeUncheckedCreateWithoutAvatarInput>
  }

  export type ProfileCreateWithoutAssetsInput = {
    id?: string
    gender: $Enums.Gender
    location?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    image?: FileInstanceCreateNestedOneWithoutImageOfProfileInput
    eventPreference?: EventTypeCreateNestedManyWithoutProfileInput
    coverPhoto?: FileInstanceCreateNestedOneWithoutCoverPhotoOfProfileInput
    directMessages?: DirectMessageCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewCreateNestedManyWithoutProfileInput
    venues?: VenueCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutAssetsInput = {
    id?: string
    userId: string
    gender: $Enums.Gender
    imageId?: string | null
    location?: string | null
    coverPhotoId?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventPreference?: EventTypeUncheckedCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageUncheckedCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingUncheckedCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProfileInput
    venues?: VenueUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutAssetsInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutAssetsInput, ProfileUncheckedCreateWithoutAssetsInput>
  }

  export type DirectMessageCreateWithoutFileInput = {
    id?: string
    content: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    member: ProfileCreateNestedOneWithoutDirectMessagesInput
    conversation: ConversationCreateNestedOneWithoutDirectMessagesInput
  }

  export type DirectMessageUncheckedCreateWithoutFileInput = {
    id?: string
    content: string
    memberId: string
    conversationId: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageCreateOrConnectWithoutFileInput = {
    where: DirectMessageWhereUniqueInput
    create: XOR<DirectMessageCreateWithoutFileInput, DirectMessageUncheckedCreateWithoutFileInput>
  }

  export type VenueUpsertWithoutArrangementsImageInput = {
    update: XOR<VenueUpdateWithoutArrangementsImageInput, VenueUncheckedUpdateWithoutArrangementsImageInput>
    create: XOR<VenueCreateWithoutArrangementsImageInput, VenueUncheckedCreateWithoutArrangementsImageInput>
    where?: VenueWhereInput
  }

  export type VenueUpdateToOneWithWhereWithoutArrangementsImageInput = {
    where?: VenueWhereInput
    data: XOR<VenueUpdateWithoutArrangementsImageInput, VenueUncheckedUpdateWithoutArrangementsImageInput>
  }

  export type VenueUpdateWithoutArrangementsImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Profile?: ProfileUpdateOneWithoutVenuesNestedInput
    amenities?: AmenitiesUpdateManyWithoutVenueNestedInput
    shifts?: ShiftUpdateManyWithoutVenueNestedInput
    reviews?: ReviewUpdateManyWithoutVenueNestedInput
    decoration?: DecorationUpdateOneWithoutVenueNestedInput
    employees?: EmployeeUpdateManyWithoutVenueNestedInput
    bookings?: BookingUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutArrangementsImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: AmenitiesUncheckedUpdateManyWithoutVenueNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutVenueNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutVenueNestedInput
    decoration?: DecorationUncheckedUpdateOneWithoutVenueNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutVenueNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type ProfileUpsertWithoutImageInput = {
    update: XOR<ProfileUpdateWithoutImageInput, ProfileUncheckedUpdateWithoutImageInput>
    create: XOR<ProfileCreateWithoutImageInput, ProfileUncheckedCreateWithoutImageInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutImageInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutImageInput, ProfileUncheckedUpdateWithoutImageInput>
  }

  export type ProfileUpdateWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    eventPreference?: EventTypeUpdateManyWithoutProfileNestedInput
    coverPhoto?: FileInstanceUpdateOneWithoutCoverPhotoOfProfileNestedInput
    assets?: FileInstanceUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProfileNestedInput
    venues?: VenueUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoId?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventPreference?: EventTypeUncheckedUpdateManyWithoutProfileNestedInput
    assets?: FileInstanceUncheckedUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUncheckedUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUncheckedUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProfileNestedInput
    venues?: VenueUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUpsertWithoutCoverPhotoInput = {
    update: XOR<ProfileUpdateWithoutCoverPhotoInput, ProfileUncheckedUpdateWithoutCoverPhotoInput>
    create: XOR<ProfileCreateWithoutCoverPhotoInput, ProfileUncheckedCreateWithoutCoverPhotoInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutCoverPhotoInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutCoverPhotoInput, ProfileUncheckedUpdateWithoutCoverPhotoInput>
  }

  export type ProfileUpdateWithoutCoverPhotoInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    image?: FileInstanceUpdateOneWithoutImageOfProfileNestedInput
    eventPreference?: EventTypeUpdateManyWithoutProfileNestedInput
    assets?: FileInstanceUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProfileNestedInput
    venues?: VenueUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutCoverPhotoInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventPreference?: EventTypeUncheckedUpdateManyWithoutProfileNestedInput
    assets?: FileInstanceUncheckedUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUncheckedUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUncheckedUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProfileNestedInput
    venues?: VenueUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type EventTypeUpsertWithoutAvatarInput = {
    update: XOR<EventTypeUpdateWithoutAvatarInput, EventTypeUncheckedUpdateWithoutAvatarInput>
    create: XOR<EventTypeCreateWithoutAvatarInput, EventTypeUncheckedCreateWithoutAvatarInput>
    where?: EventTypeWhereInput
  }

  export type EventTypeUpdateToOneWithWhereWithoutAvatarInput = {
    where?: EventTypeWhereInput
    data: XOR<EventTypeUpdateWithoutAvatarInput, EventTypeUncheckedUpdateWithoutAvatarInput>
  }

  export type EventTypeUpdateWithoutAvatarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUpdateManyWithoutEventPreferenceNestedInput
    Booking?: BookingUpdateOneWithoutEventTypeNestedInput
  }

  export type EventTypeUncheckedUpdateWithoutAvatarInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    profile?: ProfileUncheckedUpdateManyWithoutEventPreferenceNestedInput
  }

  export type ProfileUpsertWithoutAssetsInput = {
    update: XOR<ProfileUpdateWithoutAssetsInput, ProfileUncheckedUpdateWithoutAssetsInput>
    create: XOR<ProfileCreateWithoutAssetsInput, ProfileUncheckedCreateWithoutAssetsInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutAssetsInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutAssetsInput, ProfileUncheckedUpdateWithoutAssetsInput>
  }

  export type ProfileUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    image?: FileInstanceUpdateOneWithoutImageOfProfileNestedInput
    eventPreference?: EventTypeUpdateManyWithoutProfileNestedInput
    coverPhoto?: FileInstanceUpdateOneWithoutCoverPhotoOfProfileNestedInput
    directMessages?: DirectMessageUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProfileNestedInput
    venues?: VenueUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutAssetsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoId?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventPreference?: EventTypeUncheckedUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUncheckedUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUncheckedUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProfileNestedInput
    venues?: VenueUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type DirectMessageUpsertWithoutFileInput = {
    update: XOR<DirectMessageUpdateWithoutFileInput, DirectMessageUncheckedUpdateWithoutFileInput>
    create: XOR<DirectMessageCreateWithoutFileInput, DirectMessageUncheckedCreateWithoutFileInput>
    where?: DirectMessageWhereInput
  }

  export type DirectMessageUpdateToOneWithWhereWithoutFileInput = {
    where?: DirectMessageWhereInput
    data: XOR<DirectMessageUpdateWithoutFileInput, DirectMessageUncheckedUpdateWithoutFileInput>
  }

  export type DirectMessageUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    member?: ProfileUpdateOneRequiredWithoutDirectMessagesNestedInput
    conversation?: ConversationUpdateOneRequiredWithoutDirectMessagesNestedInput
  }

  export type DirectMessageUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileCreateWithoutConversationsInitiatedInput = {
    id?: string
    gender: $Enums.Gender
    location?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    image?: FileInstanceCreateNestedOneWithoutImageOfProfileInput
    eventPreference?: EventTypeCreateNestedManyWithoutProfileInput
    coverPhoto?: FileInstanceCreateNestedOneWithoutCoverPhotoOfProfileInput
    assets?: FileInstanceCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageCreateNestedManyWithoutMemberInput
    conversationsReceived?: ConversationCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewCreateNestedManyWithoutProfileInput
    venues?: VenueCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutConversationsInitiatedInput = {
    id?: string
    userId: string
    gender: $Enums.Gender
    imageId?: string | null
    location?: string | null
    coverPhotoId?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventPreference?: EventTypeUncheckedCreateNestedManyWithoutProfileInput
    assets?: FileInstanceUncheckedCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageUncheckedCreateNestedManyWithoutMemberInput
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingUncheckedCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProfileInput
    venues?: VenueUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutConversationsInitiatedInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutConversationsInitiatedInput, ProfileUncheckedCreateWithoutConversationsInitiatedInput>
  }

  export type ProfileCreateWithoutConversationsReceivedInput = {
    id?: string
    gender: $Enums.Gender
    location?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    image?: FileInstanceCreateNestedOneWithoutImageOfProfileInput
    eventPreference?: EventTypeCreateNestedManyWithoutProfileInput
    coverPhoto?: FileInstanceCreateNestedOneWithoutCoverPhotoOfProfileInput
    assets?: FileInstanceCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutMemberOneInput
    bookingToVenue?: BookingCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewCreateNestedManyWithoutProfileInput
    venues?: VenueCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutConversationsReceivedInput = {
    id?: string
    userId: string
    gender: $Enums.Gender
    imageId?: string | null
    location?: string | null
    coverPhotoId?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventPreference?: EventTypeUncheckedCreateNestedManyWithoutProfileInput
    assets?: FileInstanceUncheckedCreateNestedManyWithoutProfileInput
    directMessages?: DirectMessageUncheckedCreateNestedManyWithoutMemberInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutMemberOneInput
    bookingToVenue?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingUncheckedCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProfileInput
    venues?: VenueUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutConversationsReceivedInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutConversationsReceivedInput, ProfileUncheckedCreateWithoutConversationsReceivedInput>
  }

  export type DirectMessageCreateWithoutConversationInput = {
    id?: string
    content: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    file?: FileInstanceCreateNestedOneWithoutDirectMessageInput
    member: ProfileCreateNestedOneWithoutDirectMessagesInput
  }

  export type DirectMessageUncheckedCreateWithoutConversationInput = {
    id?: string
    content: string
    memberId: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    file?: FileInstanceUncheckedCreateNestedOneWithoutDirectMessageInput
  }

  export type DirectMessageCreateOrConnectWithoutConversationInput = {
    where: DirectMessageWhereUniqueInput
    create: XOR<DirectMessageCreateWithoutConversationInput, DirectMessageUncheckedCreateWithoutConversationInput>
  }

  export type DirectMessageCreateManyConversationInputEnvelope = {
    data: DirectMessageCreateManyConversationInput | DirectMessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type ProfileUpsertWithoutConversationsInitiatedInput = {
    update: XOR<ProfileUpdateWithoutConversationsInitiatedInput, ProfileUncheckedUpdateWithoutConversationsInitiatedInput>
    create: XOR<ProfileCreateWithoutConversationsInitiatedInput, ProfileUncheckedCreateWithoutConversationsInitiatedInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutConversationsInitiatedInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutConversationsInitiatedInput, ProfileUncheckedUpdateWithoutConversationsInitiatedInput>
  }

  export type ProfileUpdateWithoutConversationsInitiatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    image?: FileInstanceUpdateOneWithoutImageOfProfileNestedInput
    eventPreference?: EventTypeUpdateManyWithoutProfileNestedInput
    coverPhoto?: FileInstanceUpdateOneWithoutCoverPhotoOfProfileNestedInput
    assets?: FileInstanceUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUpdateManyWithoutMemberNestedInput
    conversationsReceived?: ConversationUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProfileNestedInput
    venues?: VenueUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutConversationsInitiatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoId?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventPreference?: EventTypeUncheckedUpdateManyWithoutProfileNestedInput
    assets?: FileInstanceUncheckedUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUncheckedUpdateManyWithoutMemberNestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUncheckedUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProfileNestedInput
    venues?: VenueUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUpsertWithoutConversationsReceivedInput = {
    update: XOR<ProfileUpdateWithoutConversationsReceivedInput, ProfileUncheckedUpdateWithoutConversationsReceivedInput>
    create: XOR<ProfileCreateWithoutConversationsReceivedInput, ProfileUncheckedCreateWithoutConversationsReceivedInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutConversationsReceivedInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutConversationsReceivedInput, ProfileUncheckedUpdateWithoutConversationsReceivedInput>
  }

  export type ProfileUpdateWithoutConversationsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    image?: FileInstanceUpdateOneWithoutImageOfProfileNestedInput
    eventPreference?: EventTypeUpdateManyWithoutProfileNestedInput
    coverPhoto?: FileInstanceUpdateOneWithoutCoverPhotoOfProfileNestedInput
    assets?: FileInstanceUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutMemberOneNestedInput
    bookingToVenue?: BookingUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProfileNestedInput
    venues?: VenueUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutConversationsReceivedInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoId?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventPreference?: EventTypeUncheckedUpdateManyWithoutProfileNestedInput
    assets?: FileInstanceUncheckedUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUncheckedUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutMemberOneNestedInput
    bookingToVenue?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUncheckedUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProfileNestedInput
    venues?: VenueUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type DirectMessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: DirectMessageWhereUniqueInput
    update: XOR<DirectMessageUpdateWithoutConversationInput, DirectMessageUncheckedUpdateWithoutConversationInput>
    create: XOR<DirectMessageCreateWithoutConversationInput, DirectMessageUncheckedCreateWithoutConversationInput>
  }

  export type DirectMessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: DirectMessageWhereUniqueInput
    data: XOR<DirectMessageUpdateWithoutConversationInput, DirectMessageUncheckedUpdateWithoutConversationInput>
  }

  export type DirectMessageUpdateManyWithWhereWithoutConversationInput = {
    where: DirectMessageScalarWhereInput
    data: XOR<DirectMessageUpdateManyMutationInput, DirectMessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type FileInstanceCreateWithoutDirectMessageInput = {
    id?: string
    name: string
    fileId: string
    path: string
    createdAt?: Date | string
    expiresAt: Date | string
    bucket: string
    type: $Enums.FileType
    Venue?: VenueCreateNestedOneWithoutArrangementsImageInput
    imageOfProfile?: ProfileCreateNestedOneWithoutImageInput
    coverPhotoOfProfile?: ProfileCreateNestedOneWithoutCoverPhotoInput
    EventPreference?: EventTypeCreateNestedOneWithoutAvatarInput
    Profile?: ProfileCreateNestedOneWithoutAssetsInput
  }

  export type FileInstanceUncheckedCreateWithoutDirectMessageInput = {
    id?: string
    name: string
    fileId: string
    path: string
    createdAt?: Date | string
    expiresAt: Date | string
    bucket: string
    type: $Enums.FileType
    venueId?: string | null
    eventPreferenceId?: string | null
    profileId?: string | null
    imageOfProfile?: ProfileUncheckedCreateNestedOneWithoutImageInput
    coverPhotoOfProfile?: ProfileUncheckedCreateNestedOneWithoutCoverPhotoInput
  }

  export type FileInstanceCreateOrConnectWithoutDirectMessageInput = {
    where: FileInstanceWhereUniqueInput
    create: XOR<FileInstanceCreateWithoutDirectMessageInput, FileInstanceUncheckedCreateWithoutDirectMessageInput>
  }

  export type ProfileCreateWithoutDirectMessagesInput = {
    id?: string
    gender: $Enums.Gender
    location?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutProfileInput
    image?: FileInstanceCreateNestedOneWithoutImageOfProfileInput
    eventPreference?: EventTypeCreateNestedManyWithoutProfileInput
    coverPhoto?: FileInstanceCreateNestedOneWithoutCoverPhotoOfProfileInput
    assets?: FileInstanceCreateNestedManyWithoutProfileInput
    conversationsInitiated?: ConversationCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewCreateNestedManyWithoutProfileInput
    venues?: VenueCreateNestedManyWithoutProfileInput
  }

  export type ProfileUncheckedCreateWithoutDirectMessagesInput = {
    id?: string
    userId: string
    gender: $Enums.Gender
    imageId?: string | null
    location?: string | null
    coverPhotoId?: string | null
    profession?: string | null
    description?: string | null
    experience?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    eventPreference?: EventTypeUncheckedCreateNestedManyWithoutProfileInput
    assets?: FileInstanceUncheckedCreateNestedManyWithoutProfileInput
    conversationsInitiated?: ConversationUncheckedCreateNestedManyWithoutMemberOneInput
    conversationsReceived?: ConversationUncheckedCreateNestedManyWithoutMemberTwoInput
    bookingToVenue?: BookingUncheckedCreateNestedManyWithoutBookedByInput
    bookingToServiceProvider?: BookingUncheckedCreateNestedManyWithoutServiceProviderInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProfileInput
    venues?: VenueUncheckedCreateNestedManyWithoutProfileInput
  }

  export type ProfileCreateOrConnectWithoutDirectMessagesInput = {
    where: ProfileWhereUniqueInput
    create: XOR<ProfileCreateWithoutDirectMessagesInput, ProfileUncheckedCreateWithoutDirectMessagesInput>
  }

  export type ConversationCreateWithoutDirectMessagesInput = {
    id?: string
    memberOne: ProfileCreateNestedOneWithoutConversationsInitiatedInput
    memberTwo: ProfileCreateNestedOneWithoutConversationsReceivedInput
  }

  export type ConversationUncheckedCreateWithoutDirectMessagesInput = {
    id?: string
    memberOneId: string
    memberTwoId: string
  }

  export type ConversationCreateOrConnectWithoutDirectMessagesInput = {
    where: ConversationWhereUniqueInput
    create: XOR<ConversationCreateWithoutDirectMessagesInput, ConversationUncheckedCreateWithoutDirectMessagesInput>
  }

  export type FileInstanceUpsertWithoutDirectMessageInput = {
    update: XOR<FileInstanceUpdateWithoutDirectMessageInput, FileInstanceUncheckedUpdateWithoutDirectMessageInput>
    create: XOR<FileInstanceCreateWithoutDirectMessageInput, FileInstanceUncheckedCreateWithoutDirectMessageInput>
    where?: FileInstanceWhereInput
  }

  export type FileInstanceUpdateToOneWithWhereWithoutDirectMessageInput = {
    where?: FileInstanceWhereInput
    data: XOR<FileInstanceUpdateWithoutDirectMessageInput, FileInstanceUncheckedUpdateWithoutDirectMessageInput>
  }

  export type FileInstanceUpdateWithoutDirectMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    Venue?: VenueUpdateOneWithoutArrangementsImageNestedInput
    imageOfProfile?: ProfileUpdateOneWithoutImageNestedInput
    coverPhotoOfProfile?: ProfileUpdateOneWithoutCoverPhotoNestedInput
    EventPreference?: EventTypeUpdateOneWithoutAvatarNestedInput
    Profile?: ProfileUpdateOneWithoutAssetsNestedInput
  }

  export type FileInstanceUncheckedUpdateWithoutDirectMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    eventPreferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    imageOfProfile?: ProfileUncheckedUpdateOneWithoutImageNestedInput
    coverPhotoOfProfile?: ProfileUncheckedUpdateOneWithoutCoverPhotoNestedInput
  }

  export type ProfileUpsertWithoutDirectMessagesInput = {
    update: XOR<ProfileUpdateWithoutDirectMessagesInput, ProfileUncheckedUpdateWithoutDirectMessagesInput>
    create: XOR<ProfileCreateWithoutDirectMessagesInput, ProfileUncheckedCreateWithoutDirectMessagesInput>
    where?: ProfileWhereInput
  }

  export type ProfileUpdateToOneWithWhereWithoutDirectMessagesInput = {
    where?: ProfileWhereInput
    data: XOR<ProfileUpdateWithoutDirectMessagesInput, ProfileUncheckedUpdateWithoutDirectMessagesInput>
  }

  export type ProfileUpdateWithoutDirectMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    image?: FileInstanceUpdateOneWithoutImageOfProfileNestedInput
    eventPreference?: EventTypeUpdateManyWithoutProfileNestedInput
    coverPhoto?: FileInstanceUpdateOneWithoutCoverPhotoOfProfileNestedInput
    assets?: FileInstanceUpdateManyWithoutProfileNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProfileNestedInput
    venues?: VenueUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutDirectMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoId?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventPreference?: EventTypeUncheckedUpdateManyWithoutProfileNestedInput
    assets?: FileInstanceUncheckedUpdateManyWithoutProfileNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUncheckedUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProfileNestedInput
    venues?: VenueUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ConversationUpsertWithoutDirectMessagesInput = {
    update: XOR<ConversationUpdateWithoutDirectMessagesInput, ConversationUncheckedUpdateWithoutDirectMessagesInput>
    create: XOR<ConversationCreateWithoutDirectMessagesInput, ConversationUncheckedCreateWithoutDirectMessagesInput>
    where?: ConversationWhereInput
  }

  export type ConversationUpdateToOneWithWhereWithoutDirectMessagesInput = {
    where?: ConversationWhereInput
    data: XOR<ConversationUpdateWithoutDirectMessagesInput, ConversationUncheckedUpdateWithoutDirectMessagesInput>
  }

  export type ConversationUpdateWithoutDirectMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberOne?: ProfileUpdateOneRequiredWithoutConversationsInitiatedNestedInput
    memberTwo?: ProfileUpdateOneRequiredWithoutConversationsReceivedNestedInput
  }

  export type ConversationUncheckedUpdateWithoutDirectMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberOneId?: StringFieldUpdateOperationsInput | string
    memberTwoId?: StringFieldUpdateOperationsInput | string
  }

  export type FileInstanceCreateManyProfileInput = {
    id?: string
    name: string
    fileId: string
    path: string
    createdAt?: Date | string
    expiresAt: Date | string
    bucket: string
    type: $Enums.FileType
    venueId?: string | null
    eventPreferenceId?: string | null
    directMessageId?: string | null
  }

  export type DirectMessageCreateManyMemberInput = {
    id?: string
    content: string
    conversationId: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ConversationCreateManyMemberOneInput = {
    id?: string
    memberTwoId: string
  }

  export type ConversationCreateManyMemberTwoInput = {
    id?: string
    memberOneId: string
  }

  export type BookingCreateManyBookedByInput = {
    id?: string
    venueId?: string | null
    serviceProviderId?: string | null
    eventName: string
    location: string
    plannerName: string
    selectedDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    bookingType: $Enums.BookingType
    guestNumber: number
    decoration?: string | null
    services?: BookingCreateservicesInput | string[]
    totalCost: number
    bookingStatus?: $Enums.BookingStatus
    totalAmount?: number
    paid?: number
    due?: number
    accept: $Enums.AcceptanceStatus
    isEventFinished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyServiceProviderInput = {
    id?: string
    bookedById: string
    venueId?: string | null
    eventName: string
    location: string
    plannerName: string
    selectedDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    bookingType: $Enums.BookingType
    guestNumber: number
    decoration?: string | null
    services?: BookingCreateservicesInput | string[]
    totalCost: number
    bookingStatus?: $Enums.BookingStatus
    totalAmount?: number
    paid?: number
    due?: number
    accept: $Enums.AcceptanceStatus
    isEventFinished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyProfileInput = {
    id?: string
    venueId: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
  }

  export type VenueCreateManyProfileInput = {
    id?: string
    name: string
    city: string
    area: string
    description?: string | null
    capacity: number
    bookedDates?: VenueCreatebookedDatesInput | Date[] | string[]
    type: $Enums.VenueType
    cateringDescription?: string | null
    parkingDescription?: string | null
    availabilityDescription?: string | null
    extraServiceDescription?: string | null
    price: number
    bookingType: $Enums.BookingType
    verified?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventTypeUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    avatar?: FileInstanceUpdateOneWithoutEventPreferenceNestedInput
    Booking?: BookingUpdateOneWithoutEventTypeNestedInput
  }

  export type EventTypeUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
    avatar?: FileInstanceUncheckedUpdateOneWithoutEventPreferenceNestedInput
  }

  export type EventTypeUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    bookingId?: StringFieldUpdateOperationsInput | string
  }

  export type FileInstanceUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    Venue?: VenueUpdateOneWithoutArrangementsImageNestedInput
    imageOfProfile?: ProfileUpdateOneWithoutImageNestedInput
    coverPhotoOfProfile?: ProfileUpdateOneWithoutCoverPhotoNestedInput
    EventPreference?: EventTypeUpdateOneWithoutAvatarNestedInput
    DirectMessage?: DirectMessageUpdateOneWithoutFileNestedInput
  }

  export type FileInstanceUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    eventPreferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    directMessageId?: NullableStringFieldUpdateOperationsInput | string | null
    imageOfProfile?: ProfileUncheckedUpdateOneWithoutImageNestedInput
    coverPhotoOfProfile?: ProfileUncheckedUpdateOneWithoutCoverPhotoNestedInput
  }

  export type FileInstanceUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    fileId?: StringFieldUpdateOperationsInput | string
    path?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bucket?: StringFieldUpdateOperationsInput | string
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    eventPreferenceId?: NullableStringFieldUpdateOperationsInput | string | null
    directMessageId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DirectMessageUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FileInstanceUpdateOneWithoutDirectMessageNestedInput
    conversation?: ConversationUpdateOneRequiredWithoutDirectMessagesNestedInput
  }

  export type DirectMessageUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FileInstanceUncheckedUpdateOneWithoutDirectMessageNestedInput
  }

  export type DirectMessageUncheckedUpdateManyWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConversationUpdateWithoutMemberOneInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberTwo?: ProfileUpdateOneRequiredWithoutConversationsReceivedNestedInput
    directMessages?: DirectMessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMemberOneInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberTwoId?: StringFieldUpdateOperationsInput | string
    directMessages?: DirectMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutMemberOneInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberTwoId?: StringFieldUpdateOperationsInput | string
  }

  export type ConversationUpdateWithoutMemberTwoInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberOne?: ProfileUpdateOneRequiredWithoutConversationsInitiatedNestedInput
    directMessages?: DirectMessageUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateWithoutMemberTwoInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberOneId?: StringFieldUpdateOperationsInput | string
    directMessages?: DirectMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type ConversationUncheckedUpdateManyWithoutMemberTwoInput = {
    id?: StringFieldUpdateOperationsInput | string
    memberOneId?: StringFieldUpdateOperationsInput | string
  }

  export type BookingUpdateWithoutBookedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    plannerName?: StringFieldUpdateOperationsInput | string
    selectedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    guestNumber?: IntFieldUpdateOperationsInput | number
    decoration?: NullableStringFieldUpdateOperationsInput | string | null
    services?: BookingUpdateservicesInput | string[]
    totalCost?: IntFieldUpdateOperationsInput | number
    bookingStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    due?: IntFieldUpdateOperationsInput | number
    accept?: EnumAcceptanceStatusFieldUpdateOperationsInput | $Enums.AcceptanceStatus
    isEventFinished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneWithoutBookingsNestedInput
    serviceProvider?: ProfileUpdateOneWithoutBookingToServiceProviderNestedInput
    eventType?: EventTypeUpdateOneWithoutBookingNestedInput
    payment?: PaymentUpdateManyWithoutBookingInfoNestedInput
  }

  export type BookingUncheckedUpdateWithoutBookedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    plannerName?: StringFieldUpdateOperationsInput | string
    selectedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    guestNumber?: IntFieldUpdateOperationsInput | number
    decoration?: NullableStringFieldUpdateOperationsInput | string | null
    services?: BookingUpdateservicesInput | string[]
    totalCost?: IntFieldUpdateOperationsInput | number
    bookingStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    due?: IntFieldUpdateOperationsInput | number
    accept?: EnumAcceptanceStatusFieldUpdateOperationsInput | $Enums.AcceptanceStatus
    isEventFinished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EventTypeUncheckedUpdateOneWithoutBookingNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutBookingInfoNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutBookedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    plannerName?: StringFieldUpdateOperationsInput | string
    selectedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    guestNumber?: IntFieldUpdateOperationsInput | number
    decoration?: NullableStringFieldUpdateOperationsInput | string | null
    services?: BookingUpdateservicesInput | string[]
    totalCost?: IntFieldUpdateOperationsInput | number
    bookingStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    due?: IntFieldUpdateOperationsInput | number
    accept?: EnumAcceptanceStatusFieldUpdateOperationsInput | $Enums.AcceptanceStatus
    isEventFinished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    plannerName?: StringFieldUpdateOperationsInput | string
    selectedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    guestNumber?: IntFieldUpdateOperationsInput | number
    decoration?: NullableStringFieldUpdateOperationsInput | string | null
    services?: BookingUpdateservicesInput | string[]
    totalCost?: IntFieldUpdateOperationsInput | number
    bookingStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    due?: IntFieldUpdateOperationsInput | number
    accept?: EnumAcceptanceStatusFieldUpdateOperationsInput | $Enums.AcceptanceStatus
    isEventFinished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedBy?: ProfileUpdateOneRequiredWithoutBookingToVenueNestedInput
    venue?: VenueUpdateOneWithoutBookingsNestedInput
    eventType?: EventTypeUpdateOneWithoutBookingNestedInput
    payment?: PaymentUpdateManyWithoutBookingInfoNestedInput
  }

  export type BookingUncheckedUpdateWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookedById?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    plannerName?: StringFieldUpdateOperationsInput | string
    selectedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    guestNumber?: IntFieldUpdateOperationsInput | number
    decoration?: NullableStringFieldUpdateOperationsInput | string | null
    services?: BookingUpdateservicesInput | string[]
    totalCost?: IntFieldUpdateOperationsInput | number
    bookingStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    due?: IntFieldUpdateOperationsInput | number
    accept?: EnumAcceptanceStatusFieldUpdateOperationsInput | $Enums.AcceptanceStatus
    isEventFinished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EventTypeUncheckedUpdateOneWithoutBookingNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutBookingInfoNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutServiceProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookedById?: StringFieldUpdateOperationsInput | string
    venueId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    plannerName?: StringFieldUpdateOperationsInput | string
    selectedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    guestNumber?: IntFieldUpdateOperationsInput | number
    decoration?: NullableStringFieldUpdateOperationsInput | string | null
    services?: BookingUpdateservicesInput | string[]
    totalCost?: IntFieldUpdateOperationsInput | number
    bookingStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    due?: IntFieldUpdateOperationsInput | number
    accept?: EnumAcceptanceStatusFieldUpdateOperationsInput | $Enums.AcceptanceStatus
    isEventFinished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Venue?: VenueUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: AmenitiesUpdateManyWithoutVenueNestedInput
    arrangementsImage?: FileInstanceUpdateOneWithoutVenueNestedInput
    shifts?: ShiftUpdateManyWithoutVenueNestedInput
    reviews?: ReviewUpdateManyWithoutVenueNestedInput
    decoration?: DecorationUpdateOneWithoutVenueNestedInput
    employees?: EmployeeUpdateManyWithoutVenueNestedInput
    bookings?: BookingUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    amenities?: AmenitiesUncheckedUpdateManyWithoutVenueNestedInput
    arrangementsImage?: FileInstanceUncheckedUpdateOneWithoutVenueNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutVenueNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutVenueNestedInput
    decoration?: DecorationUncheckedUpdateOneWithoutVenueNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutVenueNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateManyWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProfileUpdateWithoutEventPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    location?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutProfileNestedInput
    image?: FileInstanceUpdateOneWithoutImageOfProfileNestedInput
    coverPhoto?: FileInstanceUpdateOneWithoutCoverPhotoOfProfileNestedInput
    assets?: FileInstanceUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUpdateManyWithoutProfileNestedInput
    venues?: VenueUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateWithoutEventPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoId?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    assets?: FileInstanceUncheckedUpdateManyWithoutProfileNestedInput
    directMessages?: DirectMessageUncheckedUpdateManyWithoutMemberNestedInput
    conversationsInitiated?: ConversationUncheckedUpdateManyWithoutMemberOneNestedInput
    conversationsReceived?: ConversationUncheckedUpdateManyWithoutMemberTwoNestedInput
    bookingToVenue?: BookingUncheckedUpdateManyWithoutBookedByNestedInput
    bookingToServiceProvider?: BookingUncheckedUpdateManyWithoutServiceProviderNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProfileNestedInput
    venues?: VenueUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type ProfileUncheckedUpdateManyWithoutEventPreferenceInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    gender?: EnumGenderFieldUpdateOperationsInput | $Enums.Gender
    imageId?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    coverPhotoId?: NullableStringFieldUpdateOperationsInput | string | null
    profession?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    experience?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftCreateManyVenueInput = {
    id?: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    shiftName: string
    employeeId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyVenueInput = {
    id?: string
    rating: number
    comment?: string | null
    createdAt?: Date | string
    profileId?: string | null
  }

  export type EmployeeCreateManyVenueInput = {
    id?: string
    firstName: string
    lastName: string
    email: string
    phone: string
    role: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BookingCreateManyVenueInput = {
    id?: string
    bookedById: string
    serviceProviderId?: string | null
    eventName: string
    location: string
    plannerName: string
    selectedDate: Date | string
    startTime: Date | string
    endTime: Date | string
    duration: number
    bookingType: $Enums.BookingType
    guestNumber: number
    decoration?: string | null
    services?: BookingCreateservicesInput | string[]
    totalCost: number
    bookingStatus?: $Enums.BookingStatus
    totalAmount?: number
    paid?: number
    due?: number
    accept: $Enums.AcceptanceStatus
    isEventFinished?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AmenitiesUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AmenitiesUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AmenitiesUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    default?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ShiftUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    shiftName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutShiftsNestedInput
  }

  export type ShiftUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    shiftName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    shiftName?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Profile?: ProfileUpdateOneWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ReviewUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    comment?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EmployeeUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    shifts?: ShiftUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BookingUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    plannerName?: StringFieldUpdateOperationsInput | string
    selectedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    guestNumber?: IntFieldUpdateOperationsInput | number
    decoration?: NullableStringFieldUpdateOperationsInput | string | null
    services?: BookingUpdateservicesInput | string[]
    totalCost?: IntFieldUpdateOperationsInput | number
    bookingStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    due?: IntFieldUpdateOperationsInput | number
    accept?: EnumAcceptanceStatusFieldUpdateOperationsInput | $Enums.AcceptanceStatus
    isEventFinished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bookedBy?: ProfileUpdateOneRequiredWithoutBookingToVenueNestedInput
    serviceProvider?: ProfileUpdateOneWithoutBookingToServiceProviderNestedInput
    eventType?: EventTypeUpdateOneWithoutBookingNestedInput
    payment?: PaymentUpdateManyWithoutBookingInfoNestedInput
  }

  export type BookingUncheckedUpdateWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookedById?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    plannerName?: StringFieldUpdateOperationsInput | string
    selectedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    guestNumber?: IntFieldUpdateOperationsInput | number
    decoration?: NullableStringFieldUpdateOperationsInput | string | null
    services?: BookingUpdateservicesInput | string[]
    totalCost?: IntFieldUpdateOperationsInput | number
    bookingStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    due?: IntFieldUpdateOperationsInput | number
    accept?: EnumAcceptanceStatusFieldUpdateOperationsInput | $Enums.AcceptanceStatus
    isEventFinished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    eventType?: EventTypeUncheckedUpdateOneWithoutBookingNestedInput
    payment?: PaymentUncheckedUpdateManyWithoutBookingInfoNestedInput
  }

  export type BookingUncheckedUpdateManyWithoutVenueInput = {
    id?: StringFieldUpdateOperationsInput | string
    bookedById?: StringFieldUpdateOperationsInput | string
    serviceProviderId?: NullableStringFieldUpdateOperationsInput | string | null
    eventName?: StringFieldUpdateOperationsInput | string
    location?: StringFieldUpdateOperationsInput | string
    plannerName?: StringFieldUpdateOperationsInput | string
    selectedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    guestNumber?: IntFieldUpdateOperationsInput | number
    decoration?: NullableStringFieldUpdateOperationsInput | string | null
    services?: BookingUpdateservicesInput | string[]
    totalCost?: IntFieldUpdateOperationsInput | number
    bookingStatus?: EnumBookingStatusFieldUpdateOperationsInput | $Enums.BookingStatus
    totalAmount?: IntFieldUpdateOperationsInput | number
    paid?: IntFieldUpdateOperationsInput | number
    due?: IntFieldUpdateOperationsInput | number
    accept?: EnumAcceptanceStatusFieldUpdateOperationsInput | $Enums.AcceptanceStatus
    isEventFinished?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftCreateManyEmployeeInput = {
    id?: string
    venueId: string
    startTime: Date | string
    endTime: Date | string
    duration: number
    shiftName: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    shiftName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    venue?: VenueUpdateOneRequiredWithoutShiftsNestedInput
  }

  export type ShiftUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    shiftName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    venueId?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: IntFieldUpdateOperationsInput | number
    shiftName?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyBookingInfoInput = {
    id?: string
    paymentStatus: $Enums.PaymentStatus
    paymentMethod: $Enums.PaymentMethod
    amount: number
    transactionId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentUpdateWithoutBookingInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutBookingInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutBookingInfoInput = {
    id?: StringFieldUpdateOperationsInput | string
    paymentStatus?: EnumPaymentStatusFieldUpdateOperationsInput | $Enums.PaymentStatus
    paymentMethod?: EnumPaymentMethodFieldUpdateOperationsInput | $Enums.PaymentMethod
    amount?: IntFieldUpdateOperationsInput | number
    transactionId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VenueUpdateWithoutAmenitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Profile?: ProfileUpdateOneWithoutVenuesNestedInput
    arrangementsImage?: FileInstanceUpdateOneWithoutVenueNestedInput
    shifts?: ShiftUpdateManyWithoutVenueNestedInput
    reviews?: ReviewUpdateManyWithoutVenueNestedInput
    decoration?: DecorationUpdateOneWithoutVenueNestedInput
    employees?: EmployeeUpdateManyWithoutVenueNestedInput
    bookings?: BookingUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateWithoutAmenitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    arrangementsImage?: FileInstanceUncheckedUpdateOneWithoutVenueNestedInput
    shifts?: ShiftUncheckedUpdateManyWithoutVenueNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutVenueNestedInput
    decoration?: DecorationUncheckedUpdateOneWithoutVenueNestedInput
    employees?: EmployeeUncheckedUpdateManyWithoutVenueNestedInput
    bookings?: BookingUncheckedUpdateManyWithoutVenueNestedInput
  }

  export type VenueUncheckedUpdateManyWithoutAmenitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileId?: NullableStringFieldUpdateOperationsInput | string | null
    name?: StringFieldUpdateOperationsInput | string
    city?: StringFieldUpdateOperationsInput | string
    area?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    capacity?: IntFieldUpdateOperationsInput | number
    bookedDates?: VenueUpdatebookedDatesInput | Date[] | string[]
    type?: EnumVenueTypeFieldUpdateOperationsInput | $Enums.VenueType
    cateringDescription?: NullableStringFieldUpdateOperationsInput | string | null
    parkingDescription?: NullableStringFieldUpdateOperationsInput | string | null
    availabilityDescription?: NullableStringFieldUpdateOperationsInput | string | null
    extraServiceDescription?: NullableStringFieldUpdateOperationsInput | string | null
    price?: IntFieldUpdateOperationsInput | number
    bookingType?: EnumBookingTypeFieldUpdateOperationsInput | $Enums.BookingType
    verified?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DirectMessageCreateManyConversationInput = {
    id?: string
    content: string
    memberId: string
    deleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DirectMessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FileInstanceUpdateOneWithoutDirectMessageNestedInput
    member?: ProfileUpdateOneRequiredWithoutDirectMessagesNestedInput
  }

  export type DirectMessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FileInstanceUncheckedUpdateOneWithoutDirectMessageNestedInput
  }

  export type DirectMessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    memberId?: StringFieldUpdateOperationsInput | string
    deleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}